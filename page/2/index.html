<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT">










<meta name="description" content="生活不只眼前的苟且，还有诗和远方的田野">
<meta property="og:type" content="website">
<meta property="og:title" content="jasonjie">
<meta property="og:url" content="http://denglinjie.com/page/2/index.html">
<meta property="og:site_name" content="jasonjie">
<meta property="og:description" content="生活不只眼前的苟且，还有诗和远方的田野">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="jasonjie">
<meta name="twitter:description" content="生活不只眼前的苟且，还有诗和远方的田野">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://denglinjie.com/page/2/">





  <title>jasonjie</title>
  








</head>

<body itemscope="" itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope="" itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">jasonjie</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br>
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://denglinjie.com/2017/09/08/2017-09-08-Spring源码分析之SpringMVC的DispatcherServlet是如何处理Http请求的/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="jasonjie">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="jasonjie">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/09/08/2017-09-08-Spring源码分析之SpringMVC的DispatcherServlet是如何处理Http请求的/" itemprop="url">Spring源码分析之SpringMVC的DispatcherServlet是如何处理Http请求的</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-09-08T00:00:00+08:00">
                2017-09-08
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>一般我们会在web.xml文件中配置DispatcherServlet，比如如下配置方式：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;servlet&gt;  </span><br><span class="line">        &lt;servlet-name&gt;dispatcherServlet&lt;/servlet-name&gt;  </span><br><span class="line">        &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt;  </span><br><span class="line">        &lt;init-param&gt;  </span><br><span class="line">            &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;  </span><br><span class="line">            &lt;param-value&gt;classpath:dispatcher-servlet.xml&lt;/param-value&gt;  </span><br><span class="line">        &lt;/init-param&gt;  </span><br><span class="line">        &lt;load-on-startup&gt;1&lt;/load-on-startup&gt;  </span><br><span class="line">    &lt;/servlet&gt;  </span><br><span class="line">      </span><br><span class="line">    &lt;servlet-mapping&gt;  </span><br><span class="line">        &lt;servlet-name&gt;dispatcherServlet&lt;/servlet-name&gt;  </span><br><span class="line">        &lt;url-pattern&gt;/&lt;/url-pattern&gt;  </span><br><span class="line">    &lt;/servlet-mapping&gt;</span><br></pre></td></tr></table></figure></p>
<p>上述代码配置了所有路径的http请求都会交给DispatcherServlet来处理<br>那么我们来看下DispatcherServlet的具体代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">@SuppressWarnings(&quot;serial&quot;)  </span><br><span class="line">public class DispatcherServlet extends FrameworkServlet &#123;  </span><br><span class="line">    public DispatcherServlet(WebApplicationContext webApplicationContext) &#123;  </span><br><span class="line">        super(webApplicationContext);  </span><br><span class="line">        setDispatchOptionsRequest(true);  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    @Override  </span><br><span class="line">    protected void onRefresh(ApplicationContext context) &#123;  </span><br><span class="line">        initStrategies(context);  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    /**  </span><br><span class="line">     * Initialize the strategy objects that this servlet uses.  </span><br><span class="line">     * &lt;p&gt;May be overridden in subclasses in order to initialize further strategy objects.  </span><br><span class="line">     */  </span><br><span class="line">    protected void initStrategies(ApplicationContext context) &#123;  </span><br><span class="line">        initMultipartResolver(context);  </span><br><span class="line">        initLocaleResolver(context);  </span><br><span class="line">        initThemeResolver(context);  </span><br><span class="line">        initHandlerMappings(context);  </span><br><span class="line">        initHandlerAdapters(context);  </span><br><span class="line">        initHandlerExceptionResolvers(context);  </span><br><span class="line">        initRequestToViewNameTranslator(context);  </span><br><span class="line">        initViewResolvers(context);  </span><br><span class="line">        initFlashMapManager(context);  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">    @Override  </span><br><span class="line">    protected void doService(HttpServletRequest request, HttpServletResponse response) throws Exception &#123;  </span><br><span class="line">          </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">    protected void doDispatch(HttpServletRequest request, HttpServletResponse response) throws Exception &#123;  </span><br><span class="line">          </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>可以看到这个类继承了FrameworkServlet类，再来看下这个类的代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line">@SuppressWarnings(&quot;serial&quot;)  </span><br><span class="line">public abstract class FrameworkServlet extends HttpServletBean implements ApplicationContextAware &#123;  </span><br><span class="line">  </span><br><span class="line">    @Override  </span><br><span class="line">    protected final void initServletBean() throws ServletException &#123;  </span><br><span class="line">          </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    protected WebApplicationContext initWebApplicationContext() &#123;  </span><br><span class="line">  </span><br><span class="line">        if (!this.refreshEventReceived) &#123;  </span><br><span class="line">            // Either the context is not a ConfigurableApplicationContext with refresh  </span><br><span class="line">            // support or the context injected at construction time had already been  </span><br><span class="line">            // refreshed -&gt; trigger initial onRefresh manually here.  </span><br><span class="line">            onRefresh(wac);  </span><br><span class="line">        &#125;  </span><br><span class="line">  </span><br><span class="line">          </span><br><span class="line">    &#125;  </span><br><span class="line">    @Override  </span><br><span class="line">    public void destroy() &#123;  </span><br><span class="line">        getServletContext().log(&quot;Destroying Spring FrameworkServlet &apos;&quot; + getServletName() + &quot;&apos;&quot;);  </span><br><span class="line">        // Only call close() on WebApplicationContext if locally managed...  </span><br><span class="line">        if (this.webApplicationContext instanceof ConfigurableApplicationContext &amp;&amp; !this.webApplicationContextInjected) &#123;  </span><br><span class="line">            ((ConfigurableApplicationContext) this.webApplicationContext).close();  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">    /**  </span><br><span class="line">     * Override the parent class implementation in order to intercept PATCH requests.  </span><br><span class="line">     */  </span><br><span class="line">    @Override  </span><br><span class="line">    protected void service(HttpServletRequest request, HttpServletResponse response)  </span><br><span class="line">            throws ServletException, IOException &#123;  </span><br><span class="line">  </span><br><span class="line">        HttpMethod httpMethod = HttpMethod.resolve(request.getMethod());  </span><br><span class="line">        if (HttpMethod.PATCH == httpMethod || httpMethod == null) &#123;  </span><br><span class="line">            processRequest(request, response);  </span><br><span class="line">        &#125;  </span><br><span class="line">        else &#123;  </span><br><span class="line">            super.service(request, response);  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">      </span><br><span class="line">    @Override  </span><br><span class="line">    protected final void doGet(HttpServletRequest request, HttpServletResponse response)  </span><br><span class="line">            throws ServletException, IOException &#123;  </span><br><span class="line">  </span><br><span class="line">        processRequest(request, response);  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">      </span><br><span class="line">    @Override  </span><br><span class="line">    protected final void doPost(HttpServletRequest request, HttpServletResponse response)  </span><br><span class="line">            throws ServletException, IOException &#123;  </span><br><span class="line">  </span><br><span class="line">        processRequest(request, response);  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    protected final void processRequest(HttpServletRequest request, HttpServletResponse response)  </span><br><span class="line">            throws ServletException, IOException &#123;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>可以看到这个类继承了HttpServletBean类，而HttpServletBean类又继承了HttpServlet类，其中HttpServlet类的init，destroy，service三个方法负责管理Servlet的生命周期。<br>init方法：负责初始化Servlet对象<br>destroy方法：负责销毁Servlet对象<br>service方法：负责处理http请求<br>由于HttpServletBean实现了HttpServlet的init方法，可以看到该方法的代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">public final void init() throws ServletException &#123;  </span><br><span class="line">        if (logger.isDebugEnabled()) &#123;  </span><br><span class="line">            logger.debug(&quot;Initializing servlet &apos;&quot; + getServletName() + &quot;&apos;&quot;);  </span><br><span class="line">        &#125;  </span><br><span class="line">  </span><br><span class="line">        // Set bean properties from init parameters.  </span><br><span class="line">        // 获取servlet初始化的参数,对Bean属性进行配置  </span><br><span class="line">        try &#123;  </span><br><span class="line">            PropertyValues pvs = new ServletConfigPropertyValues(getServletConfig(), this.requiredProperties);  </span><br><span class="line">            BeanWrapper bw = PropertyAccessorFactory.forBeanPropertyAccess(this);  </span><br><span class="line">            ResourceLoader resourceLoader = new ServletContextResourceLoader(getServletContext());  </span><br><span class="line">            bw.registerCustomEditor(Resource.class, new ResourceEditor(resourceLoader, getEnvironment()));  </span><br><span class="line">            initBeanWrapper(bw);  </span><br><span class="line">            bw.setPropertyValues(pvs, true);  </span><br><span class="line">        &#125;  </span><br><span class="line">        catch (BeansException ex) &#123;  </span><br><span class="line">            logger.error(&quot;Failed to set bean properties on servlet &apos;&quot; + getServletName() + &quot;&apos;&quot;, ex);  </span><br><span class="line">            throw ex;  </span><br><span class="line">        &#125;  </span><br><span class="line">  </span><br><span class="line">        // Let subclasses do whatever initialization they like.  </span><br><span class="line">        // 调用子类的initServletBean进行具体的初始化  </span><br><span class="line">        initServletBean();  </span><br><span class="line">  </span><br><span class="line">        if (logger.isDebugEnabled()) &#123;  </span><br><span class="line">            logger.debug(&quot;Servlet &apos;&quot; + getServletName() + &quot;&apos; configured successfully&quot;);  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>这里会读取配置在ServletContext中的Bean属性参数，这里可以看到对PropertyValues和BeanWrapper的使用，这里就完成了对Servlet的初始化<br>接着调用了initServletBean方法来初始化DispatcherServlet持有的IOC容器，当然底层其实是调用initWebApplicationContext方法来初始化，其代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">protected WebApplicationContext initWebApplicationContext() &#123;  </span><br><span class="line">        // 得到根上下文,这个根上下文是保存在ServletContext中的,使用这个根上下文作为当前MVC上下文的双亲上下文,当前的上下文就是wac  </span><br><span class="line">        // cwac.setParent(rootContext)就是设置当前上下文的根上下文  </span><br><span class="line">        WebApplicationContext rootContext =  </span><br><span class="line">                WebApplicationContextUtils.getWebApplicationContext(getServletContext());  </span><br><span class="line">        WebApplicationContext wac = null;  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">        if (wac == null) &#123;  </span><br><span class="line">            // No context instance is defined for this servlet -&gt; create a local one  </span><br><span class="line">            wac = createWebApplicationContext(rootContext);  </span><br><span class="line">        &#125;  </span><br><span class="line">  </span><br><span class="line">        if (!this.refreshEventReceived) &#123;  </span><br><span class="line">            // Either the context is not a ConfigurableApplicationContext with refresh  </span><br><span class="line">            // support or the context injected at construction time had already been  </span><br><span class="line">            // refreshed -&gt; trigger initial onRefresh manually here.  </span><br><span class="line">            onRefresh(wac);  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>可以看到createWebApplicationContext方法就是在创建并初始化IOC容器，代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">protected WebApplicationContext createWebApplicationContext(ApplicationContext parent) &#123;  </span><br><span class="line">          </span><br><span class="line">        //设置IOC容器的各个参数  </span><br><span class="line">        wac.setEnvironment(getEnvironment());  </span><br><span class="line">        wac.setParent(parent);  </span><br><span class="line">        wac.setConfigLocation(getContextConfigLocation());  </span><br><span class="line">  </span><br><span class="line">        configureAndRefreshWebApplicationContext(wac);  </span><br><span class="line">  </span><br><span class="line">        return wac;  </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>这里设置了当前IOC容器上下文的双亲上下文，双亲上下文是如下方法获取到的：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">WebApplicationContext rootContext =  </span><br><span class="line">                WebApplicationContextUtils.getWebApplicationContext(getServletContext());</span><br></pre></td></tr></table></figure></p>
<p>这样当从IOC容器中getBean的时候会先从其双亲上下文中获取bean,configureAndRefreshWebApplicationContext方法里面调用了wac.refresh()，也就是refresh方法来真正启动对IOC容器的初始化，这里就跟IOC容器的初始化保持一致了</p>
<p>到这里，对DispatcherServlet所持有的IOC容器的初始化就完成了，初始化完成后，DispatcherServlet就持有一个以自己的Servlet名称命名的IOC容器了，这个IOC容器是一个WebApplicationContext对象。<br>我们还可以看到initWebApplicationContext方法中还调用了onrefresh方法，该方法是由DispatcherServlet来实现的，并最终调用了DispatcherServlet的如下方法来进行初始化：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">protected void initStrategies(ApplicationContext context) &#123;  </span><br><span class="line">        initMultipartResolver(context);  </span><br><span class="line">        initLocaleResolver(context);  </span><br><span class="line">        initThemeResolver(context);  </span><br><span class="line">        initHandlerMappings(context);  </span><br><span class="line">        initHandlerAdapters(context);  </span><br><span class="line">        initHandlerExceptionResolvers(context);  </span><br><span class="line">        initRequestToViewNameTranslator(context);  </span><br><span class="line">        initViewResolvers(context);  </span><br><span class="line">        initFlashMapManager(context);  </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>在这个方法里，DispatcherServlet对MVC模块的其他部分进行了初始化，比如handlerMapping，ViewResolver等，它是启动整个Spring MVC框架的初始化<br>比如，支持国际化的LocalResolver，支持request映射的HandlerMapping，以及视图生成的ViewResolver等的初始化<br>这里的initHandlerMapping是为HTTP请求找到相应的Controller控制器。<br>DispatcherServlet的整个初始化过程就到这里结束了，下面说下DispatcherServlet是如何处理http请求的</p>
<p>首先http请求是由doService来处理的，那么我们可以看下HttpServlet类的该方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">protected void service(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123;  </span><br><span class="line">        String method = req.getMethod();  </span><br><span class="line">        long errMsg;  </span><br><span class="line">        if(method.equals(&quot;GET&quot;)) &#123;  </span><br><span class="line">            errMsg = this.getLastModified(req);  </span><br><span class="line">            if(errMsg == -1L) &#123;  </span><br><span class="line">                this.doGet(req, resp);  </span><br><span class="line">            &#125; else &#123;  </span><br><span class="line">                long ifModifiedSince = req.getDateHeader(&quot;If-Modified-Since&quot;);  </span><br><span class="line">                if(ifModifiedSince &lt; errMsg) &#123;  </span><br><span class="line">                    this.maybeSetLastModified(resp, errMsg);  </span><br><span class="line">                    this.doGet(req, resp);  </span><br><span class="line">                &#125; else &#123;  </span><br><span class="line">                    resp.setStatus(304);  </span><br><span class="line">                &#125;  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125; else if(method.equals(&quot;HEAD&quot;)) &#123;  </span><br><span class="line">            errMsg = this.getLastModified(req);  </span><br><span class="line">            this.maybeSetLastModified(resp, errMsg);  </span><br><span class="line">            this.doHead(req, resp);  </span><br><span class="line">        &#125; else if(method.equals(&quot;POST&quot;)) &#123;  </span><br><span class="line">            this.doPost(req, resp);  </span><br><span class="line">        &#125; else if(method.equals(&quot;PUT&quot;)) &#123;  </span><br><span class="line">            this.doPut(req, resp);  </span><br><span class="line">        &#125; else if(method.equals(&quot;DELETE&quot;)) &#123;  </span><br><span class="line">            this.doDelete(req, resp);  </span><br><span class="line">        &#125; else if(method.equals(&quot;OPTIONS&quot;)) &#123;  </span><br><span class="line">            this.doOptions(req, resp);  </span><br><span class="line">        &#125; else if(method.equals(&quot;TRACE&quot;)) &#123;  </span><br><span class="line">            this.doTrace(req, resp);  </span><br><span class="line">        &#125; else &#123;  </span><br><span class="line">            String errMsg1 = lStrings.getString(&quot;http.method_not_implemented&quot;);  </span><br><span class="line">            Object[] errArgs = new Object[]&#123;method&#125;;  </span><br><span class="line">            errMsg1 = MessageFormat.format(errMsg1, errArgs);  </span><br><span class="line">            resp.sendError(501, errMsg1);  </span><br><span class="line">        &#125;  </span><br><span class="line">  </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>这个方法里面会根据不同的请求类型，来调用不同的处理方法，比如会调用doGet或者doPost方法来分别处理get请求和post请求，跟踪这些方法，可以发现，最终是调用了DispatcherServlet的doService方法，代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">protected void doService(HttpServletRequest request, HttpServletResponse response) throws Exception &#123;  </span><br><span class="line">        try &#123;  </span><br><span class="line">            this.doDispatch(request, response);  </span><br><span class="line">        &#125; finally &#123;  </span><br><span class="line">            if(!WebAsyncUtils.getAsyncManager(request).isConcurrentHandlingStarted() &amp;&amp; attributesSnapshot1 != null) &#123;  </span><br><span class="line">                this.restoreAttributesAfterInclude(request, attributesSnapshot1);  </span><br><span class="line">            &#125;  </span><br><span class="line">  </span><br><span class="line">        &#125;  </span><br><span class="line">  </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>可以看到该方法调用了doDispatch来进行处理，doDispatch是MVC模式的主要部分</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://denglinjie.com/2017/09/08/2017-09-08-Spring源码分析之doDispatch分发请求逻辑/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="jasonjie">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="jasonjie">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/09/08/2017-09-08-Spring源码分析之doDispatch分发请求逻辑/" itemprop="url">Spring源码分析之doDispatch分发请求逻辑</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-09-08T00:00:00+08:00">
                2017-09-08
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>首先，我的另外一篇博客已经讲述了DispatcherServlet的整个初始化过程，地址如下：<br><a href="http://blog.csdn.net/u011734144/article/details/74136168" target="_blank" rel="noopener">http://blog.csdn.net/u011734144/article/details/74136168</a></p>
<p>下面说说DispatcherServlet是如何分发请求的<br>分发请求是由该类的doDispatch方法来完成的，先看下具体代码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line">protected void doDispatch(HttpServletRequest request, HttpServletResponse response) throws Exception &#123;</span><br><span class="line">		HttpServletRequest processedRequest = request;</span><br><span class="line">		HandlerExecutionChain mappedHandler = null;</span><br><span class="line">		boolean multipartRequestParsed = false;</span><br><span class="line"></span><br><span class="line">		WebAsyncManager asyncManager = WebAsyncUtils.getAsyncManager(request);</span><br><span class="line"></span><br><span class="line">		try &#123;</span><br><span class="line">			// 这里为视图准备好一个ModelAndView,这个ModelAndView持有handler处理请求的结果</span><br><span class="line">			ModelAndView mv = null;</span><br><span class="line">			Exception dispatchException = null;</span><br><span class="line"></span><br><span class="line">			try &#123;</span><br><span class="line">				processedRequest = checkMultipart(request);</span><br><span class="line">				multipartRequestParsed = (processedRequest != request);</span><br><span class="line"></span><br><span class="line">				// Determine handler for the current request.</span><br><span class="line">				// 根据请求得到对应的Handler</span><br><span class="line">				mappedHandler = getHandler(processedRequest);</span><br><span class="line">				if (mappedHandler == null || mappedHandler.getHandler() == null) &#123;</span><br><span class="line">					noHandlerFound(processedRequest, response);</span><br><span class="line">					return;</span><br><span class="line">				&#125;</span><br><span class="line"></span><br><span class="line">				// Determine handler adapter for the current request.</span><br><span class="line">				// 这里是实际调用handler的地方,在执行handler之前,用handlerAdapter先先检查一下handler的合法性: 即是不是按spring的要求编写的handler</span><br><span class="line">				// handler处理的结果封装到ModelAndView中,为视图提供展现数据</span><br><span class="line">				HandlerAdapter ha = getHandlerAdapter(mappedHandler.getHandler());</span><br><span class="line"></span><br><span class="line">				// Process last-modified header, if supported by the handler.</span><br><span class="line">				String method = request.getMethod();</span><br><span class="line">				boolean isGet = &quot;GET&quot;.equals(method);</span><br><span class="line">				if (isGet || &quot;HEAD&quot;.equals(method)) &#123;</span><br><span class="line">					long lastModified = ha.getLastModified(request, mappedHandler.getHandler());</span><br><span class="line">					if (logger.isDebugEnabled()) &#123;</span><br><span class="line">						logger.debug(&quot;Last-Modified value for [&quot; + getRequestUri(request) + &quot;] is: &quot; + lastModified);</span><br><span class="line">					&#125;</span><br><span class="line">					if (new ServletWebRequest(request, response).checkNotModified(lastModified) &amp;&amp; isGet) &#123;</span><br><span class="line">						return;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line"></span><br><span class="line">				if (!mappedHandler.applyPreHandle(processedRequest, response)) &#123;</span><br><span class="line">					return;</span><br><span class="line">				&#125;</span><br><span class="line"></span><br><span class="line">				// Actually invoke the handler.</span><br><span class="line">				// 通过调用handlerAdapter的handle方法,实际上触发对Controller的handleRequest方法的调用</span><br><span class="line">				mv = ha.handle(processedRequest, response, mappedHandler.getHandler());</span><br><span class="line"></span><br><span class="line">				if (asyncManager.isConcurrentHandlingStarted()) &#123;</span><br><span class="line">					return;</span><br><span class="line">				&#125;</span><br><span class="line"></span><br><span class="line">				applyDefaultViewName(processedRequest, mv);</span><br><span class="line">				mappedHandler.applyPostHandle(processedRequest, response, mv);</span><br><span class="line">			&#125;</span><br><span class="line">			</span><br><span class="line">			processDispatchResult(processedRequest, response, mappedHandler, mv, dispatchException);</span><br><span class="line">		&#125;</span><br><span class="line">	</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure></p>
<p>首先可以看到，这里为视图准备好一个ModelAndView,这个ModelAndView持有handler处理请求的结果<br>然后如下代码：<br>mappedHandler = getHandler(processedRequest)<br>可以根据请求得到对应的handler，如果获取不到对应的handler，就会调用noHandlerFound方法来进行处理，表示找不到对应的处理器，从而抛出异常<br>在执行handler之前,用handlerAdapter先先检查一下handler的合法性: 即是不是按spring的要求编写的handler，即需要判断这个handler是不是Controller接口的实现<br>这个判断是通过HandlerAdapter来判断的，以SimpleControllerHandlerAdapter的实现为例来了解这个判断是如何起作用的，这个判断是通过support方法来实现，<br>判断当前的handler是不是Controller对象，具体代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">public class SimpleControllerHandlerAdapter implements HandlerAdapter &#123;</span><br><span class="line"></span><br><span class="line">	// 判断将要调用handler是不是controller</span><br><span class="line">	@Override</span><br><span class="line">	public boolean supports(Object handler) &#123;</span><br><span class="line">		return (handler instanceof Controller);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	@Override</span><br><span class="line">	public ModelAndView handle(HttpServletRequest request, HttpServletResponse response, Object handler)</span><br><span class="line">			throws Exception &#123;</span><br><span class="line">		//对http请求响应的处理.生成各种需要的数据,并把这些数据封装到ModelAndView中去</span><br><span class="line">		return ((Controller) handler).handleRequest(request, response);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	@Override</span><br><span class="line">	public long getLastModified(HttpServletRequest request, Object handler) &#123;</span><br><span class="line">		if (handler instanceof LastModified) &#123;</span><br><span class="line">			return ((LastModified) handler).getLastModified(request);</span><br><span class="line">		&#125;</span><br><span class="line">		return -1L;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接下来mappedHandler.applyPreHandle方法，代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">boolean applyPreHandle(HttpServletRequest request, HttpServletResponse response) throws Exception &#123;</span><br><span class="line">		HandlerInterceptor[] interceptors = getInterceptors();</span><br><span class="line">		if (!ObjectUtils.isEmpty(interceptors)) &#123;</span><br><span class="line">			for (int i = 0; i &lt; interceptors.length; i++) &#123;</span><br><span class="line">				HandlerInterceptor interceptor = interceptors[i];</span><br><span class="line">				if (!interceptor.preHandle(request, response, this.handler)) &#123;</span><br><span class="line">					triggerAfterCompletion(request, response, null);</span><br><span class="line">					return false;</span><br><span class="line">				&#125;</span><br><span class="line">				this.interceptorIndex = i;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		return true;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure></p>
<p>这是调用为handler配置的拦截器，从HanlderExecutionChain中取出所有的拦截器Interceptor进行前置处理<br>mv = ha.handle(processedRequest, response, mappedHandler.getHandler()); 是真正调用handler进行处理的地方，实际是触发对Controller的<br>handleRequest方法的调用来进行http请求的处理<br>mappedHandler.applyPostHandle方法与前置处理方法applyPreHandle类似，是handle的拦截器的后置处理，具体代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">void applyPostHandle(HttpServletRequest request, HttpServletResponse response, ModelAndView mv) throws Exception &#123;</span><br><span class="line">		HandlerInterceptor[] interceptors = getInterceptors();</span><br><span class="line">		if (!ObjectUtils.isEmpty(interceptors)) &#123;</span><br><span class="line">			for (int i = interceptors.length - 1; i &gt;= 0; i--) &#123;</span><br><span class="line">				HandlerInterceptor interceptor = interceptors[i];</span><br><span class="line">				interceptor.postHandle(request, response, this.handler, mv);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure></p>
<p>最后的processDispatchResult方法就是使用视图对ModelAndView数据的展现<br>到这里，主流程我们就分析完了。<br>接下来我们看下具体的获取handler的过程，也就是getHandler方法的代码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">protected HandlerExecutionChain getHandler(HttpServletRequest request) throws Exception &#123;</span><br><span class="line">		// 这里是从HandlerMapping中去取handler的调用</span><br><span class="line">		for (HandlerMapping hm : this.handlerMappings) &#123;</span><br><span class="line">			if (logger.isTraceEnabled()) &#123;</span><br><span class="line">				logger.trace(</span><br><span class="line">						&quot;Testing handler map [&quot; + hm + &quot;] in DispatcherServlet with name &apos;&quot; + getServletName() + &quot;&apos;&quot;);</span><br><span class="line">			&#125;</span><br><span class="line">			HandlerExecutionChain handler = hm.getHandler(request);</span><br><span class="line">			if (handler != null) &#123;</span><br><span class="line">				return handler;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		return null;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure></p>
<p>可以看到它其实就是从handlerMappings中获取对应的处理器，也就是遍历当前所持有的所有的HanlderMapping，因为在DispatcherServlet中可能定义了不止一个<br>handlerMapping，在这一系列handlerMapping中只要找到了一个需要的handler，就会停止查找，在找到了handler以后，通过hanler返回的是一个HandlerExecutionChain<br>对象，其中包含了最终的Controller和定义的一个拦截器链，拦截器链是为了对handler其实也就是目标Controller进行增强。这样就会按照上面的步骤，先来调用拦截器链的前置处理方法，然后调用Controller来进行请求处理，然后调用<br>拦截器链的后置处理方法。<br>那么接下来我们想知道的就是handlerMappings中的拦截器链和Controller是何时注册进去的<br>下面我们以HandlerMapping的其中一个实现SimpleUrlHandlerMapping来进行讲解，根据名字，可以看出他是根据Url来进行映射，并注册Handler和Interceptor，从而<br>维护一个反映这种url到handler和Interceptor的映射关系的handlerMap，当需要匹配Http请求的时候就需要查询这个handlerMap中的信息来得到对应的<br>HandlerExecutionChain，而这个对象里面就封装了url对应的handler和Interceptor，这个过程就是在SimpleUrlHandlerMapping的如下方法中完成的：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public void initApplicationContext() throws BeansException &#123;</span><br><span class="line">   super.initApplicationContext();</span><br><span class="line">   registerHandlers(this.urlMap);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">public abstract class ApplicationObjectSupport implements ApplicationContextAware &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	@Override</span><br><span class="line">	public final void setApplicationContext(ApplicationContext context) throws BeansException &#123;</span><br><span class="line">		if (context == null &amp;&amp; !isContextRequired()) &#123;</span><br><span class="line">			// Reset internal context state.</span><br><span class="line">			this.applicationContext = null;</span><br><span class="line">			this.messageSourceAccessor = null;</span><br><span class="line">		&#125;</span><br><span class="line">		else if (this.applicationContext == null) &#123;</span><br><span class="line">			// Initialize with passed-in context.</span><br><span class="line">			if (!requiredContextClass().isInstance(context)) &#123;</span><br><span class="line">				throw new ApplicationContextException(</span><br><span class="line">						&quot;Invalid application context: needs to be of type [&quot; + requiredContextClass().getName() + &quot;]&quot;);</span><br><span class="line">			&#125;</span><br><span class="line">			this.applicationContext = context;</span><br><span class="line">			this.messageSourceAccessor = new MessageSourceAccessor(context);</span><br><span class="line">			initApplicationContext(context);</span><br><span class="line">		&#125;</span><br><span class="line">		else &#123;</span><br><span class="line">			// Ignore reinitialization if same context passed in.</span><br><span class="line">			if (this.applicationContext != context) &#123;</span><br><span class="line">				throw new ApplicationContextException(</span><br><span class="line">						&quot;Cannot reinitialize with different application context: current one is [&quot; +</span><br><span class="line">						this.applicationContext + &quot;], passed-in one is [&quot; + context + &quot;]&quot;);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到这个类实现了ApplicationContextAware接口，我们知道在类进行初始化的时候，系统会自动帮我们调用ApplicationContextAware类的<br>setApplicationContext方法，来让bean获取对IOC容器的感知，这个调用在我的其他文章中也有具体的介绍，这里不做过多的说明。我们可以看到这个方法里面就是调用<br>initApplicationContext的地方，即这里来完成启动对映射关系的注册</p>
<p>接着说上面的初始化方法，其中的registerHandlers方法其实是调用的基类AbstractUrlHandlerMapping的registerHandlers方法来进行的注册，具体代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">protected void registerHandler(String urlPath, Object handler) throws BeansException, IllegalStateException &#123;</span><br><span class="line">		Assert.notNull(urlPath, &quot;URL path must not be null&quot;);</span><br><span class="line">		Assert.notNull(handler, &quot;Handler object must not be null&quot;);</span><br><span class="line">		Object resolvedHandler = handler;</span><br><span class="line"></span><br><span class="line">		// Eagerly resolve handler if referencing singleton via name.</span><br><span class="line">		// 如果直接使用bean名称进行映射,那就直接从容器中获取handler</span><br><span class="line">		if (!this.lazyInitHandlers &amp;&amp; handler instanceof String) &#123;</span><br><span class="line">			String handlerName = (String) handler;</span><br><span class="line">			if (getApplicationContext().isSingleton(handlerName)) &#123;</span><br><span class="line">				resolvedHandler = getApplicationContext().getBean(handlerName);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		Object mappedHandler = this.handlerMap.get(urlPath);</span><br><span class="line">		if (mappedHandler != null) &#123;</span><br><span class="line">			if (mappedHandler != resolvedHandler) &#123;</span><br><span class="line">				throw new IllegalStateException(</span><br><span class="line">						&quot;Cannot map &quot; + getHandlerDescription(handler) + &quot; to URL path [&quot; + urlPath +</span><br><span class="line">						&quot;]: There is already &quot; + getHandlerDescription(mappedHandler) + &quot; mapped.&quot;);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		else &#123;</span><br><span class="line">			// 处理URL是&quot;/&quot;的映射,把这个&quot;/&quot;映射的controller设置到rootHandler中</span><br><span class="line">			if (urlPath.equals(&quot;/&quot;)) &#123;</span><br><span class="line">				if (logger.isInfoEnabled()) &#123;</span><br><span class="line">					logger.info(&quot;Root mapping to &quot; + getHandlerDescription(handler));</span><br><span class="line">				&#125;</span><br><span class="line">				setRootHandler(resolvedHandler);</span><br><span class="line">			&#125;</span><br><span class="line">			// 处理URL是&quot;/*&quot;的映射,把这个&quot;/&quot;映射的controller设置到defaultHandler中</span><br><span class="line">			else if (urlPath.equals(&quot;/*&quot;)) &#123;</span><br><span class="line">				if (logger.isInfoEnabled()) &#123;</span><br><span class="line">					logger.info(&quot;Default mapping to &quot; + getHandlerDescription(handler));</span><br><span class="line">				&#125;</span><br><span class="line">				setDefaultHandler(resolvedHandler);</span><br><span class="line">			&#125;</span><br><span class="line">			// 处理正常的URL映射,设置handlerMap的key和value,分别对应于URL和映射的controller</span><br><span class="line">			else &#123;</span><br><span class="line">				this.handlerMap.put(urlPath, resolvedHandler);</span><br><span class="line">				if (logger.isInfoEnabled()) &#123;</span><br><span class="line">					logger.info(&quot;Mapped URL path [&quot; + urlPath + &quot;] onto &quot; + getHandlerDescription(handler));</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure></p>
<p>在这个处理过程中，如果使用Bean的名称作为映射，那么直接从容器中获取这个Http映射对应的Bean，然后还要对不同的URL配置进行解析处理，比如在Http请求中配置<br>成“/”和通配符“/*”的URL，以及正常的URL请求，完成这个解析处理过程以后，会把URL和handler作为键值对放到上面说到的handlerMap中去，handlerMap其实就是<br>一个hashMap，其中保存了URL请求到Controller的映射关系，这个handlerMap是在AbstractUrlHandlerMapping中定义的</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://denglinjie.com/2017/09/08/2017-09-08-Spring源码分析之ProxyFactoryBean方式实现Aop功能的分析/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="jasonjie">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="jasonjie">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/09/08/2017-09-08-Spring源码分析之ProxyFactoryBean方式实现Aop功能的分析/" itemprop="url">Spring源码分析之ProxyFactoryBean方式实现Aop功能的分析</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-09-08T00:00:00+08:00">
                2017-09-08
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>实现Aop功能有两种方式，</p>
<ol>
<li>ProxyFactoryBean方式： 这种方式是通过配置实现</li>
<li>ProxyFactory方式：这种方式是通过编程实现<br>这里只说ProxyFactoryBean方式<br>首先说下具体的配置，一个例子如下：</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id=&quot;testAdvisor&quot; class=&quot;com.abc.TestAdvisor&quot;</span><br><span class="line">	&lt;property name=&quot;pointcut&quot;  ref=&quot;bookPointcut&quot;/&gt; </span><br><span class="line">        &lt;property name=&quot;advice&quot; ref=&quot;aroundMethod&quot;&gt;&lt;/property&gt;</span><br><span class="line">&lt;/bean&gt;</span><br><span class="line">&lt;bean id=&quot;testAop&quot; class=&quot;org.springframeword.aop.ProxyFactoryBean&quot;&gt;</span><br><span class="line">      &lt;property name=&quot;proxyInterfaces&quot;&gt;</span><br><span class="line">              &lt;value&gt;com.test.AbcInterface&lt;/value&gt;</span><br><span class="line">      &lt;/property&gt;</span><br><span class="line">      &lt;property name=&quot;target&quot;&gt;</span><br><span class="line">              &lt;bean class=&quot;com.abc.TestTarget&quot;/&gt;</span><br><span class="line">      &lt;/property&gt;</span><br><span class="line">      &lt;property name=&quot;interceptorNames&quot;&gt;</span><br><span class="line">              &lt;list&gt;</span><br><span class="line">                        &lt;value&gt;testAdvisor&lt;/value&gt;  </span><br><span class="line">              &lt;/list&gt;</span><br><span class="line">      &lt;/property&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure>
<p>上述配置中，testAdvisor是配置了一个通知器，该通知器配置了pointcut，即执行该通知需要满足的条件，还配置了匹配条件时要执行的方法，target配置的是要被增强的目标对象，interceptorNames配置的是一些通知，用来增强目标对象。proxyInterfaces配置的是需要代理的接口名的字符串数组。如果没有提供，将为目标类使用一个CGLIB代理，即这个接口的配置将会影响是用JDK还是CGLIB来创建目标对象的代理对象。<br>首先看下ProxyFactoryBean的getObject方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">	public Object getObject() throws BeansException &#123;</span><br><span class="line">		initializeAdvisorChain();</span><br><span class="line">		//生成代理对象时,因为Spring中有singleton类型和prototype类型这两种不同的Bean,所以要对代理对象的生成做一个区分</span><br><span class="line">		if (isSingleton()) &#123;</span><br><span class="line">			//生成singleton的代理对象,这个方法是ProxyFactoryBean生成AOPProxy代理对象的调用入口</span><br><span class="line">			//代理对象会封装对target目标对象的调用,也就是说针对target对象的方法调用行为会被这里生成的代理对象所拦截</span><br><span class="line">			return getSingletonInstance();</span><br><span class="line">		&#125;</span><br><span class="line">		else &#123;</span><br><span class="line">			if (this.targetName == null) &#123;</span><br><span class="line">				logger.warn(&quot;Using non-singleton proxies with singleton targets is often undesirable. &quot; +</span><br><span class="line">						&quot;Enable prototype proxies by setting the &apos;targetName&apos; property.&quot;);</span><br><span class="line">			&#125;</span><br><span class="line">			return newPrototypeInstance();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure></p>
<p>这个方法其实就是用来为目标对象生成代理对象的<br>initializeAdvisorChain是初始化通知器链，即从上述配置中读取interceptorNames参数的值就可以拿到所有为目标对象配置的通知器，该方法的代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">	 * Create the advisor (interceptor) chain. Advisors that are sourced</span><br><span class="line">	 * from a BeanFactory will be refreshed each time a new prototype instance</span><br><span class="line">	 * is added. Interceptors added programmatically through the factory API</span><br><span class="line">	 * are unaffected by such changes.</span><br><span class="line">	 * 初始化通知器链,通知器链封装了一系列的拦截器,这些拦截器都需要从配置中读取,然后为代理对象的生成做好准备</span><br><span class="line">	 */</span><br><span class="line">	private synchronized void initializeAdvisorChain() throws AopConfigException, BeansException &#123;</span><br><span class="line">		//这个标志位是用来表示通知器链是否已经初始化,初始化的工作发生在应用第一次通过ProxyFactoryBean去获取代理对象的时候</span><br><span class="line">		if (this.advisorChainInitialized) &#123;</span><br><span class="line">			return;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		if (!ObjectUtils.isEmpty(this.interceptorNames)) &#123;</span><br><span class="line">			if (this.beanFactory == null) &#123;</span><br><span class="line">				throw new IllegalStateException(&quot;No BeanFactory available anymore (probably due to serialization) &quot; +</span><br><span class="line">						&quot;- cannot resolve interceptor names &quot; + Arrays.asList(this.interceptorNames));</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			// Globals can&apos;t be last unless we specified a targetSource using the property...</span><br><span class="line">			if (this.interceptorNames[this.interceptorNames.length - 1].endsWith(GLOBAL_SUFFIX) &amp;&amp;</span><br><span class="line">					this.targetName == null &amp;&amp; this.targetSource == EMPTY_TARGET_SOURCE) &#123;</span><br><span class="line">				throw new AopConfigException(&quot;Target required after globals&quot;);</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			// Materialize interceptor chain from bean names.</span><br><span class="line">			//这里是添加Advisor链的调用,是通过interceptorNames属性进行配置的</span><br><span class="line">			//this.interceptorNames就是配置中配置的所有通知器</span><br><span class="line">			for (String name : this.interceptorNames) &#123;</span><br><span class="line">				if (logger.isTraceEnabled()) &#123;</span><br><span class="line">					logger.trace(&quot;Configuring advisor or advice &apos;&quot; + name + &quot;&apos;&quot;);</span><br><span class="line">				&#125;</span><br><span class="line"></span><br><span class="line">				if (name.endsWith(GLOBAL_SUFFIX)) &#123;</span><br><span class="line">					if (!(this.beanFactory instanceof ListableBeanFactory)) &#123;</span><br><span class="line">						throw new AopConfigException(</span><br><span class="line">								&quot;Can only use global advisors or interceptors with a ListableBeanFactory&quot;);</span><br><span class="line">					&#125;</span><br><span class="line">					addGlobalAdvisor((ListableBeanFactory) this.beanFactory,</span><br><span class="line">							name.substring(0, name.length() - GLOBAL_SUFFIX.length()));</span><br><span class="line">				&#125;</span><br><span class="line"></span><br><span class="line">				else &#123;</span><br><span class="line">					// If we get here, we need to add a named interceptor.</span><br><span class="line">					// We must check if it&apos;s a singleton or prototype.</span><br><span class="line">					//如果程序在这里被调用,那么需要加入命名的拦截器advice,并且需要检查这个Bean是singleton还是prototype</span><br><span class="line">					Object advice;</span><br><span class="line">					if (this.singleton || this.beanFactory.isSingleton(name)) &#123;</span><br><span class="line">						// Add the real Advisor/Advice to the chain.</span><br><span class="line">						//取得advisor的地方,是通过beanFactory取得的,把intercepNames这个List中的interceptor的名字交给BeanFactory,然后通过getBean去获取</span><br><span class="line">						advice = this.beanFactory.getBean(name);</span><br><span class="line">					&#125;</span><br><span class="line">					else &#123;</span><br><span class="line">						// It&apos;s a prototype Advice or Advisor: replace with a prototype.</span><br><span class="line">						// Avoid unnecessary creation of prototype bean just for advisor chain initialization.</span><br><span class="line">						advice = new PrototypePlaceholderAdvisor(name);</span><br><span class="line">					&#125;</span><br><span class="line">					addAdvisorOnChainCreation(advice, name);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		this.advisorChainInitialized = true;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure></p>
<p>其他的getSingletonInstance方法和newPrototypeInstance类其实就是构造代理对象<br>其中getSingletonInstance方法的代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">private synchronized Object getSingletonInstance() &#123;</span><br><span class="line">		if (this.singletonInstance == null) &#123;</span><br><span class="line">			this.targetSource = freshTargetSource();</span><br><span class="line">			if (this.autodetectInterfaces &amp;&amp; getProxiedInterfaces().length == 0 &amp;&amp; !isProxyTargetClass()) &#123;</span><br><span class="line">				// Rely on AOP infrastructure to tell us what interfaces to proxy.</span><br><span class="line">				//根据AOP框架来判断需要代理的接口</span><br><span class="line">				Class&lt;?&gt; targetClass = getTargetClass();</span><br><span class="line">				if (targetClass == null) &#123;</span><br><span class="line">					throw new FactoryBeanNotInitializedException(&quot;Cannot determine target class for proxy&quot;);</span><br><span class="line">				&#125;</span><br><span class="line">				//设置代理对象的接口</span><br><span class="line">				setInterfaces(ClassUtils.getAllInterfacesForClass(targetClass, this.proxyClassLoader));</span><br><span class="line">			&#125;</span><br><span class="line">			// Initialize the shared singleton instance.</span><br><span class="line">			super.setFrozen(this.freezeProxy);</span><br><span class="line">			//createAopProxy()方法可能会返回ObjenesisCglibAopProxy对象,也可能会返回JdkDynamicAopProxy对象</span><br><span class="line">			//然后getProxy方法会根据ObjenesisCglibAopProxy或者JdkDynamicAopProxy对象的getProxy方法来生成最终的代理对象</span><br><span class="line">			//这就是所谓的,Spring生成代理对象的两种方式,一种是CGLIB,一种是JDK</span><br><span class="line">			this.singletonInstance = getProxy(createAopProxy());	//这里的方法会使用ProxyFactory来生成需要的Proxy,通过createAopProxy返回的AopProxy来得到代理对象</span><br><span class="line">		&#125;</span><br><span class="line">		return this.singletonInstance;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure></p>
<p>注意this.singletonInstance = getProxy(createAopProxy());这行代码<br>createAopProxy()方法可能会返回ObjenesisCglibAopProxy对象,也可能会返回JdkDynamicAopProxy对象，这个逻辑是在DefaultAopProxyFactory<br>类中实现的，逻辑如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">public class DefaultAopProxyFactory implements AopProxyFactory, Serializable &#123;</span><br><span class="line"></span><br><span class="line">	//config里面封装了想要生成的代理对象的信息</span><br><span class="line">	@Override</span><br><span class="line">	public AopProxy createAopProxy(AdvisedSupport config) throws AopConfigException &#123;</span><br><span class="line">		if (config.isOptimize() || config.isProxyTargetClass() || hasNoUserSuppliedProxyInterfaces(config)) &#123;</span><br><span class="line">			Class&lt;?&gt; targetClass = config.getTargetClass();	//首先要从AdvisedSupport对象中取得配置的目标对象,如果目标对象为空,则直接抛出异常,因为连目标对象都没有,还为谁创建代理对象</span><br><span class="line">			if (targetClass == null) &#123;</span><br><span class="line">				throw new AopConfigException(&quot;TargetSource cannot determine target class: &quot; +</span><br><span class="line">						&quot;Either an interface or a target is required for proxy creation.&quot;);</span><br><span class="line">			&#125;</span><br><span class="line">			//关于AopProxy代理对象的生成,需要考虑使用哪种生成方式,如果目标对象是接口类,那么适合使用JDK来生成代理对象,否则spring会使用CGLIB来生成目标对象的代理对象</span><br><span class="line">			//对于具体的AopProxy代理对象的生成,最终并不是由DefaultAopProxyFactory来完成,而是分别由JdkDynamicAopProxy和ObjenesisCglibAopProxy完成</span><br><span class="line">			if (targetClass.isInterface() || Proxy.isProxyClass(targetClass)) &#123;</span><br><span class="line">				return new JdkDynamicAopProxy(config);	//使用JDK来生成AOPProxy代理对象</span><br><span class="line">			&#125;</span><br><span class="line">			return new ObjenesisCglibAopProxy(config);	//使用第三方CGLIB来生成AOPProxy代理对象</span><br><span class="line">		&#125;</span><br><span class="line">		else &#123;</span><br><span class="line">			return new JdkDynamicAopProxy(config);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure></p>
<p>可以看到，它会根据目标类是不是接口等信息来判定使用ObjenesisCglibAopProxy还是JdkDynamicAopProxy</p>
<p>然后getProxy方法会根据ObjenesisCglibAopProxy或者JdkDynamicAopProxy对象的getProxy方法来生成最终的代理对象<br>这就是所谓的,Spring生成代理对象的两种方式,一种是CGLIB,一种是JDK<br>下面说说用JdkDynamicAopProxy方式生成的代理对象的拦截方式，它实际用的就是JDK的动态代理<br>我们知道，动态代理拦截的入口是实现了InvocationHandler接口后的invoke方法，即所有对目标方法的调用首先会被invoke方法拦截<br>而JdkDynamicAopProxy方式实现的动态代理的拦截入口也是该类的invoke方法，该类的部分方法如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * JDK-based &#123;@link AopProxy&#125; implementation for the Spring AOP framework</span><br><span class="line"> *InvocationHandler接口的invoke方法就是拦截回调的入口,即对目标方法的调用会先被invoke方法拦截,并在invoke方法里面来调用目标方法</span><br><span class="line"> */</span><br><span class="line">final class JdkDynamicAopProxy implements AopProxy, InvocationHandler, Serializable &#123;</span><br><span class="line"></span><br><span class="line">	public JdkDynamicAopProxy(AdvisedSupport config) throws AopConfigException &#123;</span><br><span class="line">		Assert.notNull(config, &quot;AdvisedSupport must not be null&quot;);</span><br><span class="line">		if (config.getAdvisors().length == 0 &amp;&amp; config.getTargetSource() == AdvisedSupport.EMPTY_TARGET_SOURCE) &#123;</span><br><span class="line">			throw new AopConfigException(&quot;No advisors and no TargetSource specified&quot;);</span><br><span class="line">		&#125;</span><br><span class="line">		this.advised = config;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	@Override</span><br><span class="line">	public Object getProxy() &#123;</span><br><span class="line">		return getProxy(ClassUtils.getDefaultClassLoader());</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	@Override</span><br><span class="line">	public Object getProxy(ClassLoader classLoader) &#123;</span><br><span class="line">		if (logger.isDebugEnabled()) &#123;</span><br><span class="line">			logger.debug(&quot;Creating JDK dynamic proxy: target source is &quot; + this.advised.getTargetSource());</span><br><span class="line">		&#125;</span><br><span class="line">		//首先从advised对象中取得代理对象的代理接口配置</span><br><span class="line">		Class&lt;?&gt;[] proxiedInterfaces = AopProxyUtils.completeProxiedInterfaces(this.advised, true);</span><br><span class="line">		findDefinedEqualsAndHashCodeMethods(proxiedInterfaces);</span><br><span class="line">		//第三个参数需要实现InvocationHandler接口和invoke方法,这个invoke方法是Proxy代理对象的回调方法</span><br><span class="line">		//这种方式其实就是用JDK的动态代理来为目标对象创建代理对象,对目标对象方法的调用就是由这个代理对象来调用的</span><br><span class="line">		return Proxy.newProxyInstance(classLoader, proxiedInterfaces, this);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	/**</span><br><span class="line">	 * Implementation of &#123;@code InvocationHandler.invoke&#125;.</span><br><span class="line">	 * &lt;p&gt;Callers will see exactly the exception thrown by the target,</span><br><span class="line">	 * unless a hook method throws an exception.</span><br><span class="line">	 * 拦截回调入口</span><br><span class="line">	 */</span><br><span class="line">	@Override</span><br><span class="line">	public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123;</span><br><span class="line">		MethodInvocation invocation;</span><br><span class="line">		Object oldProxy = null;</span><br><span class="line">		boolean setProxyContext = false;</span><br><span class="line"></span><br><span class="line">		TargetSource targetSource = this.advised.targetSource;</span><br><span class="line">		Class&lt;?&gt; targetClass = null;</span><br><span class="line">		Object target = null;</span><br><span class="line"></span><br><span class="line">		try &#123;</span><br><span class="line">			//如果目标对象没有实现Object类的基本方法:equals</span><br><span class="line">			if (!this.equalsDefined &amp;&amp; AopUtils.isEqualsMethod(method)) &#123;</span><br><span class="line">				// The target does not implement the equals(Object) method itself.</span><br><span class="line">				return equals(args[0]);</span><br><span class="line">			&#125;</span><br><span class="line">			//如果目标对象没有实现Object类的基本方法:hashcode</span><br><span class="line">			else if (!this.hashCodeDefined &amp;&amp; AopUtils.isHashCodeMethod(method)) &#123;</span><br><span class="line">				// The target does not implement the hashCode() method itself.</span><br><span class="line">				return hashCode();</span><br><span class="line">			&#125;</span><br><span class="line">			else if (method.getDeclaringClass() == DecoratingProxy.class) &#123;</span><br><span class="line">				// There is only getDecoratedClass() declared -&gt; dispatch to proxy config.</span><br><span class="line">				return AopProxyUtils.ultimateTargetClass(this.advised);</span><br><span class="line">			&#125;</span><br><span class="line">			else if (!this.advised.opaque &amp;&amp; method.getDeclaringClass().isInterface() &amp;&amp;</span><br><span class="line">					method.getDeclaringClass().isAssignableFrom(Advised.class)) &#123;</span><br><span class="line">				// Service invocations on ProxyConfig with the proxy config...</span><br><span class="line">				//根据代理对象的配置来调用服务</span><br><span class="line">				return AopUtils.invokeJoinpointUsingReflection(this.advised, method, args);</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			Object retVal;</span><br><span class="line"></span><br><span class="line">			if (this.advised.exposeProxy) &#123;</span><br><span class="line">				// Make invocation available if necessary.</span><br><span class="line">				oldProxy = AopContext.setCurrentProxy(proxy);</span><br><span class="line">				setProxyContext = true;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			// May be null. Get as late as possible to minimize the time we &quot;own&quot; the target,</span><br><span class="line">			// in case it comes from a pool.</span><br><span class="line">			//得到目标对象</span><br><span class="line">			target = targetSource.getTarget();</span><br><span class="line">			if (target != null) &#123;</span><br><span class="line">				targetClass = target.getClass();</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			// Get the interception chain for this method.	获取方法method的拦截器链</span><br><span class="line">			// 拦截器链实际就是由一系列的Advice通知对象组成的</span><br><span class="line">			List&lt;Object&gt; chain = this.advised.getInterceptorsAndDynamicInterceptionAdvice(method, targetClass);</span><br><span class="line"></span><br><span class="line">			// Check whether we have any advice. If we don&apos;t, we can fallback on direct</span><br><span class="line">			// reflective invocation of the target, and avoid creating a MethodInvocation.</span><br><span class="line">			//如果没有定义拦截器链,就直接调用target对象的对应方法</span><br><span class="line">			if (chain.isEmpty()) &#123;</span><br><span class="line">				// We can skip creating a MethodInvocation: just invoke the target directly</span><br><span class="line">				// Note that the final invoker must be an InvokerInterceptor so we know it does</span><br><span class="line">				// nothing but a reflective operation on the target, and no hot swapping or fancy proxying.</span><br><span class="line">				Object[] argsToUse = AopProxyUtils.adaptArgumentsIfNecessary(method, args);	//适配参数</span><br><span class="line">				//调用target对象的对应方法</span><br><span class="line">				retVal = AopUtils.invokeJoinpointUsingReflection(target, method, argsToUse);</span><br><span class="line">			&#125;</span><br><span class="line">			else &#123;</span><br><span class="line">				// We need to create a method invocation...</span><br><span class="line">				//如果有拦截器的设定,那么需要调用拦截器之后才调用目标对象的相应方法,通过构造一个ReflectiveMethodInvocation来实现</span><br><span class="line">				invocation = new ReflectiveMethodInvocation(proxy, target, method, args, targetClass, chain);</span><br><span class="line">				// Proceed to the joinpoint through the interceptor chain.</span><br><span class="line">				//沿着拦截器链继续前进</span><br><span class="line">				retVal = invocation.proceed();</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			// Massage return value if necessary.</span><br><span class="line">			Class&lt;?&gt; returnType = method.getReturnType();</span><br><span class="line">			if (retVal != null &amp;&amp; retVal == target &amp;&amp; returnType.isInstance(proxy) &amp;&amp;</span><br><span class="line">					!RawTargetAccess.class.isAssignableFrom(method.getDeclaringClass())) &#123;</span><br><span class="line">				// Special case: it returned &quot;this&quot; and the return type of the method</span><br><span class="line">				// is type-compatible. Note that we can&apos;t help if the target sets</span><br><span class="line">				// a reference to itself in another returned object.</span><br><span class="line">				retVal = proxy;</span><br><span class="line">			&#125;</span><br><span class="line">			else if (retVal == null &amp;&amp; returnType != Void.TYPE &amp;&amp; returnType.isPrimitive()) &#123;</span><br><span class="line">				throw new AopInvocationException(</span><br><span class="line">						&quot;Null return value from advice does not match primitive return type for: &quot; + method);</span><br><span class="line">			&#125;</span><br><span class="line">			return retVal;</span><br><span class="line">		&#125;</span><br><span class="line">		finally &#123;</span><br><span class="line">			if (target != null &amp;&amp; !targetSource.isStatic()) &#123;</span><br><span class="line">				// Must have come from TargetSource.</span><br><span class="line">				targetSource.releaseTarget(target);</span><br><span class="line">			&#125;</span><br><span class="line">			if (setProxyContext) &#123;</span><br><span class="line">				// Restore old proxy.</span><br><span class="line">				AopContext.setCurrentProxy(oldProxy);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>上述getProxy方法其实就是JdkDynamicAopProxy用来给目标对象生成代码对象的方法<br>而invoke就是对目标方法调用时的拦截入口<br>其中的<br>List<object> chain = this.advised.getInterceptorsAndDynamicInterceptionAdvice(method, targetClass);<br>这行代码就是获取到目标对象所有的拦截器，为什么这里是获取拦截器？其实在上面初始化通知器链的时候拿到的都是配置的通知器，这个方法是要将这些通知器用对应的适配器<br>适配成对应的拦截器，至于为什么要做这个步骤，在我的另外一篇博客中说的很清楚了，地址如下：<br><a href="http://blog.csdn.net/u011734144/article/details/73436539" target="_blank" rel="noopener">http://blog.csdn.net/u011734144/article/details/73436539</a><br>这里转换成拦截器后，也并不是直接就要将该拦截器加入最终要执行的拦截器链中，还需要判断对应的通知是否应该执行，对应的代码片段如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">//对配置的advisor通知器进行逐个遍历,这个通知器链都是配置在interceptorNames中的</span><br><span class="line">		for (Advisor advisor : config.getAdvisors()) &#123;</span><br><span class="line">			if (advisor instanceof PointcutAdvisor) &#123;</span><br><span class="line">				// Add it conditionally.</span><br><span class="line">				PointcutAdvisor pointcutAdvisor = (PointcutAdvisor) advisor;</span><br><span class="line">				if (config.isPreFiltered() || pointcutAdvisor.getPointcut().getClassFilter().matches(actualClass)) &#123;</span><br><span class="line">					//registry.getInterceptors(advisor)是对从ProxyFactoryBean配置中得到的通知进行适配,从而得到相应的拦截器,再把它加入到前面设置好的list中去</span><br><span class="line">					//从而完成所谓的拦截器注册过程</span><br><span class="line">					MethodInterceptor[] interceptors = registry.getInterceptors(advisor);</span><br><span class="line">					MethodMatcher mm = pointcutAdvisor.getPointcut().getMethodMatcher();</span><br><span class="line">					if (MethodMatchers.matches(mm, method, actualClass, hasIntroductions)) &#123;</span><br><span class="line">						if (mm.isRuntime()) &#123;</span><br><span class="line">							// Creating a new object instance in the getInterceptors() method</span><br><span class="line">							// isn&apos;t a problem as we normally cache created chains.</span><br><span class="line">							for (MethodInterceptor interceptor : interceptors) &#123;</span><br><span class="line">								interceptorList.add(new InterceptorAndDynamicMethodMatcher(interceptor, mm));</span><br><span class="line">							&#125;</span><br><span class="line">						&#125;</span><br><span class="line">						else &#123;</span><br><span class="line">							interceptorList.addAll(Arrays.asList(interceptors));</span><br><span class="line">						&#125;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			else if (advisor instanceof IntroductionAdvisor) &#123;</span><br><span class="line">				IntroductionAdvisor ia = (IntroductionAdvisor) advisor;</span><br><span class="line">				if (config.isPreFiltered() || ia.getClassFilter().matches(actualClass)) &#123;</span><br><span class="line">					Interceptor[] interceptors = registry.getInterceptors(advisor);</span><br><span class="line">					interceptorList.addAll(Arrays.asList(interceptors));</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			else &#123;</span><br><span class="line">				Interceptor[] interceptors = registry.getInterceptors(advisor);</span><br><span class="line">				interceptorList.addAll(Arrays.asList(interceptors));</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br></pre></td></tr></table></figure></object></p>
<p>这里需要判断通知器中配置的切入点是否匹配当前要被调用的方法，即MethodMatchers.matches是否为true，只有匹配的通知才会将对应的拦截器加入到最终待执行的拦截器链中<br>接下来invoke方法中比较核心的就是如下代码：<br>retVal = invocation.proceed();<br>这个方法其实就是启动拦截器链的执行，依次执行每一个拦截器链，在每一个拦截器里面都会根据通知的类型来决定是先执行通知的方法还是先继续执行下一个拦截器，<br>拦截器中具体的执行逻辑也请参考我上面说的我的另外一篇文章</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://denglinjie.com/2017/09/08/2017-09-08-Spring源码分析之BeanPostProcessor接口和BeanFactoryPostProcessor接口方法不执行原因分析/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="jasonjie">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="jasonjie">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/09/08/2017-09-08-Spring源码分析之BeanPostProcessor接口和BeanFactoryPostProcessor接口方法不执行原因分析/" itemprop="url">Spring源码分析之BeanPostProcessor接口和BeanFactoryPostProcessor接口方法不执行原因分析</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-09-08T00:00:00+08:00">
                2017-09-08
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>首先下面是我的Bean<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line"> * Copyright 2002-2017 the original author or authors.</span><br><span class="line"> *</span><br><span class="line"> * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);</span><br><span class="line"> * you may not use this file except in compliance with the License.</span><br><span class="line"> * You may obtain a copy of the License at</span><br><span class="line"> *</span><br><span class="line"> *      http://www.apache.org/licenses/LICENSE-2.0</span><br><span class="line"> *</span><br><span class="line"> * Unless required by applicable law or agreed to in writing, software</span><br><span class="line"> * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,</span><br><span class="line"> * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.</span><br><span class="line"> * See the License for the specific language governing permissions and</span><br><span class="line"> * limitations under the License.</span><br><span class="line"> */</span><br><span class="line">package com.verify.constant;</span><br><span class="line"></span><br><span class="line">import org.springframework.beans.BeansException;</span><br><span class="line">import org.springframework.beans.PropertyValues;</span><br><span class="line">import org.springframework.beans.factory.*;</span><br><span class="line">import org.springframework.beans.factory.config.BeanFactoryPostProcessor;</span><br><span class="line">import org.springframework.beans.factory.config.BeanPostProcessor;</span><br><span class="line">import org.springframework.beans.factory.config.ConfigurableListableBeanFactory;</span><br><span class="line">import org.springframework.beans.factory.config.InstantiationAwareBeanPostProcessor;</span><br><span class="line"></span><br><span class="line">import java.beans.PropertyDescriptor;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * TODO</span><br><span class="line"> *</span><br><span class="line"> * @author linjiedeng</span><br><span class="line"> * @date 17/5/8 下午10:47</span><br><span class="line"> * @since TODO</span><br><span class="line"> */</span><br><span class="line">public class StudentService implements BeanPostProcessor, InitializingBean, BeanFactoryPostProcessor, BeanNameAware, BeanClassLoaderAware, BeanFactoryAware &#123;</span><br><span class="line"></span><br><span class="line">    private ClassLoader classLoader;</span><br><span class="line"></span><br><span class="line">    private BeanFactory beanFactory;</span><br><span class="line"></span><br><span class="line">    private String name;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void setBeanClassLoader(ClassLoader classLoader) &#123;</span><br><span class="line">        this.classLoader = classLoader; //实现BeanClassLoaderAware接口可以获取到对应的classLoader</span><br><span class="line">        System.out.println(&quot;set bean class loader&quot;);</span><br><span class="line">        System.out.println(classLoader);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void setBeanFactory(BeanFactory beanFactory) throws BeansException &#123;</span><br><span class="line">        this.beanFactory = beanFactory; //实现BeanFactoryAware接口获取该Bean的beanFactory</span><br><span class="line">        System.out.println(&quot;set bean factory&quot;);</span><br><span class="line">        System.out.println(beanFactory);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void setBeanName(String name) &#123;</span><br><span class="line">        this.name = name;   //实现BeanNameAware接口获取该Bean的名字</span><br><span class="line">        System.out.println(&quot;set bean name&quot;);</span><br><span class="line">        System.out.println(name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void initMethod() &#123;</span><br><span class="line">        System.out.println(&quot;init method&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void afterPropertiesSet() throws Exception &#123;</span><br><span class="line">        System.out.println(&quot;afterPropertiesSet&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public Object postProcessBeforeInitialization(Object bean, String beanName) throws BeansException &#123;</span><br><span class="line">        System.out.println(&quot;postProcessBeforeInitialization&quot;);</span><br><span class="line">        return bean;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public Object postProcessAfterInitialization(Object bean, String beanName) throws BeansException &#123;</span><br><span class="line">        System.out.println(&quot;postProcessAfterInitialization&quot;);</span><br><span class="line">        return bean;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void postProcessBeanFactory(ConfigurableListableBeanFactory beanFactory) throws BeansException &#123;</span><br><span class="line">        System.out.println(&quot;postProcessBeanFactory&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void read() &#123;</span><br><span class="line">        System.out.println(&quot;Student service read&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>bean的配置文件applicationContext.xml内容如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;</span><br><span class="line">       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span><br><span class="line">       xmlns:context=&quot;http://www.springframework.org/schema/context&quot;</span><br><span class="line">       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans</span><br><span class="line">        http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd&quot;&gt;</span><br><span class="line"></span><br><span class="line">    &lt;bean id=&quot;studentService&quot; class=&quot;com.verify.constant.StudentService&quot; init-method=&quot;initMethod&quot;/&gt;</span><br><span class="line">&lt;/beans&gt;</span><br></pre></td></tr></table></figure></p>
<p>测试代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">@Test</span><br><span class="line">    public void test2() &#123;</span><br><span class="line">        ClassPathResource resource = new ClassPathResource(&quot;applicationContext.xml&quot;);</span><br><span class="line">        DefaultListableBeanFactory factory = new DefaultListableBeanFactory();</span><br><span class="line">        XmlBeanDefinitionReader reader = new XmlBeanDefinitionReader(factory);</span><br><span class="line">        reader.loadBeanDefinitions(resource);</span><br><span class="line">        StudentService studentService = (StudentService)factory.getBean(&quot;studentService&quot;);</span><br><span class="line">        studentService.read();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>测试代码执行后，其他方法都执行了，但是唯独BeanPostProcessor接口的两个方法postProcessBeforeInitialization和postProcessAfterInitialization以及<br>BeanFactoryPostProcessor接口的方法没有执行，这我就有点疑惑了，这是咋回事？其实这两个接口应该是在bean初始化的过程中被调用，是在AbstractAutowireCapableBeanFactory接口的initializeBean初始化方法中被调用的，代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">protected Object initializeBean(final String beanName, final Object bean, RootBeanDefinition mbd) &#123;</span><br><span class="line">		if (System.getSecurityManager() != null) &#123;</span><br><span class="line">			AccessController.doPrivileged(new PrivilegedAction&lt;Object&gt;() &#123;</span><br><span class="line">				@Override</span><br><span class="line">				public Object run() &#123;</span><br><span class="line">					invokeAwareMethods(beanName, bean);</span><br><span class="line">					return null;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;, getAccessControlContext());</span><br><span class="line">		&#125;</span><br><span class="line">		else &#123;</span><br><span class="line">			invokeAwareMethods(beanName, bean);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		Object wrappedBean = bean;</span><br><span class="line">		if (mbd == null || !mbd.isSynthetic()) &#123;</span><br><span class="line">			//执行BeanPostProcessor扩展点的PostProcessBeforeInitialization进行修改实例化Bean</span><br><span class="line">			wrappedBean = applyBeanPostProcessorsBeforeInitialization(wrappedBean, beanName);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		try &#123;</span><br><span class="line">			//调用Bean的初始化方法,这个初始化方法是在BeanDefinition中通过定义init-method属性指定的</span><br><span class="line">			//同时,如果Bean实现了InitializingBean接口,那么这个Bean的afterPropertiesSet实现也不会被调用</span><br><span class="line">			invokeInitMethods(beanName, wrappedBean, mbd);</span><br><span class="line">		&#125;</span><br><span class="line">		catch (Throwable ex) &#123;</span><br><span class="line">			throw new BeanCreationException(</span><br><span class="line">					(mbd != null ? mbd.getResourceDescription() : null),</span><br><span class="line">					beanName, &quot;Invocation of init method failed&quot;, ex);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		if (mbd == null || !mbd.isSynthetic()) &#123;</span><br><span class="line">			//执行BeanPostProcessor扩展点的PostProcessAfterInitialization进行修改实例化Bean</span><br><span class="line">			wrappedBean = applyBeanPostProcessorsAfterInitialization(wrappedBean, beanName);</span><br><span class="line">		&#125;</span><br><span class="line">		return wrappedBean;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure></p>
<p>initializeBean方法是Bean的初始化方法，在该初始化方法中会调用Bean的一些初始化方法，比如如下方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">private void invokeAwareMethods(final String beanName, final Object bean) &#123;</span><br><span class="line">		if (bean instanceof Aware) &#123;</span><br><span class="line">			if (bean instanceof BeanNameAware) &#123;</span><br><span class="line">				((BeanNameAware) bean).setBeanName(beanName);</span><br><span class="line">			&#125;</span><br><span class="line">			if (bean instanceof BeanClassLoaderAware) &#123;</span><br><span class="line">				((BeanClassLoaderAware) bean).setBeanClassLoader(getBeanClassLoader());</span><br><span class="line">			&#125;</span><br><span class="line">			if (bean instanceof BeanFactoryAware) &#123;</span><br><span class="line">				((BeanFactoryAware) bean).setBeanFactory(AbstractAutowireCapableBeanFactory.this);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure></p>
<p>即只要Bean实现了BeanNameAware接口，这里就会帮你调用，BeanClassLoaderAware和BeanFactory接口同样如此，上述我的代码中就实现了这三个接口，启动的过程中都被调用了，再实现的方法中可以获取这些信息，并存储。<br>再比如如下方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public Object applyBeanPostProcessorsBeforeInitialization(Object existingBean, String beanName)</span><br><span class="line">			throws BeansException &#123;</span><br><span class="line"></span><br><span class="line">		Object result = existingBean;</span><br><span class="line">		for (BeanPostProcessor beanProcessor : getBeanPostProcessors()) &#123;</span><br><span class="line">			result = beanProcessor.postProcessBeforeInitialization(result, beanName);</span><br><span class="line">			if (result == null) &#123;</span><br><span class="line">				return result;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		return result;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure></p>
<p>这里其实是如果Bean实现了BeanPostProcessor接口，这里就会调用bean实现的postProcessBeforeInitialization方法，这是在bean的真正初始化之前被调用<br>对应的BeanPostProcessor接口的另外一个方法，是在bean的初始化之后被调用，如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public Object applyBeanPostProcessorsAfterInitialization(Object existingBean, String beanName)</span><br><span class="line">			throws BeansException &#123;</span><br><span class="line"></span><br><span class="line">		Object result = existingBean;</span><br><span class="line">		for (BeanPostProcessor beanProcessor : getBeanPostProcessors()) &#123;</span><br><span class="line">			result = beanProcessor.postProcessAfterInitialization(result, beanName);</span><br><span class="line">			if (result == null) &#123;</span><br><span class="line">				return result;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		return result;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure></p>
<p>真正的初始化是在如下方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">protected void invokeInitMethods(String beanName, final Object bean, RootBeanDefinition mbd)</span><br><span class="line">			throws Throwable &#123;</span><br><span class="line"></span><br><span class="line">		boolean isInitializingBean = (bean instanceof InitializingBean);</span><br><span class="line">		if (isInitializingBean &amp;&amp; (mbd == null || !mbd.isExternallyManagedInitMethod(&quot;afterPropertiesSet&quot;))) &#123;</span><br><span class="line">			if (logger.isDebugEnabled()) &#123;</span><br><span class="line">				logger.debug(&quot;Invoking afterPropertiesSet() on bean with name &apos;&quot; + beanName + &quot;&apos;&quot;);</span><br><span class="line">			&#125;</span><br><span class="line">			if (System.getSecurityManager() != null) &#123;</span><br><span class="line">				try &#123;</span><br><span class="line">					AccessController.doPrivileged(new PrivilegedExceptionAction&lt;Object&gt;() &#123;</span><br><span class="line">						@Override</span><br><span class="line">						public Object run() throws Exception &#123;</span><br><span class="line">							((InitializingBean) bean).afterPropertiesSet();</span><br><span class="line">							return null;</span><br><span class="line">						&#125;</span><br><span class="line">					&#125;, getAccessControlContext());</span><br><span class="line">				&#125;</span><br><span class="line">				catch (PrivilegedActionException pae) &#123;</span><br><span class="line">					throw pae.getException();</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			else &#123;</span><br><span class="line">				((InitializingBean) bean).afterPropertiesSet();	//启动afterPropertiesSet,afterPropertiesSet是InitializingBean接口的方法</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		if (mbd != null) &#123;</span><br><span class="line">			String initMethodName = mbd.getInitMethodName();	//获取用户自定义的初始化方法</span><br><span class="line">			if (initMethodName != null &amp;&amp; !(isInitializingBean &amp;&amp; &quot;afterPropertiesSet&quot;.equals(initMethodName)) &amp;&amp;</span><br><span class="line">					!mbd.isExternallyManagedInitMethod(initMethodName)) &#123;</span><br><span class="line">				invokeCustomInitMethod(beanName, bean, mbd);	//调用自定义的初始化方法</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure></p>
<p>可以看到，上述代码实际上是在调用Bean实现的initializingBean接口的afterPropertiesSet方法来初始化Bean，接下来还调用了用户自定义的init-method方法，可以看到上面我的applicationContext.xml配置文件中配置的有一个initMethod方法，这就是自定义的初始化方法，这个方法也是在这里被调用的</p>
<p>好，代码分析到这，也可以看到了，既然这里初始化的时候调用了BeanPostProcessor的那两个方法，但是我的测试代码为什么没有执行这两个方法呢？<br>其实可以看到真正执行BeanPostProcessor接口的代码是如下代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public Object applyBeanPostProcessorsBeforeInitialization(Object existingBean, String beanName)</span><br><span class="line">			throws BeansException &#123;</span><br><span class="line"></span><br><span class="line">		Object result = existingBean;</span><br><span class="line">		for (BeanPostProcessor beanProcessor : getBeanPostProcessors()) &#123;</span><br><span class="line">			result = beanProcessor.postProcessBeforeInitialization(result, beanName);</span><br><span class="line">			if (result == null) &#123;</span><br><span class="line">				return result;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		return result;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure></p>
<p>其中的getBeanPostProcessors()方法获取的实际就是AbstractBeanFactory的this.beanPostProcessors属性值，看来是这个属性值为空，所以执行的时候没有调用<br>那接下来要分析的原因就是为什么this.beanPostProcessors属性值为空呢？或者说bean的载入时为什么没有载入进来呢？那就要看它是在哪里载入的了，最终定位到载入是在<br>AbstractApplicationContext中执行的<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">	public void refresh() throws BeansException, IllegalStateException &#123;</span><br><span class="line">		synchronized (this.startupShutdownMonitor) &#123;</span><br><span class="line">			// Prepare this context for refreshing.</span><br><span class="line">			prepareRefresh();</span><br><span class="line"></span><br><span class="line">			//这是在子类中启动refreshBeanFactory的地方</span><br><span class="line">			// Tell the subclass to refresh the internal bean factory.</span><br><span class="line">			ConfigurableListableBeanFactory beanFactory = obtainFreshBeanFactory();</span><br><span class="line"></span><br><span class="line">			// Prepare the bean factory for use in this context.</span><br><span class="line">			prepareBeanFactory(beanFactory);</span><br><span class="line"></span><br><span class="line">			try &#123;</span><br><span class="line">				// Allows post-processing of the bean factory in context subclasses.</span><br><span class="line">				// 设置BeanFactory的后置处理</span><br><span class="line">				postProcessBeanFactory(beanFactory);</span><br><span class="line"></span><br><span class="line">				// Invoke factory processors registered as beans in the context.</span><br><span class="line">				// 调用BeanFactory的后处理器,这些后处理器是在Bean定义中向容器注册的</span><br><span class="line">				invokeBeanFactoryPostProcessors(beanFactory);</span><br><span class="line"></span><br><span class="line">				// Register bean processors that intercept bean creation.</span><br><span class="line">				// 注册Bean的后处理器,在Bean创建过程中调用</span><br><span class="line">				registerBeanPostProcessors(beanFactory);</span><br><span class="line"></span><br><span class="line">				// Initialize message source for this context.</span><br><span class="line">				// 对上下文中的消息源进行初始化</span><br><span class="line">				initMessageSource();</span><br><span class="line"></span><br><span class="line">				// Initialize event multicaster for this context.</span><br><span class="line">				// 初始化上下文中的事件机制</span><br><span class="line">				initApplicationEventMulticaster();</span><br><span class="line"></span><br><span class="line">				// Initialize other special beans in specific context subclasses.</span><br><span class="line">				// 初始化其他的特殊Bean</span><br><span class="line">				onRefresh();</span><br><span class="line"></span><br><span class="line">				// Check for listener beans and register them.</span><br><span class="line">				// 检查监听Bean,并且将这些Bean向容器注册</span><br><span class="line">				registerListeners();</span><br><span class="line"></span><br><span class="line">				// Instantiate all remaining (non-lazy-init) singletons.这里是对lazy-init属性进行处理的地方</span><br><span class="line">				finishBeanFactoryInitialization(beanFactory);</span><br><span class="line"></span><br><span class="line">				// Last step: publish corresponding event.</span><br><span class="line">				// 发布容器事件,结束Refresh过程</span><br><span class="line">				finishRefresh();</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			catch (BeansException ex) &#123;</span><br><span class="line">				if (logger.isWarnEnabled()) &#123;</span><br><span class="line">					logger.warn(&quot;Exception encountered during context initialization - &quot; +</span><br><span class="line">							&quot;cancelling refresh attempt: &quot; + ex);</span><br><span class="line">				&#125;</span><br><span class="line"></span><br><span class="line">				// Destroy already created singletons to avoid dangling resources.</span><br><span class="line">				// 为防止Bean资环占用,在异常处理中,销毁已经在前面过程中生成的单件Bean</span><br><span class="line">				destroyBeans();</span><br><span class="line"></span><br><span class="line">				// Reset &apos;active&apos; flag.</span><br><span class="line">				cancelRefresh(ex);</span><br><span class="line"></span><br><span class="line">				// Propagate exception to caller.</span><br><span class="line">				throw ex;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			finally &#123;</span><br><span class="line">				// Reset common introspection caches in Spring&apos;s core, since we</span><br><span class="line">				// might not ever need metadata for singleton beans anymore...</span><br><span class="line">				resetCommonCaches();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure></p>
<p>registerBeanPostProcessors(beanFactory)是载入Bean实现的BeanPostProcessor接口，具体载入代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line">public static void registerBeanPostProcessors(</span><br><span class="line">			ConfigurableListableBeanFactory beanFactory, AbstractApplicationContext applicationContext) &#123;</span><br><span class="line"></span><br><span class="line">		String[] postProcessorNames = beanFactory.getBeanNamesForType(BeanPostProcessor.class, true, false);</span><br><span class="line"></span><br><span class="line">		// Register BeanPostProcessorChecker that logs an info message when</span><br><span class="line">		// a bean is created during BeanPostProcessor instantiation, i.e. when</span><br><span class="line">		// a bean is not eligible for getting processed by all BeanPostProcessors.</span><br><span class="line">		int beanProcessorTargetCount = beanFactory.getBeanPostProcessorCount() + 1 + postProcessorNames.length;</span><br><span class="line">		beanFactory.addBeanPostProcessor(new BeanPostProcessorChecker(beanFactory, beanProcessorTargetCount));</span><br><span class="line"></span><br><span class="line">		// Separate between BeanPostProcessors that implement PriorityOrdered,</span><br><span class="line">		// Ordered, and the rest.</span><br><span class="line">		List&lt;BeanPostProcessor&gt; priorityOrderedPostProcessors = new ArrayList&lt;&gt;();</span><br><span class="line">		List&lt;BeanPostProcessor&gt; internalPostProcessors = new ArrayList&lt;&gt;();</span><br><span class="line">		List&lt;String&gt; orderedPostProcessorNames = new ArrayList&lt;&gt;();</span><br><span class="line">		List&lt;String&gt; nonOrderedPostProcessorNames = new ArrayList&lt;&gt;();</span><br><span class="line">		for (String ppName : postProcessorNames) &#123;</span><br><span class="line">			if (beanFactory.isTypeMatch(ppName, PriorityOrdered.class)) &#123;</span><br><span class="line">				BeanPostProcessor pp = beanFactory.getBean(ppName, BeanPostProcessor.class);</span><br><span class="line">				priorityOrderedPostProcessors.add(pp);</span><br><span class="line">				if (pp instanceof MergedBeanDefinitionPostProcessor) &#123;</span><br><span class="line">					internalPostProcessors.add(pp);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			else if (beanFactory.isTypeMatch(ppName, Ordered.class)) &#123;</span><br><span class="line">				orderedPostProcessorNames.add(ppName);</span><br><span class="line">			&#125;</span><br><span class="line">			else &#123;</span><br><span class="line">				nonOrderedPostProcessorNames.add(ppName);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		// First, register the BeanPostProcessors that implement PriorityOrdered.</span><br><span class="line">		sortPostProcessors(beanFactory, priorityOrderedPostProcessors);</span><br><span class="line">		registerBeanPostProcessors(beanFactory, priorityOrderedPostProcessors);</span><br><span class="line"></span><br><span class="line">		// Next, register the BeanPostProcessors that implement Ordered.</span><br><span class="line">		List&lt;BeanPostProcessor&gt; orderedPostProcessors = new ArrayList&lt;&gt;();</span><br><span class="line">		for (String ppName : orderedPostProcessorNames) &#123;</span><br><span class="line">			BeanPostProcessor pp = beanFactory.getBean(ppName, BeanPostProcessor.class);</span><br><span class="line">			orderedPostProcessors.add(pp);</span><br><span class="line">			if (pp instanceof MergedBeanDefinitionPostProcessor) &#123;</span><br><span class="line">				internalPostProcessors.add(pp);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		sortPostProcessors(beanFactory, orderedPostProcessors);</span><br><span class="line">		registerBeanPostProcessors(beanFactory, orderedPostProcessors);</span><br><span class="line"></span><br><span class="line">		// Now, register all regular BeanPostProcessors.</span><br><span class="line">		List&lt;BeanPostProcessor&gt; nonOrderedPostProcessors = new ArrayList&lt;&gt;();</span><br><span class="line">		for (String ppName : nonOrderedPostProcessorNames) &#123;</span><br><span class="line">			BeanPostProcessor pp = beanFactory.getBean(ppName, BeanPostProcessor.class);</span><br><span class="line">			nonOrderedPostProcessors.add(pp);</span><br><span class="line">			if (pp instanceof MergedBeanDefinitionPostProcessor) &#123;</span><br><span class="line">				internalPostProcessors.add(pp);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		registerBeanPostProcessors(beanFactory, nonOrderedPostProcessors);</span><br><span class="line"></span><br><span class="line">		// Finally, re-register all internal BeanPostProcessors.</span><br><span class="line">		sortPostProcessors(beanFactory, internalPostProcessors);</span><br><span class="line">		registerBeanPostProcessors(beanFactory, internalPostProcessors);</span><br><span class="line"></span><br><span class="line">		beanFactory.addBeanPostProcessor(new ApplicationListenerDetector(applicationContext));</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure></p>
<p>invokeBeanFactoryPostProcessors(beanFactory)是载入Bean实现的BeanFactoryPostProcessor接口，具体载入如下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br></pre></td><td class="code"><pre><span class="line">public static void invokeBeanFactoryPostProcessors(</span><br><span class="line">			ConfigurableListableBeanFactory beanFactory, List&lt;BeanFactoryPostProcessor&gt; beanFactoryPostProcessors) &#123;</span><br><span class="line"></span><br><span class="line">		// Invoke BeanDefinitionRegistryPostProcessors first, if any.</span><br><span class="line">		Set&lt;String&gt; processedBeans = new HashSet&lt;&gt;();</span><br><span class="line"></span><br><span class="line">		if (beanFactory instanceof BeanDefinitionRegistry) &#123;</span><br><span class="line">			BeanDefinitionRegistry registry = (BeanDefinitionRegistry) beanFactory;</span><br><span class="line">			List&lt;BeanFactoryPostProcessor&gt; regularPostProcessors = new LinkedList&lt;&gt;();</span><br><span class="line">			List&lt;BeanDefinitionRegistryPostProcessor&gt; registryPostProcessors =</span><br><span class="line">					new LinkedList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">			for (BeanFactoryPostProcessor postProcessor : beanFactoryPostProcessors) &#123;</span><br><span class="line">				if (postProcessor instanceof BeanDefinitionRegistryPostProcessor) &#123;</span><br><span class="line">					BeanDefinitionRegistryPostProcessor registryPostProcessor =</span><br><span class="line">							(BeanDefinitionRegistryPostProcessor) postProcessor;</span><br><span class="line">					registryPostProcessor.postProcessBeanDefinitionRegistry(registry);</span><br><span class="line">					registryPostProcessors.add(registryPostProcessor);</span><br><span class="line">				&#125;</span><br><span class="line">				else &#123;</span><br><span class="line">					regularPostProcessors.add(postProcessor);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			// Do not initialize FactoryBeans here: We need to leave all regular beans</span><br><span class="line">			// uninitialized to let the bean factory post-processors apply to them!</span><br><span class="line">			// Separate between BeanDefinitionRegistryPostProcessors that implement</span><br><span class="line">			// PriorityOrdered, Ordered, and the rest.</span><br><span class="line">			String[] postProcessorNames =</span><br><span class="line">					beanFactory.getBeanNamesForType(BeanDefinitionRegistryPostProcessor.class, true, false);</span><br><span class="line"></span><br><span class="line">			// First, invoke the BeanDefinitionRegistryPostProcessors that implement PriorityOrdered.</span><br><span class="line">			List&lt;BeanDefinitionRegistryPostProcessor&gt; priorityOrderedPostProcessors = new ArrayList&lt;&gt;();</span><br><span class="line">			for (String ppName : postProcessorNames) &#123;</span><br><span class="line">				if (beanFactory.isTypeMatch(ppName, PriorityOrdered.class)) &#123;</span><br><span class="line">					priorityOrderedPostProcessors.add(beanFactory.getBean(ppName, BeanDefinitionRegistryPostProcessor.class));</span><br><span class="line">					processedBeans.add(ppName);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			sortPostProcessors(beanFactory, priorityOrderedPostProcessors);</span><br><span class="line">			registryPostProcessors.addAll(priorityOrderedPostProcessors);</span><br><span class="line">			invokeBeanDefinitionRegistryPostProcessors(priorityOrderedPostProcessors, registry);</span><br><span class="line"></span><br><span class="line">			// Next, invoke the BeanDefinitionRegistryPostProcessors that implement Ordered.</span><br><span class="line">			postProcessorNames = beanFactory.getBeanNamesForType(BeanDefinitionRegistryPostProcessor.class, true, false);</span><br><span class="line">			List&lt;BeanDefinitionRegistryPostProcessor&gt; orderedPostProcessors = new ArrayList&lt;&gt;();</span><br><span class="line">			for (String ppName : postProcessorNames) &#123;</span><br><span class="line">				if (!processedBeans.contains(ppName) &amp;&amp; beanFactory.isTypeMatch(ppName, Ordered.class)) &#123;</span><br><span class="line">					orderedPostProcessors.add(beanFactory.getBean(ppName, BeanDefinitionRegistryPostProcessor.class));</span><br><span class="line">					processedBeans.add(ppName);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			sortPostProcessors(beanFactory, orderedPostProcessors);</span><br><span class="line">			registryPostProcessors.addAll(orderedPostProcessors);</span><br><span class="line">			invokeBeanDefinitionRegistryPostProcessors(orderedPostProcessors, registry);</span><br><span class="line"></span><br><span class="line">			// Finally, invoke all other BeanDefinitionRegistryPostProcessors until no further ones appear.</span><br><span class="line">			boolean reiterate = true;</span><br><span class="line">			while (reiterate) &#123;</span><br><span class="line">				reiterate = false;</span><br><span class="line">				postProcessorNames = beanFactory.getBeanNamesForType(BeanDefinitionRegistryPostProcessor.class, true, false);</span><br><span class="line">				for (String ppName : postProcessorNames) &#123;</span><br><span class="line">					if (!processedBeans.contains(ppName)) &#123;</span><br><span class="line">						BeanDefinitionRegistryPostProcessor pp = beanFactory.getBean(ppName, BeanDefinitionRegistryPostProcessor.class);</span><br><span class="line">						registryPostProcessors.add(pp);</span><br><span class="line">						processedBeans.add(ppName);</span><br><span class="line">						pp.postProcessBeanDefinitionRegistry(registry);</span><br><span class="line">						reiterate = true;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			// Now, invoke the postProcessBeanFactory callback of all processors handled so far.</span><br><span class="line">			invokeBeanFactoryPostProcessors(registryPostProcessors, beanFactory);</span><br><span class="line">			invokeBeanFactoryPostProcessors(regularPostProcessors, beanFactory);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		else &#123;</span><br><span class="line">			// Invoke factory processors registered with the context instance.</span><br><span class="line">			invokeBeanFactoryPostProcessors(beanFactoryPostProcessors, beanFactory);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		// Do not initialize FactoryBeans here: We need to leave all regular beans</span><br><span class="line">		// uninitialized to let the bean factory post-processors apply to them!</span><br><span class="line">		String[] postProcessorNames =</span><br><span class="line">				beanFactory.getBeanNamesForType(BeanFactoryPostProcessor.class, true, false);</span><br><span class="line"></span><br><span class="line">		// Separate between BeanFactoryPostProcessors that implement PriorityOrdered,</span><br><span class="line">		// Ordered, and the rest.</span><br><span class="line">		List&lt;BeanFactoryPostProcessor&gt; priorityOrderedPostProcessors = new ArrayList&lt;&gt;();</span><br><span class="line">		List&lt;String&gt; orderedPostProcessorNames = new ArrayList&lt;&gt;();</span><br><span class="line">		List&lt;String&gt; nonOrderedPostProcessorNames = new ArrayList&lt;&gt;();</span><br><span class="line">		for (String ppName : postProcessorNames) &#123;</span><br><span class="line">			if (processedBeans.contains(ppName)) &#123;</span><br><span class="line">				// skip - already processed in first phase above</span><br><span class="line">			&#125;</span><br><span class="line">			else if (beanFactory.isTypeMatch(ppName, PriorityOrdered.class)) &#123;</span><br><span class="line">				priorityOrderedPostProcessors.add(beanFactory.getBean(ppName, BeanFactoryPostProcessor.class));</span><br><span class="line">			&#125;</span><br><span class="line">			else if (beanFactory.isTypeMatch(ppName, Ordered.class)) &#123;</span><br><span class="line">				orderedPostProcessorNames.add(ppName);</span><br><span class="line">			&#125;</span><br><span class="line">			else &#123;</span><br><span class="line">				nonOrderedPostProcessorNames.add(ppName);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		// First, invoke the BeanFactoryPostProcessors that implement PriorityOrdered.</span><br><span class="line">		sortPostProcessors(beanFactory, priorityOrderedPostProcessors);</span><br><span class="line">		invokeBeanFactoryPostProcessors(priorityOrderedPostProcessors, beanFactory);</span><br><span class="line"></span><br><span class="line">		// Next, invoke the BeanFactoryPostProcessors that implement Ordered.</span><br><span class="line">		List&lt;BeanFactoryPostProcessor&gt; orderedPostProcessors = new ArrayList&lt;&gt;();</span><br><span class="line">		for (String postProcessorName : orderedPostProcessorNames) &#123;</span><br><span class="line">			orderedPostProcessors.add(beanFactory.getBean(postProcessorName, BeanFactoryPostProcessor.class));</span><br><span class="line">		&#125;</span><br><span class="line">		sortPostProcessors(beanFactory, orderedPostProcessors);</span><br><span class="line">		invokeBeanFactoryPostProcessors(orderedPostProcessors, beanFactory);</span><br><span class="line"></span><br><span class="line">		// Finally, invoke all other BeanFactoryPostProcessors.</span><br><span class="line">		List&lt;BeanFactoryPostProcessor&gt; nonOrderedPostProcessors = new ArrayList&lt;&gt;();</span><br><span class="line">		for (String postProcessorName : nonOrderedPostProcessorNames) &#123;</span><br><span class="line">			nonOrderedPostProcessors.add(beanFactory.getBean(postProcessorName, BeanFactoryPostProcessor.class));</span><br><span class="line">		&#125;</span><br><span class="line">		invokeBeanFactoryPostProcessors(nonOrderedPostProcessors, beanFactory);</span><br><span class="line"></span><br><span class="line">		// Clear cached merged bean definitions since the post-processors might have</span><br><span class="line">		// modified the original metadata, e.g. replacing placeholders in values...</span><br><span class="line">		beanFactory.clearMetadataCache();</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure></p>
<p>所以我们可以看到BeanPostProcessor接口和BeanFactoryPostProcessor接口的载入只在abstractApplicationContext中执行了，而在DefaultListableBeanFactory<br>中没有执行，而我们测试用的工厂就是DefaultListableBeanFactory，所以实际是根本没有载入上面两个接口。<br>接下来我把测试代码换成如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@Test</span><br><span class="line">    public void test3() &#123;</span><br><span class="line">        ApplicationContext applicationContext = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;);</span><br><span class="line">        StudentService studentService = (StudentService)applicationContext.getBean(&quot;studentService&quot;);</span><br><span class="line">        studentService.read();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>然后执行，可以很清楚的看到那两个接口的方法都执行了。<br>原因是：ClassPathXmlApplicationContext是abstractApplicationContext的实现，所以使用这个工厂来管理bean，会载入如上两个接口。<br>总结：<br>其实我们两个测试代码分别使用了DefaultListableBeanFactory和ClassPathXmlApplicationContext作为Bean工厂，ClassPathXmlApplicationContext底层其实<br>也是使用的DefaultListableBeanFactory作为Bean工厂，但是ClassPathXmlApplicationContext在DefaultListableBeanFactory的基础上额外载入了<br>BeanPostProcessor接口和BeanFactoryPostProcessor接口，这个载入是在其父接口AbstractApplicationContext中执行的，这就是为什么test2测试代码不执行这两个接口的方法的原因。<br>此外，对于两个工厂而言，真正的在初始化的过程中调用这些接口的地方都是在底层工厂DefaultListableBeanFactory中,而DefaultListableBeanFactory<br>实际是调用的父接口AbstractAutowireCapableBeanFactory的initializeBean方法来进行初始化，从而调用那些初始化接口的方法</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="page-number current">2</span>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope="" itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">jasonjie</p>
              <p class="site-description motion-element" itemprop="description">生活不只眼前的苟且，还有诗和远方的田野</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">14</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            

            
              
              
              <div class="site-state-item site-state-tags">
                
                  <span class="site-state-item-count">4</span>
                  <span class="site-state-item-name">标签</span>
                
              </div>
            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">jasonjie</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Muse</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
