<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="utf-8">
  

  
  <title>Spring源码分析之BeanPostProcessor接口和BeanFactoryPostProcessor接口方法不执行原因分析 | Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="首先下面是我的Bean12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394/* * Copyr">
<meta name="keywords" content="Spring,Java,Linux">
<meta property="og:type" content="article">
<meta property="og:title" content="Spring源码分析之BeanPostProcessor接口和BeanFactoryPostProcessor接口方法不执行原因分析">
<meta property="og:url" content="http://yoursite.com/2017/09/08/2017-09-08-Spring源码分析之BeanPostProcessor接口和BeanFactoryPostProcessor接口方法不执行原因分析/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="首先下面是我的Bean12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394/* * Copyr">
<meta property="og:locale" content="zh-Hans">
<meta property="og:updated_time" content="2018-12-18T02:52:45.199Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Spring源码分析之BeanPostProcessor接口和BeanFactoryPostProcessor接口方法不执行原因分析">
<meta name="twitter:description" content="首先下面是我的Bean12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394/* * Copyr">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
</head>
</html>
<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
          <a class="main-nav-link" href="/about">about</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main"><article id="post-2017-09-08-Spring源码分析之BeanPostProcessor接口和BeanFactoryPostProcessor接口方法不执行原因分析" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/09/08/2017-09-08-Spring源码分析之BeanPostProcessor接口和BeanFactoryPostProcessor接口方法不执行原因分析/" class="article-date">
  <time datetime="2017-09-07T16:00:00.000Z" itemprop="datePublished">2017-09-08</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      Spring源码分析之BeanPostProcessor接口和BeanFactoryPostProcessor接口方法不执行原因分析
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>首先下面是我的Bean<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line"> * Copyright 2002-2017 the original author or authors.</span><br><span class="line"> *</span><br><span class="line"> * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);</span><br><span class="line"> * you may not use this file except in compliance with the License.</span><br><span class="line"> * You may obtain a copy of the License at</span><br><span class="line"> *</span><br><span class="line"> *      http://www.apache.org/licenses/LICENSE-2.0</span><br><span class="line"> *</span><br><span class="line"> * Unless required by applicable law or agreed to in writing, software</span><br><span class="line"> * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,</span><br><span class="line"> * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.</span><br><span class="line"> * See the License for the specific language governing permissions and</span><br><span class="line"> * limitations under the License.</span><br><span class="line"> */</span><br><span class="line">package com.verify.constant;</span><br><span class="line"></span><br><span class="line">import org.springframework.beans.BeansException;</span><br><span class="line">import org.springframework.beans.PropertyValues;</span><br><span class="line">import org.springframework.beans.factory.*;</span><br><span class="line">import org.springframework.beans.factory.config.BeanFactoryPostProcessor;</span><br><span class="line">import org.springframework.beans.factory.config.BeanPostProcessor;</span><br><span class="line">import org.springframework.beans.factory.config.ConfigurableListableBeanFactory;</span><br><span class="line">import org.springframework.beans.factory.config.InstantiationAwareBeanPostProcessor;</span><br><span class="line"></span><br><span class="line">import java.beans.PropertyDescriptor;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * TODO</span><br><span class="line"> *</span><br><span class="line"> * @author linjiedeng</span><br><span class="line"> * @date 17/5/8 下午10:47</span><br><span class="line"> * @since TODO</span><br><span class="line"> */</span><br><span class="line">public class StudentService implements BeanPostProcessor, InitializingBean, BeanFactoryPostProcessor, BeanNameAware, BeanClassLoaderAware, BeanFactoryAware &#123;</span><br><span class="line"></span><br><span class="line">    private ClassLoader classLoader;</span><br><span class="line"></span><br><span class="line">    private BeanFactory beanFactory;</span><br><span class="line"></span><br><span class="line">    private String name;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void setBeanClassLoader(ClassLoader classLoader) &#123;</span><br><span class="line">        this.classLoader = classLoader; //实现BeanClassLoaderAware接口可以获取到对应的classLoader</span><br><span class="line">        System.out.println(&quot;set bean class loader&quot;);</span><br><span class="line">        System.out.println(classLoader);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void setBeanFactory(BeanFactory beanFactory) throws BeansException &#123;</span><br><span class="line">        this.beanFactory = beanFactory; //实现BeanFactoryAware接口获取该Bean的beanFactory</span><br><span class="line">        System.out.println(&quot;set bean factory&quot;);</span><br><span class="line">        System.out.println(beanFactory);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void setBeanName(String name) &#123;</span><br><span class="line">        this.name = name;   //实现BeanNameAware接口获取该Bean的名字</span><br><span class="line">        System.out.println(&quot;set bean name&quot;);</span><br><span class="line">        System.out.println(name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void initMethod() &#123;</span><br><span class="line">        System.out.println(&quot;init method&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void afterPropertiesSet() throws Exception &#123;</span><br><span class="line">        System.out.println(&quot;afterPropertiesSet&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public Object postProcessBeforeInitialization(Object bean, String beanName) throws BeansException &#123;</span><br><span class="line">        System.out.println(&quot;postProcessBeforeInitialization&quot;);</span><br><span class="line">        return bean;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public Object postProcessAfterInitialization(Object bean, String beanName) throws BeansException &#123;</span><br><span class="line">        System.out.println(&quot;postProcessAfterInitialization&quot;);</span><br><span class="line">        return bean;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void postProcessBeanFactory(ConfigurableListableBeanFactory beanFactory) throws BeansException &#123;</span><br><span class="line">        System.out.println(&quot;postProcessBeanFactory&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void read() &#123;</span><br><span class="line">        System.out.println(&quot;Student service read&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>bean的配置文件applicationContext.xml内容如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;</span><br><span class="line">       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span><br><span class="line">       xmlns:context=&quot;http://www.springframework.org/schema/context&quot;</span><br><span class="line">       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans</span><br><span class="line">        http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd&quot;&gt;</span><br><span class="line"></span><br><span class="line">    &lt;bean id=&quot;studentService&quot; class=&quot;com.verify.constant.StudentService&quot; init-method=&quot;initMethod&quot;/&gt;</span><br><span class="line">&lt;/beans&gt;</span><br></pre></td></tr></table></figure></p>
<p>测试代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">@Test</span><br><span class="line">    public void test2() &#123;</span><br><span class="line">        ClassPathResource resource = new ClassPathResource(&quot;applicationContext.xml&quot;);</span><br><span class="line">        DefaultListableBeanFactory factory = new DefaultListableBeanFactory();</span><br><span class="line">        XmlBeanDefinitionReader reader = new XmlBeanDefinitionReader(factory);</span><br><span class="line">        reader.loadBeanDefinitions(resource);</span><br><span class="line">        StudentService studentService = (StudentService)factory.getBean(&quot;studentService&quot;);</span><br><span class="line">        studentService.read();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>测试代码执行后，其他方法都执行了，但是唯独BeanPostProcessor接口的两个方法postProcessBeforeInitialization和postProcessAfterInitialization以及<br>BeanFactoryPostProcessor接口的方法没有执行，这我就有点疑惑了，这是咋回事？其实这两个接口应该是在bean初始化的过程中被调用，是在AbstractAutowireCapableBeanFactory接口的initializeBean初始化方法中被调用的，代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">protected Object initializeBean(final String beanName, final Object bean, RootBeanDefinition mbd) &#123;</span><br><span class="line">		if (System.getSecurityManager() != null) &#123;</span><br><span class="line">			AccessController.doPrivileged(new PrivilegedAction&lt;Object&gt;() &#123;</span><br><span class="line">				@Override</span><br><span class="line">				public Object run() &#123;</span><br><span class="line">					invokeAwareMethods(beanName, bean);</span><br><span class="line">					return null;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;, getAccessControlContext());</span><br><span class="line">		&#125;</span><br><span class="line">		else &#123;</span><br><span class="line">			invokeAwareMethods(beanName, bean);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		Object wrappedBean = bean;</span><br><span class="line">		if (mbd == null || !mbd.isSynthetic()) &#123;</span><br><span class="line">			//执行BeanPostProcessor扩展点的PostProcessBeforeInitialization进行修改实例化Bean</span><br><span class="line">			wrappedBean = applyBeanPostProcessorsBeforeInitialization(wrappedBean, beanName);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		try &#123;</span><br><span class="line">			//调用Bean的初始化方法,这个初始化方法是在BeanDefinition中通过定义init-method属性指定的</span><br><span class="line">			//同时,如果Bean实现了InitializingBean接口,那么这个Bean的afterPropertiesSet实现也不会被调用</span><br><span class="line">			invokeInitMethods(beanName, wrappedBean, mbd);</span><br><span class="line">		&#125;</span><br><span class="line">		catch (Throwable ex) &#123;</span><br><span class="line">			throw new BeanCreationException(</span><br><span class="line">					(mbd != null ? mbd.getResourceDescription() : null),</span><br><span class="line">					beanName, &quot;Invocation of init method failed&quot;, ex);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		if (mbd == null || !mbd.isSynthetic()) &#123;</span><br><span class="line">			//执行BeanPostProcessor扩展点的PostProcessAfterInitialization进行修改实例化Bean</span><br><span class="line">			wrappedBean = applyBeanPostProcessorsAfterInitialization(wrappedBean, beanName);</span><br><span class="line">		&#125;</span><br><span class="line">		return wrappedBean;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure></p>
<p>initializeBean方法是Bean的初始化方法，在该初始化方法中会调用Bean的一些初始化方法，比如如下方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">private void invokeAwareMethods(final String beanName, final Object bean) &#123;</span><br><span class="line">		if (bean instanceof Aware) &#123;</span><br><span class="line">			if (bean instanceof BeanNameAware) &#123;</span><br><span class="line">				((BeanNameAware) bean).setBeanName(beanName);</span><br><span class="line">			&#125;</span><br><span class="line">			if (bean instanceof BeanClassLoaderAware) &#123;</span><br><span class="line">				((BeanClassLoaderAware) bean).setBeanClassLoader(getBeanClassLoader());</span><br><span class="line">			&#125;</span><br><span class="line">			if (bean instanceof BeanFactoryAware) &#123;</span><br><span class="line">				((BeanFactoryAware) bean).setBeanFactory(AbstractAutowireCapableBeanFactory.this);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure></p>
<p>即只要Bean实现了BeanNameAware接口，这里就会帮你调用，BeanClassLoaderAware和BeanFactory接口同样如此，上述我的代码中就实现了这三个接口，启动的过程中都被调用了，再实现的方法中可以获取这些信息，并存储。<br>再比如如下方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public Object applyBeanPostProcessorsBeforeInitialization(Object existingBean, String beanName)</span><br><span class="line">			throws BeansException &#123;</span><br><span class="line"></span><br><span class="line">		Object result = existingBean;</span><br><span class="line">		for (BeanPostProcessor beanProcessor : getBeanPostProcessors()) &#123;</span><br><span class="line">			result = beanProcessor.postProcessBeforeInitialization(result, beanName);</span><br><span class="line">			if (result == null) &#123;</span><br><span class="line">				return result;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		return result;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure></p>
<p>这里其实是如果Bean实现了BeanPostProcessor接口，这里就会调用bean实现的postProcessBeforeInitialization方法，这是在bean的真正初始化之前被调用<br>对应的BeanPostProcessor接口的另外一个方法，是在bean的初始化之后被调用，如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public Object applyBeanPostProcessorsAfterInitialization(Object existingBean, String beanName)</span><br><span class="line">			throws BeansException &#123;</span><br><span class="line"></span><br><span class="line">		Object result = existingBean;</span><br><span class="line">		for (BeanPostProcessor beanProcessor : getBeanPostProcessors()) &#123;</span><br><span class="line">			result = beanProcessor.postProcessAfterInitialization(result, beanName);</span><br><span class="line">			if (result == null) &#123;</span><br><span class="line">				return result;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		return result;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure></p>
<p>真正的初始化是在如下方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">protected void invokeInitMethods(String beanName, final Object bean, RootBeanDefinition mbd)</span><br><span class="line">			throws Throwable &#123;</span><br><span class="line"></span><br><span class="line">		boolean isInitializingBean = (bean instanceof InitializingBean);</span><br><span class="line">		if (isInitializingBean &amp;&amp; (mbd == null || !mbd.isExternallyManagedInitMethod(&quot;afterPropertiesSet&quot;))) &#123;</span><br><span class="line">			if (logger.isDebugEnabled()) &#123;</span><br><span class="line">				logger.debug(&quot;Invoking afterPropertiesSet() on bean with name &apos;&quot; + beanName + &quot;&apos;&quot;);</span><br><span class="line">			&#125;</span><br><span class="line">			if (System.getSecurityManager() != null) &#123;</span><br><span class="line">				try &#123;</span><br><span class="line">					AccessController.doPrivileged(new PrivilegedExceptionAction&lt;Object&gt;() &#123;</span><br><span class="line">						@Override</span><br><span class="line">						public Object run() throws Exception &#123;</span><br><span class="line">							((InitializingBean) bean).afterPropertiesSet();</span><br><span class="line">							return null;</span><br><span class="line">						&#125;</span><br><span class="line">					&#125;, getAccessControlContext());</span><br><span class="line">				&#125;</span><br><span class="line">				catch (PrivilegedActionException pae) &#123;</span><br><span class="line">					throw pae.getException();</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			else &#123;</span><br><span class="line">				((InitializingBean) bean).afterPropertiesSet();	//启动afterPropertiesSet,afterPropertiesSet是InitializingBean接口的方法</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		if (mbd != null) &#123;</span><br><span class="line">			String initMethodName = mbd.getInitMethodName();	//获取用户自定义的初始化方法</span><br><span class="line">			if (initMethodName != null &amp;&amp; !(isInitializingBean &amp;&amp; &quot;afterPropertiesSet&quot;.equals(initMethodName)) &amp;&amp;</span><br><span class="line">					!mbd.isExternallyManagedInitMethod(initMethodName)) &#123;</span><br><span class="line">				invokeCustomInitMethod(beanName, bean, mbd);	//调用自定义的初始化方法</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure></p>
<p>可以看到，上述代码实际上是在调用Bean实现的initializingBean接口的afterPropertiesSet方法来初始化Bean，接下来还调用了用户自定义的init-method方法，可以看到上面我的applicationContext.xml配置文件中配置的有一个initMethod方法，这就是自定义的初始化方法，这个方法也是在这里被调用的</p>
<p>好，代码分析到这，也可以看到了，既然这里初始化的时候调用了BeanPostProcessor的那两个方法，但是我的测试代码为什么没有执行这两个方法呢？<br>其实可以看到真正执行BeanPostProcessor接口的代码是如下代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public Object applyBeanPostProcessorsBeforeInitialization(Object existingBean, String beanName)</span><br><span class="line">			throws BeansException &#123;</span><br><span class="line"></span><br><span class="line">		Object result = existingBean;</span><br><span class="line">		for (BeanPostProcessor beanProcessor : getBeanPostProcessors()) &#123;</span><br><span class="line">			result = beanProcessor.postProcessBeforeInitialization(result, beanName);</span><br><span class="line">			if (result == null) &#123;</span><br><span class="line">				return result;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		return result;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure></p>
<p>其中的getBeanPostProcessors()方法获取的实际就是AbstractBeanFactory的this.beanPostProcessors属性值，看来是这个属性值为空，所以执行的时候没有调用<br>那接下来要分析的原因就是为什么this.beanPostProcessors属性值为空呢？或者说bean的载入时为什么没有载入进来呢？那就要看它是在哪里载入的了，最终定位到载入是在<br>AbstractApplicationContext中执行的<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">	public void refresh() throws BeansException, IllegalStateException &#123;</span><br><span class="line">		synchronized (this.startupShutdownMonitor) &#123;</span><br><span class="line">			// Prepare this context for refreshing.</span><br><span class="line">			prepareRefresh();</span><br><span class="line"></span><br><span class="line">			//这是在子类中启动refreshBeanFactory的地方</span><br><span class="line">			// Tell the subclass to refresh the internal bean factory.</span><br><span class="line">			ConfigurableListableBeanFactory beanFactory = obtainFreshBeanFactory();</span><br><span class="line"></span><br><span class="line">			// Prepare the bean factory for use in this context.</span><br><span class="line">			prepareBeanFactory(beanFactory);</span><br><span class="line"></span><br><span class="line">			try &#123;</span><br><span class="line">				// Allows post-processing of the bean factory in context subclasses.</span><br><span class="line">				// 设置BeanFactory的后置处理</span><br><span class="line">				postProcessBeanFactory(beanFactory);</span><br><span class="line"></span><br><span class="line">				// Invoke factory processors registered as beans in the context.</span><br><span class="line">				// 调用BeanFactory的后处理器,这些后处理器是在Bean定义中向容器注册的</span><br><span class="line">				invokeBeanFactoryPostProcessors(beanFactory);</span><br><span class="line"></span><br><span class="line">				// Register bean processors that intercept bean creation.</span><br><span class="line">				// 注册Bean的后处理器,在Bean创建过程中调用</span><br><span class="line">				registerBeanPostProcessors(beanFactory);</span><br><span class="line"></span><br><span class="line">				// Initialize message source for this context.</span><br><span class="line">				// 对上下文中的消息源进行初始化</span><br><span class="line">				initMessageSource();</span><br><span class="line"></span><br><span class="line">				// Initialize event multicaster for this context.</span><br><span class="line">				// 初始化上下文中的事件机制</span><br><span class="line">				initApplicationEventMulticaster();</span><br><span class="line"></span><br><span class="line">				// Initialize other special beans in specific context subclasses.</span><br><span class="line">				// 初始化其他的特殊Bean</span><br><span class="line">				onRefresh();</span><br><span class="line"></span><br><span class="line">				// Check for listener beans and register them.</span><br><span class="line">				// 检查监听Bean,并且将这些Bean向容器注册</span><br><span class="line">				registerListeners();</span><br><span class="line"></span><br><span class="line">				// Instantiate all remaining (non-lazy-init) singletons.这里是对lazy-init属性进行处理的地方</span><br><span class="line">				finishBeanFactoryInitialization(beanFactory);</span><br><span class="line"></span><br><span class="line">				// Last step: publish corresponding event.</span><br><span class="line">				// 发布容器事件,结束Refresh过程</span><br><span class="line">				finishRefresh();</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			catch (BeansException ex) &#123;</span><br><span class="line">				if (logger.isWarnEnabled()) &#123;</span><br><span class="line">					logger.warn(&quot;Exception encountered during context initialization - &quot; +</span><br><span class="line">							&quot;cancelling refresh attempt: &quot; + ex);</span><br><span class="line">				&#125;</span><br><span class="line"></span><br><span class="line">				// Destroy already created singletons to avoid dangling resources.</span><br><span class="line">				// 为防止Bean资环占用,在异常处理中,销毁已经在前面过程中生成的单件Bean</span><br><span class="line">				destroyBeans();</span><br><span class="line"></span><br><span class="line">				// Reset &apos;active&apos; flag.</span><br><span class="line">				cancelRefresh(ex);</span><br><span class="line"></span><br><span class="line">				// Propagate exception to caller.</span><br><span class="line">				throw ex;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			finally &#123;</span><br><span class="line">				// Reset common introspection caches in Spring&apos;s core, since we</span><br><span class="line">				// might not ever need metadata for singleton beans anymore...</span><br><span class="line">				resetCommonCaches();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure></p>
<p>registerBeanPostProcessors(beanFactory)是载入Bean实现的BeanPostProcessor接口，具体载入代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line">public static void registerBeanPostProcessors(</span><br><span class="line">			ConfigurableListableBeanFactory beanFactory, AbstractApplicationContext applicationContext) &#123;</span><br><span class="line"></span><br><span class="line">		String[] postProcessorNames = beanFactory.getBeanNamesForType(BeanPostProcessor.class, true, false);</span><br><span class="line"></span><br><span class="line">		// Register BeanPostProcessorChecker that logs an info message when</span><br><span class="line">		// a bean is created during BeanPostProcessor instantiation, i.e. when</span><br><span class="line">		// a bean is not eligible for getting processed by all BeanPostProcessors.</span><br><span class="line">		int beanProcessorTargetCount = beanFactory.getBeanPostProcessorCount() + 1 + postProcessorNames.length;</span><br><span class="line">		beanFactory.addBeanPostProcessor(new BeanPostProcessorChecker(beanFactory, beanProcessorTargetCount));</span><br><span class="line"></span><br><span class="line">		// Separate between BeanPostProcessors that implement PriorityOrdered,</span><br><span class="line">		// Ordered, and the rest.</span><br><span class="line">		List&lt;BeanPostProcessor&gt; priorityOrderedPostProcessors = new ArrayList&lt;&gt;();</span><br><span class="line">		List&lt;BeanPostProcessor&gt; internalPostProcessors = new ArrayList&lt;&gt;();</span><br><span class="line">		List&lt;String&gt; orderedPostProcessorNames = new ArrayList&lt;&gt;();</span><br><span class="line">		List&lt;String&gt; nonOrderedPostProcessorNames = new ArrayList&lt;&gt;();</span><br><span class="line">		for (String ppName : postProcessorNames) &#123;</span><br><span class="line">			if (beanFactory.isTypeMatch(ppName, PriorityOrdered.class)) &#123;</span><br><span class="line">				BeanPostProcessor pp = beanFactory.getBean(ppName, BeanPostProcessor.class);</span><br><span class="line">				priorityOrderedPostProcessors.add(pp);</span><br><span class="line">				if (pp instanceof MergedBeanDefinitionPostProcessor) &#123;</span><br><span class="line">					internalPostProcessors.add(pp);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			else if (beanFactory.isTypeMatch(ppName, Ordered.class)) &#123;</span><br><span class="line">				orderedPostProcessorNames.add(ppName);</span><br><span class="line">			&#125;</span><br><span class="line">			else &#123;</span><br><span class="line">				nonOrderedPostProcessorNames.add(ppName);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		// First, register the BeanPostProcessors that implement PriorityOrdered.</span><br><span class="line">		sortPostProcessors(beanFactory, priorityOrderedPostProcessors);</span><br><span class="line">		registerBeanPostProcessors(beanFactory, priorityOrderedPostProcessors);</span><br><span class="line"></span><br><span class="line">		// Next, register the BeanPostProcessors that implement Ordered.</span><br><span class="line">		List&lt;BeanPostProcessor&gt; orderedPostProcessors = new ArrayList&lt;&gt;();</span><br><span class="line">		for (String ppName : orderedPostProcessorNames) &#123;</span><br><span class="line">			BeanPostProcessor pp = beanFactory.getBean(ppName, BeanPostProcessor.class);</span><br><span class="line">			orderedPostProcessors.add(pp);</span><br><span class="line">			if (pp instanceof MergedBeanDefinitionPostProcessor) &#123;</span><br><span class="line">				internalPostProcessors.add(pp);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		sortPostProcessors(beanFactory, orderedPostProcessors);</span><br><span class="line">		registerBeanPostProcessors(beanFactory, orderedPostProcessors);</span><br><span class="line"></span><br><span class="line">		// Now, register all regular BeanPostProcessors.</span><br><span class="line">		List&lt;BeanPostProcessor&gt; nonOrderedPostProcessors = new ArrayList&lt;&gt;();</span><br><span class="line">		for (String ppName : nonOrderedPostProcessorNames) &#123;</span><br><span class="line">			BeanPostProcessor pp = beanFactory.getBean(ppName, BeanPostProcessor.class);</span><br><span class="line">			nonOrderedPostProcessors.add(pp);</span><br><span class="line">			if (pp instanceof MergedBeanDefinitionPostProcessor) &#123;</span><br><span class="line">				internalPostProcessors.add(pp);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		registerBeanPostProcessors(beanFactory, nonOrderedPostProcessors);</span><br><span class="line"></span><br><span class="line">		// Finally, re-register all internal BeanPostProcessors.</span><br><span class="line">		sortPostProcessors(beanFactory, internalPostProcessors);</span><br><span class="line">		registerBeanPostProcessors(beanFactory, internalPostProcessors);</span><br><span class="line"></span><br><span class="line">		beanFactory.addBeanPostProcessor(new ApplicationListenerDetector(applicationContext));</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure></p>
<p>invokeBeanFactoryPostProcessors(beanFactory)是载入Bean实现的BeanFactoryPostProcessor接口，具体载入如下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br></pre></td><td class="code"><pre><span class="line">public static void invokeBeanFactoryPostProcessors(</span><br><span class="line">			ConfigurableListableBeanFactory beanFactory, List&lt;BeanFactoryPostProcessor&gt; beanFactoryPostProcessors) &#123;</span><br><span class="line"></span><br><span class="line">		// Invoke BeanDefinitionRegistryPostProcessors first, if any.</span><br><span class="line">		Set&lt;String&gt; processedBeans = new HashSet&lt;&gt;();</span><br><span class="line"></span><br><span class="line">		if (beanFactory instanceof BeanDefinitionRegistry) &#123;</span><br><span class="line">			BeanDefinitionRegistry registry = (BeanDefinitionRegistry) beanFactory;</span><br><span class="line">			List&lt;BeanFactoryPostProcessor&gt; regularPostProcessors = new LinkedList&lt;&gt;();</span><br><span class="line">			List&lt;BeanDefinitionRegistryPostProcessor&gt; registryPostProcessors =</span><br><span class="line">					new LinkedList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">			for (BeanFactoryPostProcessor postProcessor : beanFactoryPostProcessors) &#123;</span><br><span class="line">				if (postProcessor instanceof BeanDefinitionRegistryPostProcessor) &#123;</span><br><span class="line">					BeanDefinitionRegistryPostProcessor registryPostProcessor =</span><br><span class="line">							(BeanDefinitionRegistryPostProcessor) postProcessor;</span><br><span class="line">					registryPostProcessor.postProcessBeanDefinitionRegistry(registry);</span><br><span class="line">					registryPostProcessors.add(registryPostProcessor);</span><br><span class="line">				&#125;</span><br><span class="line">				else &#123;</span><br><span class="line">					regularPostProcessors.add(postProcessor);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			// Do not initialize FactoryBeans here: We need to leave all regular beans</span><br><span class="line">			// uninitialized to let the bean factory post-processors apply to them!</span><br><span class="line">			// Separate between BeanDefinitionRegistryPostProcessors that implement</span><br><span class="line">			// PriorityOrdered, Ordered, and the rest.</span><br><span class="line">			String[] postProcessorNames =</span><br><span class="line">					beanFactory.getBeanNamesForType(BeanDefinitionRegistryPostProcessor.class, true, false);</span><br><span class="line"></span><br><span class="line">			// First, invoke the BeanDefinitionRegistryPostProcessors that implement PriorityOrdered.</span><br><span class="line">			List&lt;BeanDefinitionRegistryPostProcessor&gt; priorityOrderedPostProcessors = new ArrayList&lt;&gt;();</span><br><span class="line">			for (String ppName : postProcessorNames) &#123;</span><br><span class="line">				if (beanFactory.isTypeMatch(ppName, PriorityOrdered.class)) &#123;</span><br><span class="line">					priorityOrderedPostProcessors.add(beanFactory.getBean(ppName, BeanDefinitionRegistryPostProcessor.class));</span><br><span class="line">					processedBeans.add(ppName);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			sortPostProcessors(beanFactory, priorityOrderedPostProcessors);</span><br><span class="line">			registryPostProcessors.addAll(priorityOrderedPostProcessors);</span><br><span class="line">			invokeBeanDefinitionRegistryPostProcessors(priorityOrderedPostProcessors, registry);</span><br><span class="line"></span><br><span class="line">			// Next, invoke the BeanDefinitionRegistryPostProcessors that implement Ordered.</span><br><span class="line">			postProcessorNames = beanFactory.getBeanNamesForType(BeanDefinitionRegistryPostProcessor.class, true, false);</span><br><span class="line">			List&lt;BeanDefinitionRegistryPostProcessor&gt; orderedPostProcessors = new ArrayList&lt;&gt;();</span><br><span class="line">			for (String ppName : postProcessorNames) &#123;</span><br><span class="line">				if (!processedBeans.contains(ppName) &amp;&amp; beanFactory.isTypeMatch(ppName, Ordered.class)) &#123;</span><br><span class="line">					orderedPostProcessors.add(beanFactory.getBean(ppName, BeanDefinitionRegistryPostProcessor.class));</span><br><span class="line">					processedBeans.add(ppName);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			sortPostProcessors(beanFactory, orderedPostProcessors);</span><br><span class="line">			registryPostProcessors.addAll(orderedPostProcessors);</span><br><span class="line">			invokeBeanDefinitionRegistryPostProcessors(orderedPostProcessors, registry);</span><br><span class="line"></span><br><span class="line">			// Finally, invoke all other BeanDefinitionRegistryPostProcessors until no further ones appear.</span><br><span class="line">			boolean reiterate = true;</span><br><span class="line">			while (reiterate) &#123;</span><br><span class="line">				reiterate = false;</span><br><span class="line">				postProcessorNames = beanFactory.getBeanNamesForType(BeanDefinitionRegistryPostProcessor.class, true, false);</span><br><span class="line">				for (String ppName : postProcessorNames) &#123;</span><br><span class="line">					if (!processedBeans.contains(ppName)) &#123;</span><br><span class="line">						BeanDefinitionRegistryPostProcessor pp = beanFactory.getBean(ppName, BeanDefinitionRegistryPostProcessor.class);</span><br><span class="line">						registryPostProcessors.add(pp);</span><br><span class="line">						processedBeans.add(ppName);</span><br><span class="line">						pp.postProcessBeanDefinitionRegistry(registry);</span><br><span class="line">						reiterate = true;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			// Now, invoke the postProcessBeanFactory callback of all processors handled so far.</span><br><span class="line">			invokeBeanFactoryPostProcessors(registryPostProcessors, beanFactory);</span><br><span class="line">			invokeBeanFactoryPostProcessors(regularPostProcessors, beanFactory);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		else &#123;</span><br><span class="line">			// Invoke factory processors registered with the context instance.</span><br><span class="line">			invokeBeanFactoryPostProcessors(beanFactoryPostProcessors, beanFactory);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		// Do not initialize FactoryBeans here: We need to leave all regular beans</span><br><span class="line">		// uninitialized to let the bean factory post-processors apply to them!</span><br><span class="line">		String[] postProcessorNames =</span><br><span class="line">				beanFactory.getBeanNamesForType(BeanFactoryPostProcessor.class, true, false);</span><br><span class="line"></span><br><span class="line">		// Separate between BeanFactoryPostProcessors that implement PriorityOrdered,</span><br><span class="line">		// Ordered, and the rest.</span><br><span class="line">		List&lt;BeanFactoryPostProcessor&gt; priorityOrderedPostProcessors = new ArrayList&lt;&gt;();</span><br><span class="line">		List&lt;String&gt; orderedPostProcessorNames = new ArrayList&lt;&gt;();</span><br><span class="line">		List&lt;String&gt; nonOrderedPostProcessorNames = new ArrayList&lt;&gt;();</span><br><span class="line">		for (String ppName : postProcessorNames) &#123;</span><br><span class="line">			if (processedBeans.contains(ppName)) &#123;</span><br><span class="line">				// skip - already processed in first phase above</span><br><span class="line">			&#125;</span><br><span class="line">			else if (beanFactory.isTypeMatch(ppName, PriorityOrdered.class)) &#123;</span><br><span class="line">				priorityOrderedPostProcessors.add(beanFactory.getBean(ppName, BeanFactoryPostProcessor.class));</span><br><span class="line">			&#125;</span><br><span class="line">			else if (beanFactory.isTypeMatch(ppName, Ordered.class)) &#123;</span><br><span class="line">				orderedPostProcessorNames.add(ppName);</span><br><span class="line">			&#125;</span><br><span class="line">			else &#123;</span><br><span class="line">				nonOrderedPostProcessorNames.add(ppName);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		// First, invoke the BeanFactoryPostProcessors that implement PriorityOrdered.</span><br><span class="line">		sortPostProcessors(beanFactory, priorityOrderedPostProcessors);</span><br><span class="line">		invokeBeanFactoryPostProcessors(priorityOrderedPostProcessors, beanFactory);</span><br><span class="line"></span><br><span class="line">		// Next, invoke the BeanFactoryPostProcessors that implement Ordered.</span><br><span class="line">		List&lt;BeanFactoryPostProcessor&gt; orderedPostProcessors = new ArrayList&lt;&gt;();</span><br><span class="line">		for (String postProcessorName : orderedPostProcessorNames) &#123;</span><br><span class="line">			orderedPostProcessors.add(beanFactory.getBean(postProcessorName, BeanFactoryPostProcessor.class));</span><br><span class="line">		&#125;</span><br><span class="line">		sortPostProcessors(beanFactory, orderedPostProcessors);</span><br><span class="line">		invokeBeanFactoryPostProcessors(orderedPostProcessors, beanFactory);</span><br><span class="line"></span><br><span class="line">		// Finally, invoke all other BeanFactoryPostProcessors.</span><br><span class="line">		List&lt;BeanFactoryPostProcessor&gt; nonOrderedPostProcessors = new ArrayList&lt;&gt;();</span><br><span class="line">		for (String postProcessorName : nonOrderedPostProcessorNames) &#123;</span><br><span class="line">			nonOrderedPostProcessors.add(beanFactory.getBean(postProcessorName, BeanFactoryPostProcessor.class));</span><br><span class="line">		&#125;</span><br><span class="line">		invokeBeanFactoryPostProcessors(nonOrderedPostProcessors, beanFactory);</span><br><span class="line"></span><br><span class="line">		// Clear cached merged bean definitions since the post-processors might have</span><br><span class="line">		// modified the original metadata, e.g. replacing placeholders in values...</span><br><span class="line">		beanFactory.clearMetadataCache();</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure></p>
<p>所以我们可以看到BeanPostProcessor接口和BeanFactoryPostProcessor接口的载入只在abstractApplicationContext中执行了，而在DefaultListableBeanFactory<br>中没有执行，而我们测试用的工厂就是DefaultListableBeanFactory，所以实际是根本没有载入上面两个接口。<br>接下来我把测试代码换成如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@Test</span><br><span class="line">    public void test3() &#123;</span><br><span class="line">        ApplicationContext applicationContext = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;);</span><br><span class="line">        StudentService studentService = (StudentService)applicationContext.getBean(&quot;studentService&quot;);</span><br><span class="line">        studentService.read();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>然后执行，可以很清楚的看到那两个接口的方法都执行了。<br>原因是：ClassPathXmlApplicationContext是abstractApplicationContext的实现，所以使用这个工厂来管理bean，会载入如上两个接口。<br>总结：<br>其实我们两个测试代码分别使用了DefaultListableBeanFactory和ClassPathXmlApplicationContext作为Bean工厂，ClassPathXmlApplicationContext底层其实<br>也是使用的DefaultListableBeanFactory作为Bean工厂，但是ClassPathXmlApplicationContext在DefaultListableBeanFactory的基础上额外载入了<br>BeanPostProcessor接口和BeanFactoryPostProcessor接口，这个载入是在其父接口AbstractApplicationContext中执行的，这就是为什么test2测试代码不执行这两个接口的方法的原因。<br>此外，对于两个工厂而言，真正的在初始化的过程中调用这些接口的地方都是在底层工厂DefaultListableBeanFactory中,而DefaultListableBeanFactory<br>实际是调用的父接口AbstractAutowireCapableBeanFactory的initializeBean方法来进行初始化，从而调用那些初始化接口的方法</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2017/09/08/2017-09-08-Spring源码分析之BeanPostProcessor接口和BeanFactoryPostProcessor接口方法不执行原因分析/" data-id="cjpt6ef85001p7kmzaqtmwoo5" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Java/">Java</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Linux/">Linux</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Spring/">Spring</a></li></ul>

    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2017/09/08/2017-09-08-Spring源码分析之ProxyFactoryBean方式实现Aop功能的分析/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          Spring源码分析之ProxyFactoryBean方式实现Aop功能的分析
        
      </div>
    </a>
  
  
</nav>

  
</article>

</section>
        
          <aside id="sidebar">
  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/Java/">Java</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Linux/">Linux</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Spring/">Spring</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/hadoop/">hadoop</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/Java/" style="font-size: 20px;">Java</a> <a href="/tags/Linux/" style="font-size: 20px;">Linux</a> <a href="/tags/Spring/" style="font-size: 20px;">Spring</a> <a href="/tags/hadoop/" style="font-size: 10px;">hadoop</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/09/">September 2017</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2017/09/08/2017-09-08-Spring源码分析之lazy-init属性的配置/">Spring源码分析之lazy-init属性的配置</a>
          </li>
        
          <li>
            <a href="/2017/09/08/2017-09-08-Spring AOP中declare-parents为特定的类增加新的功能/">Spring AOP中declare-parents为特定的类增加新的功能</a>
          </li>
        
          <li>
            <a href="/2017/09/08/2017-09-08-Spring IOC学习心得之IOC容器的初始化过程/">Spring IOC学习心得之IOC容器的初始化过程</a>
          </li>
        
          <li>
            <a href="/2017/09/08/2017-09-08-Spring IOC学习心得之注册bean的依赖关系/">Spring IOC学习心得之注册bean的依赖关系</a>
          </li>
        
          <li>
            <a href="/2017/09/08/2017-09-08-Spring IOC学习心得之源码级分析ContextLoaderListener的作用(IOC容器初始化入口)/">Spring IOC学习心得之源码级分析ContextLoaderListener的作用(IOC容器初始化入口)</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2018 John Doe<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
    <a href="/about" class="mobile-nav-link">about</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>



  </div>
</body>
</html>