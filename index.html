<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT">










<meta name="description" content="生活不只眼前的苟且，还有诗和远方的田野">
<meta property="og:type" content="website">
<meta property="og:title" content="jasonjie">
<meta property="og:url" content="http://denglinjie.com/index.html">
<meta property="og:site_name" content="jasonjie">
<meta property="og:description" content="生活不只眼前的苟且，还有诗和远方的田野">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="jasonjie">
<meta name="twitter:description" content="生活不只眼前的苟且，还有诗和远方的田野">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://denglinjie.com/">





  <title>jasonjie</title>
  








</head>

<body itemscope="" itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope="" itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">jasonjie</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br>
            
            关于作者
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br>
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://denglinjie.com/2018/12/18/一篇测试/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="jasonjie">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="jasonjie">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/12/18/一篇测试/" itemprop="url">一篇测试</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-12-18T11:22:54+08:00">
                2018-12-18
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://denglinjie.com/2017/09/08/2017-09-12-我是如何解决jobtracker.info could only be replicated to 0 nodes, instead of 1这个问题的/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="jasonjie">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="jasonjie">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/09/08/2017-09-12-我是如何解决jobtracker.info could only be replicated to 0 nodes, instead of 1这个问题的/" itemprop="url">我是如何解决jobtracker.info could only be replicated to 0 nodes, instead of 1这个问题的</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-09-08T00:00:00+08:00">
                2017-09-08
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/Hadoop开发/" itemprop="url" rel="index">
                    <span itemprop="name">Hadoop开发</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>我按照慕课网上的教程来学习搭建hadoop-1.2.1环境，可是在start-all.sh这步的时候一直通不过，命令行报如下错误<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[@soguo /home/denglinjie/hadoop]# start-all.sh   </span><br><span class="line">Warning: $HADOOP_HOME is deprecated.  </span><br><span class="line">  </span><br><span class="line">starting namenode, logging to /home/denglinjie/hadoop-1.2.1/logs/hadoop-denglinjie-namenode-bjzw_30_4.out  </span><br><span class="line">localhost: ssh_exchange_identification: Connection closed by remote host  </span><br><span class="line">localhost: ssh_exchange_identification: Connection closed by remote host  </span><br><span class="line">starting jobtracker, logging to /home/denglinjie/hadoop-1.2.1/logs/hadoop-denglinjie-jobtracker-bjzw_30_4.out  </span><br><span class="line">localhost: ssh_exchange_identification: Connection closed by remote host</span><br></pre></td></tr></table></figure></p>
<p>日志文件报如下错误：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">2017-03-02 19:28:00,951 WARN org.apache.hadoop.hdfs.DFSClient: Error Recovery for null bad datanode[0] nodes == null  </span><br><span class="line">2017-03-02 19:28:00,952 WARN org.apache.hadoop.hdfs.DFSClient: Could not get block locations. Source file &quot;/home/denglinjie/hadoop/tmp/mapred/system/jobtracker.info&quot; - Aborting  </span><br><span class="line">...  </span><br><span class="line">2017-03-02 19:28:00,952 WARN org.apache.hadoop.mapred.JobTracker: Writing to file hdfs://localhost:9063/home/denglinjie/hadoop/tmp/mapred/system/jobtracker.info failed!  </span><br><span class="line">2017-03-02 19:28:00,952 WARN org.apache.hadoop.mapred.JobTracker: FileSystem is not ready yet!  </span><br><span class="line">2017-03-02 19:28:00,954 WARN org.apache.hadoop.mapred.JobTracker: Failed to initialize recovery manager.   </span><br><span class="line">org.apache.hadoop.ipc.RemoteException: java.io.IOException: File /home/denglinjie/hadoop/tmp/mapred/system/jobtracker.info could only be replicated to 0 nodes, instead of 1  </span><br><span class="line">    at org.apache.hadoop.hdfs.server.namenode.FSNamesystem.getAdditionalBlock(FSNamesystem.java:1920)  </span><br><span class="line">    at org.apache.hadoop.hdfs.server.namenode.NameNode.addBlock(NameNode.java:783)  </span><br><span class="line">    at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)  </span><br><span class="line">    at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39)  </span><br><span class="line">    at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25)  </span><br><span class="line">    at java.lang.reflect.Method.invoke(Method.java:597)  </span><br><span class="line">    at org.apache.hadoop.ipc.RPC$Server.call(RPC.java:587)  </span><br><span class="line">    at org.apache.hadoop.ipc.Server$Handler$1.run(Server.java:1432)  </span><br><span class="line">    at org.apache.hadoop.ipc.Server$Handler$1.run(Server.java:1428)  </span><br><span class="line">    at java.security.AccessController.doPrivileged(Native Method)  </span><br><span class="line">    at javax.security.auth.Subject.doAs(Subject.java:396)  </span><br><span class="line">    at org.apache.hadoop.security.UserGroupInformation.doAs(UserGroupInformation.java:1190)  </span><br><span class="line">    at org.apache.hadoop.ipc.Server$Handler.run(Server.java:1426)  </span><br><span class="line">  </span><br><span class="line">    at org.apache.hadoop.ipc.Client.call(Client.java:1113)  </span><br><span class="line">    at org.apache.hadoop.ipc.RPC$Invoker.invoke(RPC.java:229)  </span><br><span class="line">    at com.sun.proxy.$Proxy7.addBlock(Unknown Source)  </span><br><span class="line">    at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)  </span><br><span class="line">    at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39)  </span><br><span class="line">    at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25)  </span><br><span class="line">    at java.lang.reflect.Method.invoke(Method.java:597)  </span><br><span class="line">    at org.apache.hadoop.io.retry.RetryInvocationHandler.invokeMethod(RetryInvocationHandler.java:85)  </span><br><span class="line">    at org.apache.hadoop.io.retry.RetryInvocationHandler.invoke(RetryInvocationHandler.java:62)  </span><br><span class="line">    at com.sun.proxy.$Proxy7.addBlock(Unknown Source)  </span><br><span class="line">    at org.apache.hadoop.hdfs.DFSClient$DFSOutputStream.locateFollowingBlock(DFSClient.java:3720)  </span><br><span class="line">    at org.apache.hadoop.hdfs.DFSClient$DFSOutputStream.nextBlockOutputStream(DFSClient.java:3580)  </span><br><span class="line">    at org.apache.hadoop.hdfs.DFSClient$DFSOutputStream.access$2600(DFSClient.java:2783)  </span><br><span class="line">    at org.apache.hadoop.hdfs.DFSClient$DFSOutputStream$DataStreamer.run(DFSClient.java:3023)</span><br></pre></td></tr></table></figure></p>
<p>首先解决命令行报的错误：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">localhost: ssh_exchange_identification: Connection closed by remote host</span><br></pre></td></tr></table></figure></p>
<p>从google中找问题，发现网上的解决办法千奇百怪，有的说要修改slaves和masters文件中的主机名为ip地址，有的说是因为主机名不能有下划线，但是其实我的主机名用的默认的localhost，总之尝试了网上的各种解决办法，都失败，网上大多数办法都是集中在如下几个配置文件配置的问题上：<br>core-site.xml,  mapred-site.xml,  hdfs-site.xml<br>不过无论我怎么配置都不行，于是一下午都没有找到原因<br>第二天来之后，我想了下也许慕课网那个视频教程是精简版的呢，于是我索性自己从google上搜索了一篇hadoop-1.2.1搭建本地伪分布式安装的教程，按照别人的教程来，文章地址如下：<br><a href="https://hexo2hexo.github.io/hadoop1.2.1%E5%AE%89%E8%A3%85/" target="_blank" rel="noopener">https://hexo2hexo.github.io/hadoop1.2.1%E5%AE%89%E8%A3%85/</a><br>这篇文章中的步骤其实和慕课网的视频教程步骤基本雷同，但是多了如下步骤：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1.生成秘钥  </span><br><span class="line">ssh-keygen -t rsa  </span><br><span class="line">2.一直回车即可,然后进入.ssh目录,执行命令  </span><br><span class="line">cd ~/.ssh  </span><br><span class="line">cp id_rsa.pub authorized_keys  </span><br><span class="line">3.检查是否需要密码  </span><br><span class="line">ssh localhost</span><br></pre></td></tr></table></figure></p>
<p>这很显然是设置免密码登陆啊，于是我按照它的步骤操作了一遍，发现执行到ssh localhost这步的时候，报了如下错误：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh_exchange_identification: Connection closed by remote host</span><br></pre></td></tr></table></figure></p>
<p>我一看，这步跟我启动hadoop的时候报的错误是一样的吗？感情启动hadoop的时候就是在执行ssh  localhost这步呢，于是原因也找到了，<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jobtracker.info could only be replicated to 0 nodes, instead of 1</span><br></pre></td></tr></table></figure></p>
<p>上面这个应该只是ssh执行失败的结果，而不是造成问题的主要原因，既然这样那只要保证ssh  localhost成功登陆本地主机不就OK了吗<br>于是又在网上一通找，</p>
<p>首先开启了/etc/ssh/sshd_config配置文件中的如下几个选项<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">RSAAuthentication yes  </span><br><span class="line">PubkeyAuthentication yes  </span><br><span class="line">AuthorizedKeysFile  .ssh/authorized_key</span><br></pre></td></tr></table></figure></p>
<p>然后重启ssh服务</p>
<h1 id="service-sshd-restart"><a href="#service-sshd-restart" class="headerlink" title="service  sshd   restart"></a>service  sshd   restart</h1><p>发现不好使，还是登陆不上，然后又把/etc/hosts.deny文件中的</p>
<h1 id="sshd-ALL"><a href="#sshd-ALL" class="headerlink" title="sshd  ALL"></a>sshd  ALL</h1><p>这行注释打开，重启sshd服务，再次登陆成功了！<br>于是迫不及待的重新执行<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># stop-all.sh  </span><br><span class="line"># hadoop namenode -format  </span><br><span class="line"># start-all.sh</span><br></pre></td></tr></table></figure></p>
<p>成功了！！！<br>执行jps命令，成功看到了如下输出：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[@sohuo ~/hadoop-1.2.1]$ jps  </span><br><span class="line">30999 Jps  </span><br><span class="line">30510 DataNode  </span><br><span class="line">30651 SecondaryNameNode  </span><br><span class="line">30885 TaskTracker  </span><br><span class="line">30395 NameNode  </span><br><span class="line">30760 JobTracker</span><br></pre></td></tr></table></figure></p>
<p>然后说下日志文件报的错误：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jobtracker.info could only be replicated to 0 nodes, instead of 1</span><br></pre></td></tr></table></figure></p>
<p>这个问题，网上的解决办法也是多种多样，有的说是防火墙没关闭，但是其实我的机器根本没有防火墙。有的说是目录没有删除干净等等。<br>当然最后解决我问题的还是磁盘空间不足的问题。<br>在core-site.xml文件和hdfs-site.xml文件中配置的有namenode和datanode放置的目录，我的机器上，这个目录所在盘已经满了，于是我修改这两个文件配置到了另外一个盘上，问题就解决了。<br>其实一开始，我把hadoop-1.2.1.tar.gz文件解压到我自己的用户家目录下的时候就发现莫名其妙的异常，就是加压后的一些脚本文件内容都是空的，我以为是解压的过程中丢失了，于是我重新解压，才发现日志中说磁盘空间不足。<br>但是我又想在自己用户下工作，怎么办呢？于是我将hadoop-1.2.1.tar.gz文件移动到了一个剩余空间充裕的磁盘目录下，并解压，然后在我自己的家目录下为解压后的hadoop目录创建了软的符号链接，这样就可以了。<br>但是我没有意识到，我在core-site.xml文件和hdfs-site.xml文件中为hadoop指定的namenode和datanode存放的目录还是在我自己的家目录下，而这些目录就不是符号链接了，导致空间不足，所以报了上述错误，终于圆满解决。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://denglinjie.com/2016/09/20/2016-09-20-Spring源码分析之ProxyFactoryBean方式实现Aop功能的分析/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="jasonjie">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="jasonjie">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2016/09/20/2016-09-20-Spring源码分析之ProxyFactoryBean方式实现Aop功能的分析/" itemprop="url">Spring源码分析之ProxyFactoryBean方式实现Aop功能的分析</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2016-09-20T00:00:00+08:00">
                2016-09-20
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/Java开发/" itemprop="url" rel="index">
                    <span itemprop="name">Java开发</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>实现Aop功能有两种方式，</p>
<ol>
<li>ProxyFactoryBean方式： 这种方式是通过配置实现</li>
<li>ProxyFactory方式：这种方式是通过编程实现<br>这里只说ProxyFactoryBean方式<br>首先说下具体的配置，一个例子如下：</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id=&quot;testAdvisor&quot; class=&quot;com.abc.TestAdvisor&quot;</span><br><span class="line">	&lt;property name=&quot;pointcut&quot;  ref=&quot;bookPointcut&quot;/&gt; </span><br><span class="line">        &lt;property name=&quot;advice&quot; ref=&quot;aroundMethod&quot;&gt;&lt;/property&gt;</span><br><span class="line">&lt;/bean&gt;</span><br><span class="line">&lt;bean id=&quot;testAop&quot; class=&quot;org.springframeword.aop.ProxyFactoryBean&quot;&gt;</span><br><span class="line">      &lt;property name=&quot;proxyInterfaces&quot;&gt;</span><br><span class="line">              &lt;value&gt;com.test.AbcInterface&lt;/value&gt;</span><br><span class="line">      &lt;/property&gt;</span><br><span class="line">      &lt;property name=&quot;target&quot;&gt;</span><br><span class="line">              &lt;bean class=&quot;com.abc.TestTarget&quot;/&gt;</span><br><span class="line">      &lt;/property&gt;</span><br><span class="line">      &lt;property name=&quot;interceptorNames&quot;&gt;</span><br><span class="line">              &lt;list&gt;</span><br><span class="line">                        &lt;value&gt;testAdvisor&lt;/value&gt;  </span><br><span class="line">              &lt;/list&gt;</span><br><span class="line">      &lt;/property&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure>
<p>上述配置中，testAdvisor是配置了一个通知器，该通知器配置了pointcut，即执行该通知需要满足的条件，还配置了匹配条件时要执行的方法，target配置的是要被增强的目标对象，interceptorNames配置的是一些通知，用来增强目标对象。proxyInterfaces配置的是需要代理的接口名的字符串数组。如果没有提供，将为目标类使用一个CGLIB代理，即这个接口的配置将会影响是用JDK还是CGLIB来创建目标对象的代理对象。<br>首先看下ProxyFactoryBean的getObject方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">	public Object getObject() throws BeansException &#123;</span><br><span class="line">		initializeAdvisorChain();</span><br><span class="line">		//生成代理对象时,因为Spring中有singleton类型和prototype类型这两种不同的Bean,所以要对代理对象的生成做一个区分</span><br><span class="line">		if (isSingleton()) &#123;</span><br><span class="line">			//生成singleton的代理对象,这个方法是ProxyFactoryBean生成AOPProxy代理对象的调用入口</span><br><span class="line">			//代理对象会封装对target目标对象的调用,也就是说针对target对象的方法调用行为会被这里生成的代理对象所拦截</span><br><span class="line">			return getSingletonInstance();</span><br><span class="line">		&#125;</span><br><span class="line">		else &#123;</span><br><span class="line">			if (this.targetName == null) &#123;</span><br><span class="line">				logger.warn(&quot;Using non-singleton proxies with singleton targets is often undesirable. &quot; +</span><br><span class="line">						&quot;Enable prototype proxies by setting the &apos;targetName&apos; property.&quot;);</span><br><span class="line">			&#125;</span><br><span class="line">			return newPrototypeInstance();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure></p>
<p>这个方法其实就是用来为目标对象生成代理对象的<br>initializeAdvisorChain是初始化通知器链，即从上述配置中读取interceptorNames参数的值就可以拿到所有为目标对象配置的通知器，该方法的代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">	 * Create the advisor (interceptor) chain. Advisors that are sourced</span><br><span class="line">	 * from a BeanFactory will be refreshed each time a new prototype instance</span><br><span class="line">	 * is added. Interceptors added programmatically through the factory API</span><br><span class="line">	 * are unaffected by such changes.</span><br><span class="line">	 * 初始化通知器链,通知器链封装了一系列的拦截器,这些拦截器都需要从配置中读取,然后为代理对象的生成做好准备</span><br><span class="line">	 */</span><br><span class="line">	private synchronized void initializeAdvisorChain() throws AopConfigException, BeansException &#123;</span><br><span class="line">		//这个标志位是用来表示通知器链是否已经初始化,初始化的工作发生在应用第一次通过ProxyFactoryBean去获取代理对象的时候</span><br><span class="line">		if (this.advisorChainInitialized) &#123;</span><br><span class="line">			return;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		if (!ObjectUtils.isEmpty(this.interceptorNames)) &#123;</span><br><span class="line">			if (this.beanFactory == null) &#123;</span><br><span class="line">				throw new IllegalStateException(&quot;No BeanFactory available anymore (probably due to serialization) &quot; +</span><br><span class="line">						&quot;- cannot resolve interceptor names &quot; + Arrays.asList(this.interceptorNames));</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			// Globals can&apos;t be last unless we specified a targetSource using the property...</span><br><span class="line">			if (this.interceptorNames[this.interceptorNames.length - 1].endsWith(GLOBAL_SUFFIX) &amp;&amp;</span><br><span class="line">					this.targetName == null &amp;&amp; this.targetSource == EMPTY_TARGET_SOURCE) &#123;</span><br><span class="line">				throw new AopConfigException(&quot;Target required after globals&quot;);</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			// Materialize interceptor chain from bean names.</span><br><span class="line">			//这里是添加Advisor链的调用,是通过interceptorNames属性进行配置的</span><br><span class="line">			//this.interceptorNames就是配置中配置的所有通知器</span><br><span class="line">			for (String name : this.interceptorNames) &#123;</span><br><span class="line">				if (logger.isTraceEnabled()) &#123;</span><br><span class="line">					logger.trace(&quot;Configuring advisor or advice &apos;&quot; + name + &quot;&apos;&quot;);</span><br><span class="line">				&#125;</span><br><span class="line"></span><br><span class="line">				if (name.endsWith(GLOBAL_SUFFIX)) &#123;</span><br><span class="line">					if (!(this.beanFactory instanceof ListableBeanFactory)) &#123;</span><br><span class="line">						throw new AopConfigException(</span><br><span class="line">								&quot;Can only use global advisors or interceptors with a ListableBeanFactory&quot;);</span><br><span class="line">					&#125;</span><br><span class="line">					addGlobalAdvisor((ListableBeanFactory) this.beanFactory,</span><br><span class="line">							name.substring(0, name.length() - GLOBAL_SUFFIX.length()));</span><br><span class="line">				&#125;</span><br><span class="line"></span><br><span class="line">				else &#123;</span><br><span class="line">					// If we get here, we need to add a named interceptor.</span><br><span class="line">					// We must check if it&apos;s a singleton or prototype.</span><br><span class="line">					//如果程序在这里被调用,那么需要加入命名的拦截器advice,并且需要检查这个Bean是singleton还是prototype</span><br><span class="line">					Object advice;</span><br><span class="line">					if (this.singleton || this.beanFactory.isSingleton(name)) &#123;</span><br><span class="line">						// Add the real Advisor/Advice to the chain.</span><br><span class="line">						//取得advisor的地方,是通过beanFactory取得的,把intercepNames这个List中的interceptor的名字交给BeanFactory,然后通过getBean去获取</span><br><span class="line">						advice = this.beanFactory.getBean(name);</span><br><span class="line">					&#125;</span><br><span class="line">					else &#123;</span><br><span class="line">						// It&apos;s a prototype Advice or Advisor: replace with a prototype.</span><br><span class="line">						// Avoid unnecessary creation of prototype bean just for advisor chain initialization.</span><br><span class="line">						advice = new PrototypePlaceholderAdvisor(name);</span><br><span class="line">					&#125;</span><br><span class="line">					addAdvisorOnChainCreation(advice, name);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		this.advisorChainInitialized = true;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure></p>
<p>其他的getSingletonInstance方法和newPrototypeInstance类其实就是构造代理对象<br>其中getSingletonInstance方法的代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">private synchronized Object getSingletonInstance() &#123;</span><br><span class="line">		if (this.singletonInstance == null) &#123;</span><br><span class="line">			this.targetSource = freshTargetSource();</span><br><span class="line">			if (this.autodetectInterfaces &amp;&amp; getProxiedInterfaces().length == 0 &amp;&amp; !isProxyTargetClass()) &#123;</span><br><span class="line">				// Rely on AOP infrastructure to tell us what interfaces to proxy.</span><br><span class="line">				//根据AOP框架来判断需要代理的接口</span><br><span class="line">				Class&lt;?&gt; targetClass = getTargetClass();</span><br><span class="line">				if (targetClass == null) &#123;</span><br><span class="line">					throw new FactoryBeanNotInitializedException(&quot;Cannot determine target class for proxy&quot;);</span><br><span class="line">				&#125;</span><br><span class="line">				//设置代理对象的接口</span><br><span class="line">				setInterfaces(ClassUtils.getAllInterfacesForClass(targetClass, this.proxyClassLoader));</span><br><span class="line">			&#125;</span><br><span class="line">			// Initialize the shared singleton instance.</span><br><span class="line">			super.setFrozen(this.freezeProxy);</span><br><span class="line">			//createAopProxy()方法可能会返回ObjenesisCglibAopProxy对象,也可能会返回JdkDynamicAopProxy对象</span><br><span class="line">			//然后getProxy方法会根据ObjenesisCglibAopProxy或者JdkDynamicAopProxy对象的getProxy方法来生成最终的代理对象</span><br><span class="line">			//这就是所谓的,Spring生成代理对象的两种方式,一种是CGLIB,一种是JDK</span><br><span class="line">			this.singletonInstance = getProxy(createAopProxy());	//这里的方法会使用ProxyFactory来生成需要的Proxy,通过createAopProxy返回的AopProxy来得到代理对象</span><br><span class="line">		&#125;</span><br><span class="line">		return this.singletonInstance;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure></p>
<p>注意this.singletonInstance = getProxy(createAopProxy());这行代码<br>createAopProxy()方法可能会返回ObjenesisCglibAopProxy对象,也可能会返回JdkDynamicAopProxy对象，这个逻辑是在DefaultAopProxyFactory<br>类中实现的，逻辑如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">public class DefaultAopProxyFactory implements AopProxyFactory, Serializable &#123;</span><br><span class="line"></span><br><span class="line">	//config里面封装了想要生成的代理对象的信息</span><br><span class="line">	@Override</span><br><span class="line">	public AopProxy createAopProxy(AdvisedSupport config) throws AopConfigException &#123;</span><br><span class="line">		if (config.isOptimize() || config.isProxyTargetClass() || hasNoUserSuppliedProxyInterfaces(config)) &#123;</span><br><span class="line">			Class&lt;?&gt; targetClass = config.getTargetClass();	//首先要从AdvisedSupport对象中取得配置的目标对象,如果目标对象为空,则直接抛出异常,因为连目标对象都没有,还为谁创建代理对象</span><br><span class="line">			if (targetClass == null) &#123;</span><br><span class="line">				throw new AopConfigException(&quot;TargetSource cannot determine target class: &quot; +</span><br><span class="line">						&quot;Either an interface or a target is required for proxy creation.&quot;);</span><br><span class="line">			&#125;</span><br><span class="line">			//关于AopProxy代理对象的生成,需要考虑使用哪种生成方式,如果目标对象是接口类,那么适合使用JDK来生成代理对象,否则spring会使用CGLIB来生成目标对象的代理对象</span><br><span class="line">			//对于具体的AopProxy代理对象的生成,最终并不是由DefaultAopProxyFactory来完成,而是分别由JdkDynamicAopProxy和ObjenesisCglibAopProxy完成</span><br><span class="line">			if (targetClass.isInterface() || Proxy.isProxyClass(targetClass)) &#123;</span><br><span class="line">				return new JdkDynamicAopProxy(config);	//使用JDK来生成AOPProxy代理对象</span><br><span class="line">			&#125;</span><br><span class="line">			return new ObjenesisCglibAopProxy(config);	//使用第三方CGLIB来生成AOPProxy代理对象</span><br><span class="line">		&#125;</span><br><span class="line">		else &#123;</span><br><span class="line">			return new JdkDynamicAopProxy(config);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure></p>
<p>可以看到，它会根据目标类是不是接口等信息来判定使用ObjenesisCglibAopProxy还是JdkDynamicAopProxy</p>
<p>然后getProxy方法会根据ObjenesisCglibAopProxy或者JdkDynamicAopProxy对象的getProxy方法来生成最终的代理对象<br>这就是所谓的,Spring生成代理对象的两种方式,一种是CGLIB,一种是JDK<br>下面说说用JdkDynamicAopProxy方式生成的代理对象的拦截方式，它实际用的就是JDK的动态代理<br>我们知道，动态代理拦截的入口是实现了InvocationHandler接口后的invoke方法，即所有对目标方法的调用首先会被invoke方法拦截<br>而JdkDynamicAopProxy方式实现的动态代理的拦截入口也是该类的invoke方法，该类的部分方法如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * JDK-based &#123;@link AopProxy&#125; implementation for the Spring AOP framework</span><br><span class="line"> *InvocationHandler接口的invoke方法就是拦截回调的入口,即对目标方法的调用会先被invoke方法拦截,并在invoke方法里面来调用目标方法</span><br><span class="line"> */</span><br><span class="line">final class JdkDynamicAopProxy implements AopProxy, InvocationHandler, Serializable &#123;</span><br><span class="line"></span><br><span class="line">	public JdkDynamicAopProxy(AdvisedSupport config) throws AopConfigException &#123;</span><br><span class="line">		Assert.notNull(config, &quot;AdvisedSupport must not be null&quot;);</span><br><span class="line">		if (config.getAdvisors().length == 0 &amp;&amp; config.getTargetSource() == AdvisedSupport.EMPTY_TARGET_SOURCE) &#123;</span><br><span class="line">			throw new AopConfigException(&quot;No advisors and no TargetSource specified&quot;);</span><br><span class="line">		&#125;</span><br><span class="line">		this.advised = config;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	@Override</span><br><span class="line">	public Object getProxy() &#123;</span><br><span class="line">		return getProxy(ClassUtils.getDefaultClassLoader());</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	@Override</span><br><span class="line">	public Object getProxy(ClassLoader classLoader) &#123;</span><br><span class="line">		if (logger.isDebugEnabled()) &#123;</span><br><span class="line">			logger.debug(&quot;Creating JDK dynamic proxy: target source is &quot; + this.advised.getTargetSource());</span><br><span class="line">		&#125;</span><br><span class="line">		//首先从advised对象中取得代理对象的代理接口配置</span><br><span class="line">		Class&lt;?&gt;[] proxiedInterfaces = AopProxyUtils.completeProxiedInterfaces(this.advised, true);</span><br><span class="line">		findDefinedEqualsAndHashCodeMethods(proxiedInterfaces);</span><br><span class="line">		//第三个参数需要实现InvocationHandler接口和invoke方法,这个invoke方法是Proxy代理对象的回调方法</span><br><span class="line">		//这种方式其实就是用JDK的动态代理来为目标对象创建代理对象,对目标对象方法的调用就是由这个代理对象来调用的</span><br><span class="line">		return Proxy.newProxyInstance(classLoader, proxiedInterfaces, this);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	/**</span><br><span class="line">	 * Implementation of &#123;@code InvocationHandler.invoke&#125;.</span><br><span class="line">	 * &lt;p&gt;Callers will see exactly the exception thrown by the target,</span><br><span class="line">	 * unless a hook method throws an exception.</span><br><span class="line">	 * 拦截回调入口</span><br><span class="line">	 */</span><br><span class="line">	@Override</span><br><span class="line">	public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123;</span><br><span class="line">		MethodInvocation invocation;</span><br><span class="line">		Object oldProxy = null;</span><br><span class="line">		boolean setProxyContext = false;</span><br><span class="line"></span><br><span class="line">		TargetSource targetSource = this.advised.targetSource;</span><br><span class="line">		Class&lt;?&gt; targetClass = null;</span><br><span class="line">		Object target = null;</span><br><span class="line"></span><br><span class="line">		try &#123;</span><br><span class="line">			//如果目标对象没有实现Object类的基本方法:equals</span><br><span class="line">			if (!this.equalsDefined &amp;&amp; AopUtils.isEqualsMethod(method)) &#123;</span><br><span class="line">				// The target does not implement the equals(Object) method itself.</span><br><span class="line">				return equals(args[0]);</span><br><span class="line">			&#125;</span><br><span class="line">			//如果目标对象没有实现Object类的基本方法:hashcode</span><br><span class="line">			else if (!this.hashCodeDefined &amp;&amp; AopUtils.isHashCodeMethod(method)) &#123;</span><br><span class="line">				// The target does not implement the hashCode() method itself.</span><br><span class="line">				return hashCode();</span><br><span class="line">			&#125;</span><br><span class="line">			else if (method.getDeclaringClass() == DecoratingProxy.class) &#123;</span><br><span class="line">				// There is only getDecoratedClass() declared -&gt; dispatch to proxy config.</span><br><span class="line">				return AopProxyUtils.ultimateTargetClass(this.advised);</span><br><span class="line">			&#125;</span><br><span class="line">			else if (!this.advised.opaque &amp;&amp; method.getDeclaringClass().isInterface() &amp;&amp;</span><br><span class="line">					method.getDeclaringClass().isAssignableFrom(Advised.class)) &#123;</span><br><span class="line">				// Service invocations on ProxyConfig with the proxy config...</span><br><span class="line">				//根据代理对象的配置来调用服务</span><br><span class="line">				return AopUtils.invokeJoinpointUsingReflection(this.advised, method, args);</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			Object retVal;</span><br><span class="line"></span><br><span class="line">			if (this.advised.exposeProxy) &#123;</span><br><span class="line">				// Make invocation available if necessary.</span><br><span class="line">				oldProxy = AopContext.setCurrentProxy(proxy);</span><br><span class="line">				setProxyContext = true;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			// May be null. Get as late as possible to minimize the time we &quot;own&quot; the target,</span><br><span class="line">			// in case it comes from a pool.</span><br><span class="line">			//得到目标对象</span><br><span class="line">			target = targetSource.getTarget();</span><br><span class="line">			if (target != null) &#123;</span><br><span class="line">				targetClass = target.getClass();</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			// Get the interception chain for this method.	获取方法method的拦截器链</span><br><span class="line">			// 拦截器链实际就是由一系列的Advice通知对象组成的</span><br><span class="line">			List&lt;Object&gt; chain = this.advised.getInterceptorsAndDynamicInterceptionAdvice(method, targetClass);</span><br><span class="line"></span><br><span class="line">			// Check whether we have any advice. If we don&apos;t, we can fallback on direct</span><br><span class="line">			// reflective invocation of the target, and avoid creating a MethodInvocation.</span><br><span class="line">			//如果没有定义拦截器链,就直接调用target对象的对应方法</span><br><span class="line">			if (chain.isEmpty()) &#123;</span><br><span class="line">				// We can skip creating a MethodInvocation: just invoke the target directly</span><br><span class="line">				// Note that the final invoker must be an InvokerInterceptor so we know it does</span><br><span class="line">				// nothing but a reflective operation on the target, and no hot swapping or fancy proxying.</span><br><span class="line">				Object[] argsToUse = AopProxyUtils.adaptArgumentsIfNecessary(method, args);	//适配参数</span><br><span class="line">				//调用target对象的对应方法</span><br><span class="line">				retVal = AopUtils.invokeJoinpointUsingReflection(target, method, argsToUse);</span><br><span class="line">			&#125;</span><br><span class="line">			else &#123;</span><br><span class="line">				// We need to create a method invocation...</span><br><span class="line">				//如果有拦截器的设定,那么需要调用拦截器之后才调用目标对象的相应方法,通过构造一个ReflectiveMethodInvocation来实现</span><br><span class="line">				invocation = new ReflectiveMethodInvocation(proxy, target, method, args, targetClass, chain);</span><br><span class="line">				// Proceed to the joinpoint through the interceptor chain.</span><br><span class="line">				//沿着拦截器链继续前进</span><br><span class="line">				retVal = invocation.proceed();</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			// Massage return value if necessary.</span><br><span class="line">			Class&lt;?&gt; returnType = method.getReturnType();</span><br><span class="line">			if (retVal != null &amp;&amp; retVal == target &amp;&amp; returnType.isInstance(proxy) &amp;&amp;</span><br><span class="line">					!RawTargetAccess.class.isAssignableFrom(method.getDeclaringClass())) &#123;</span><br><span class="line">				// Special case: it returned &quot;this&quot; and the return type of the method</span><br><span class="line">				// is type-compatible. Note that we can&apos;t help if the target sets</span><br><span class="line">				// a reference to itself in another returned object.</span><br><span class="line">				retVal = proxy;</span><br><span class="line">			&#125;</span><br><span class="line">			else if (retVal == null &amp;&amp; returnType != Void.TYPE &amp;&amp; returnType.isPrimitive()) &#123;</span><br><span class="line">				throw new AopInvocationException(</span><br><span class="line">						&quot;Null return value from advice does not match primitive return type for: &quot; + method);</span><br><span class="line">			&#125;</span><br><span class="line">			return retVal;</span><br><span class="line">		&#125;</span><br><span class="line">		finally &#123;</span><br><span class="line">			if (target != null &amp;&amp; !targetSource.isStatic()) &#123;</span><br><span class="line">				// Must have come from TargetSource.</span><br><span class="line">				targetSource.releaseTarget(target);</span><br><span class="line">			&#125;</span><br><span class="line">			if (setProxyContext) &#123;</span><br><span class="line">				// Restore old proxy.</span><br><span class="line">				AopContext.setCurrentProxy(oldProxy);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>上述getProxy方法其实就是JdkDynamicAopProxy用来给目标对象生成代码对象的方法<br>而invoke就是对目标方法调用时的拦截入口<br>其中的<br>List<object> chain = this.advised.getInterceptorsAndDynamicInterceptionAdvice(method, targetClass);<br>这行代码就是获取到目标对象所有的拦截器，为什么这里是获取拦截器？其实在上面初始化通知器链的时候拿到的都是配置的通知器，这个方法是要将这些通知器用对应的适配器<br>适配成对应的拦截器，至于为什么要做这个步骤，在我的另外一篇博客中说的很清楚了，地址如下：<br><a href="http://blog.csdn.net/u011734144/article/details/73436539" target="_blank" rel="noopener">http://blog.csdn.net/u011734144/article/details/73436539</a><br>这里转换成拦截器后，也并不是直接就要将该拦截器加入最终要执行的拦截器链中，还需要判断对应的通知是否应该执行，对应的代码片段如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">//对配置的advisor通知器进行逐个遍历,这个通知器链都是配置在interceptorNames中的</span><br><span class="line">		for (Advisor advisor : config.getAdvisors()) &#123;</span><br><span class="line">			if (advisor instanceof PointcutAdvisor) &#123;</span><br><span class="line">				// Add it conditionally.</span><br><span class="line">				PointcutAdvisor pointcutAdvisor = (PointcutAdvisor) advisor;</span><br><span class="line">				if (config.isPreFiltered() || pointcutAdvisor.getPointcut().getClassFilter().matches(actualClass)) &#123;</span><br><span class="line">					//registry.getInterceptors(advisor)是对从ProxyFactoryBean配置中得到的通知进行适配,从而得到相应的拦截器,再把它加入到前面设置好的list中去</span><br><span class="line">					//从而完成所谓的拦截器注册过程</span><br><span class="line">					MethodInterceptor[] interceptors = registry.getInterceptors(advisor);</span><br><span class="line">					MethodMatcher mm = pointcutAdvisor.getPointcut().getMethodMatcher();</span><br><span class="line">					if (MethodMatchers.matches(mm, method, actualClass, hasIntroductions)) &#123;</span><br><span class="line">						if (mm.isRuntime()) &#123;</span><br><span class="line">							// Creating a new object instance in the getInterceptors() method</span><br><span class="line">							// isn&apos;t a problem as we normally cache created chains.</span><br><span class="line">							for (MethodInterceptor interceptor : interceptors) &#123;</span><br><span class="line">								interceptorList.add(new InterceptorAndDynamicMethodMatcher(interceptor, mm));</span><br><span class="line">							&#125;</span><br><span class="line">						&#125;</span><br><span class="line">						else &#123;</span><br><span class="line">							interceptorList.addAll(Arrays.asList(interceptors));</span><br><span class="line">						&#125;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			else if (advisor instanceof IntroductionAdvisor) &#123;</span><br><span class="line">				IntroductionAdvisor ia = (IntroductionAdvisor) advisor;</span><br><span class="line">				if (config.isPreFiltered() || ia.getClassFilter().matches(actualClass)) &#123;</span><br><span class="line">					Interceptor[] interceptors = registry.getInterceptors(advisor);</span><br><span class="line">					interceptorList.addAll(Arrays.asList(interceptors));</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			else &#123;</span><br><span class="line">				Interceptor[] interceptors = registry.getInterceptors(advisor);</span><br><span class="line">				interceptorList.addAll(Arrays.asList(interceptors));</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br></pre></td></tr></table></figure></object></p>
<p>这里需要判断通知器中配置的切入点是否匹配当前要被调用的方法，即MethodMatchers.matches是否为true，只有匹配的通知才会将对应的拦截器加入到最终待执行的拦截器链中<br>接下来invoke方法中比较核心的就是如下代码：<br>retVal = invocation.proceed();<br>这个方法其实就是启动拦截器链的执行，依次执行每一个拦截器链，在每一个拦截器里面都会根据通知的类型来决定是先执行通知的方法还是先继续执行下一个拦截器，<br>拦截器中具体的执行逻辑也请参考我上面说的我的另外一篇文章</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://denglinjie.com/2016/09/20/2016-09-20-Spring源码分析之SpringMVC的DispatcherServlet是如何处理Http请求的/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="jasonjie">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="jasonjie">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2016/09/20/2016-09-20-Spring源码分析之SpringMVC的DispatcherServlet是如何处理Http请求的/" itemprop="url">Spring源码分析之SpringMVC的DispatcherServlet是如何处理Http请求的</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2016-09-20T00:00:00+08:00">
                2016-09-20
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/Java开发/" itemprop="url" rel="index">
                    <span itemprop="name">Java开发</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>一般我们会在web.xml文件中配置DispatcherServlet，比如如下配置方式：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;servlet&gt;  </span><br><span class="line">        &lt;servlet-name&gt;dispatcherServlet&lt;/servlet-name&gt;  </span><br><span class="line">        &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt;  </span><br><span class="line">        &lt;init-param&gt;  </span><br><span class="line">            &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;  </span><br><span class="line">            &lt;param-value&gt;classpath:dispatcher-servlet.xml&lt;/param-value&gt;  </span><br><span class="line">        &lt;/init-param&gt;  </span><br><span class="line">        &lt;load-on-startup&gt;1&lt;/load-on-startup&gt;  </span><br><span class="line">    &lt;/servlet&gt;  </span><br><span class="line">      </span><br><span class="line">    &lt;servlet-mapping&gt;  </span><br><span class="line">        &lt;servlet-name&gt;dispatcherServlet&lt;/servlet-name&gt;  </span><br><span class="line">        &lt;url-pattern&gt;/&lt;/url-pattern&gt;  </span><br><span class="line">    &lt;/servlet-mapping&gt;</span><br></pre></td></tr></table></figure></p>
<p>上述代码配置了所有路径的http请求都会交给DispatcherServlet来处理<br>那么我们来看下DispatcherServlet的具体代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">@SuppressWarnings(&quot;serial&quot;)  </span><br><span class="line">public class DispatcherServlet extends FrameworkServlet &#123;  </span><br><span class="line">    public DispatcherServlet(WebApplicationContext webApplicationContext) &#123;  </span><br><span class="line">        super(webApplicationContext);  </span><br><span class="line">        setDispatchOptionsRequest(true);  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    @Override  </span><br><span class="line">    protected void onRefresh(ApplicationContext context) &#123;  </span><br><span class="line">        initStrategies(context);  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    /**  </span><br><span class="line">     * Initialize the strategy objects that this servlet uses.  </span><br><span class="line">     * &lt;p&gt;May be overridden in subclasses in order to initialize further strategy objects.  </span><br><span class="line">     */  </span><br><span class="line">    protected void initStrategies(ApplicationContext context) &#123;  </span><br><span class="line">        initMultipartResolver(context);  </span><br><span class="line">        initLocaleResolver(context);  </span><br><span class="line">        initThemeResolver(context);  </span><br><span class="line">        initHandlerMappings(context);  </span><br><span class="line">        initHandlerAdapters(context);  </span><br><span class="line">        initHandlerExceptionResolvers(context);  </span><br><span class="line">        initRequestToViewNameTranslator(context);  </span><br><span class="line">        initViewResolvers(context);  </span><br><span class="line">        initFlashMapManager(context);  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">    @Override  </span><br><span class="line">    protected void doService(HttpServletRequest request, HttpServletResponse response) throws Exception &#123;  </span><br><span class="line">          </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">    protected void doDispatch(HttpServletRequest request, HttpServletResponse response) throws Exception &#123;  </span><br><span class="line">          </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>可以看到这个类继承了FrameworkServlet类，再来看下这个类的代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line">@SuppressWarnings(&quot;serial&quot;)  </span><br><span class="line">public abstract class FrameworkServlet extends HttpServletBean implements ApplicationContextAware &#123;  </span><br><span class="line">  </span><br><span class="line">    @Override  </span><br><span class="line">    protected final void initServletBean() throws ServletException &#123;  </span><br><span class="line">          </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    protected WebApplicationContext initWebApplicationContext() &#123;  </span><br><span class="line">  </span><br><span class="line">        if (!this.refreshEventReceived) &#123;  </span><br><span class="line">            // Either the context is not a ConfigurableApplicationContext with refresh  </span><br><span class="line">            // support or the context injected at construction time had already been  </span><br><span class="line">            // refreshed -&gt; trigger initial onRefresh manually here.  </span><br><span class="line">            onRefresh(wac);  </span><br><span class="line">        &#125;  </span><br><span class="line">  </span><br><span class="line">          </span><br><span class="line">    &#125;  </span><br><span class="line">    @Override  </span><br><span class="line">    public void destroy() &#123;  </span><br><span class="line">        getServletContext().log(&quot;Destroying Spring FrameworkServlet &apos;&quot; + getServletName() + &quot;&apos;&quot;);  </span><br><span class="line">        // Only call close() on WebApplicationContext if locally managed...  </span><br><span class="line">        if (this.webApplicationContext instanceof ConfigurableApplicationContext &amp;&amp; !this.webApplicationContextInjected) &#123;  </span><br><span class="line">            ((ConfigurableApplicationContext) this.webApplicationContext).close();  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">    /**  </span><br><span class="line">     * Override the parent class implementation in order to intercept PATCH requests.  </span><br><span class="line">     */  </span><br><span class="line">    @Override  </span><br><span class="line">    protected void service(HttpServletRequest request, HttpServletResponse response)  </span><br><span class="line">            throws ServletException, IOException &#123;  </span><br><span class="line">  </span><br><span class="line">        HttpMethod httpMethod = HttpMethod.resolve(request.getMethod());  </span><br><span class="line">        if (HttpMethod.PATCH == httpMethod || httpMethod == null) &#123;  </span><br><span class="line">            processRequest(request, response);  </span><br><span class="line">        &#125;  </span><br><span class="line">        else &#123;  </span><br><span class="line">            super.service(request, response);  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">      </span><br><span class="line">    @Override  </span><br><span class="line">    protected final void doGet(HttpServletRequest request, HttpServletResponse response)  </span><br><span class="line">            throws ServletException, IOException &#123;  </span><br><span class="line">  </span><br><span class="line">        processRequest(request, response);  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">      </span><br><span class="line">    @Override  </span><br><span class="line">    protected final void doPost(HttpServletRequest request, HttpServletResponse response)  </span><br><span class="line">            throws ServletException, IOException &#123;  </span><br><span class="line">  </span><br><span class="line">        processRequest(request, response);  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    protected final void processRequest(HttpServletRequest request, HttpServletResponse response)  </span><br><span class="line">            throws ServletException, IOException &#123;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>可以看到这个类继承了HttpServletBean类，而HttpServletBean类又继承了HttpServlet类，其中HttpServlet类的init，destroy，service三个方法负责管理Servlet的生命周期。<br>init方法：负责初始化Servlet对象<br>destroy方法：负责销毁Servlet对象<br>service方法：负责处理http请求<br>由于HttpServletBean实现了HttpServlet的init方法，可以看到该方法的代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">public final void init() throws ServletException &#123;  </span><br><span class="line">        if (logger.isDebugEnabled()) &#123;  </span><br><span class="line">            logger.debug(&quot;Initializing servlet &apos;&quot; + getServletName() + &quot;&apos;&quot;);  </span><br><span class="line">        &#125;  </span><br><span class="line">  </span><br><span class="line">        // Set bean properties from init parameters.  </span><br><span class="line">        // 获取servlet初始化的参数,对Bean属性进行配置  </span><br><span class="line">        try &#123;  </span><br><span class="line">            PropertyValues pvs = new ServletConfigPropertyValues(getServletConfig(), this.requiredProperties);  </span><br><span class="line">            BeanWrapper bw = PropertyAccessorFactory.forBeanPropertyAccess(this);  </span><br><span class="line">            ResourceLoader resourceLoader = new ServletContextResourceLoader(getServletContext());  </span><br><span class="line">            bw.registerCustomEditor(Resource.class, new ResourceEditor(resourceLoader, getEnvironment()));  </span><br><span class="line">            initBeanWrapper(bw);  </span><br><span class="line">            bw.setPropertyValues(pvs, true);  </span><br><span class="line">        &#125;  </span><br><span class="line">        catch (BeansException ex) &#123;  </span><br><span class="line">            logger.error(&quot;Failed to set bean properties on servlet &apos;&quot; + getServletName() + &quot;&apos;&quot;, ex);  </span><br><span class="line">            throw ex;  </span><br><span class="line">        &#125;  </span><br><span class="line">  </span><br><span class="line">        // Let subclasses do whatever initialization they like.  </span><br><span class="line">        // 调用子类的initServletBean进行具体的初始化  </span><br><span class="line">        initServletBean();  </span><br><span class="line">  </span><br><span class="line">        if (logger.isDebugEnabled()) &#123;  </span><br><span class="line">            logger.debug(&quot;Servlet &apos;&quot; + getServletName() + &quot;&apos; configured successfully&quot;);  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>这里会读取配置在ServletContext中的Bean属性参数，这里可以看到对PropertyValues和BeanWrapper的使用，这里就完成了对Servlet的初始化<br>接着调用了initServletBean方法来初始化DispatcherServlet持有的IOC容器，当然底层其实是调用initWebApplicationContext方法来初始化，其代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">protected WebApplicationContext initWebApplicationContext() &#123;  </span><br><span class="line">        // 得到根上下文,这个根上下文是保存在ServletContext中的,使用这个根上下文作为当前MVC上下文的双亲上下文,当前的上下文就是wac  </span><br><span class="line">        // cwac.setParent(rootContext)就是设置当前上下文的根上下文  </span><br><span class="line">        WebApplicationContext rootContext =  </span><br><span class="line">                WebApplicationContextUtils.getWebApplicationContext(getServletContext());  </span><br><span class="line">        WebApplicationContext wac = null;  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">        if (wac == null) &#123;  </span><br><span class="line">            // No context instance is defined for this servlet -&gt; create a local one  </span><br><span class="line">            wac = createWebApplicationContext(rootContext);  </span><br><span class="line">        &#125;  </span><br><span class="line">  </span><br><span class="line">        if (!this.refreshEventReceived) &#123;  </span><br><span class="line">            // Either the context is not a ConfigurableApplicationContext with refresh  </span><br><span class="line">            // support or the context injected at construction time had already been  </span><br><span class="line">            // refreshed -&gt; trigger initial onRefresh manually here.  </span><br><span class="line">            onRefresh(wac);  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>可以看到createWebApplicationContext方法就是在创建并初始化IOC容器，代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">protected WebApplicationContext createWebApplicationContext(ApplicationContext parent) &#123;  </span><br><span class="line">          </span><br><span class="line">        //设置IOC容器的各个参数  </span><br><span class="line">        wac.setEnvironment(getEnvironment());  </span><br><span class="line">        wac.setParent(parent);  </span><br><span class="line">        wac.setConfigLocation(getContextConfigLocation());  </span><br><span class="line">  </span><br><span class="line">        configureAndRefreshWebApplicationContext(wac);  </span><br><span class="line">  </span><br><span class="line">        return wac;  </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>这里设置了当前IOC容器上下文的双亲上下文，双亲上下文是如下方法获取到的：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">WebApplicationContext rootContext =  </span><br><span class="line">                WebApplicationContextUtils.getWebApplicationContext(getServletContext());</span><br></pre></td></tr></table></figure></p>
<p>这样当从IOC容器中getBean的时候会先从其双亲上下文中获取bean,configureAndRefreshWebApplicationContext方法里面调用了wac.refresh()，也就是refresh方法来真正启动对IOC容器的初始化，这里就跟IOC容器的初始化保持一致了</p>
<p>到这里，对DispatcherServlet所持有的IOC容器的初始化就完成了，初始化完成后，DispatcherServlet就持有一个以自己的Servlet名称命名的IOC容器了，这个IOC容器是一个WebApplicationContext对象。<br>我们还可以看到initWebApplicationContext方法中还调用了onrefresh方法，该方法是由DispatcherServlet来实现的，并最终调用了DispatcherServlet的如下方法来进行初始化：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">protected void initStrategies(ApplicationContext context) &#123;  </span><br><span class="line">        initMultipartResolver(context);  </span><br><span class="line">        initLocaleResolver(context);  </span><br><span class="line">        initThemeResolver(context);  </span><br><span class="line">        initHandlerMappings(context);  </span><br><span class="line">        initHandlerAdapters(context);  </span><br><span class="line">        initHandlerExceptionResolvers(context);  </span><br><span class="line">        initRequestToViewNameTranslator(context);  </span><br><span class="line">        initViewResolvers(context);  </span><br><span class="line">        initFlashMapManager(context);  </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>在这个方法里，DispatcherServlet对MVC模块的其他部分进行了初始化，比如handlerMapping，ViewResolver等，它是启动整个Spring MVC框架的初始化<br>比如，支持国际化的LocalResolver，支持request映射的HandlerMapping，以及视图生成的ViewResolver等的初始化<br>这里的initHandlerMapping是为HTTP请求找到相应的Controller控制器。<br>DispatcherServlet的整个初始化过程就到这里结束了，下面说下DispatcherServlet是如何处理http请求的</p>
<p>首先http请求是由doService来处理的，那么我们可以看下HttpServlet类的该方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">protected void service(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123;  </span><br><span class="line">        String method = req.getMethod();  </span><br><span class="line">        long errMsg;  </span><br><span class="line">        if(method.equals(&quot;GET&quot;)) &#123;  </span><br><span class="line">            errMsg = this.getLastModified(req);  </span><br><span class="line">            if(errMsg == -1L) &#123;  </span><br><span class="line">                this.doGet(req, resp);  </span><br><span class="line">            &#125; else &#123;  </span><br><span class="line">                long ifModifiedSince = req.getDateHeader(&quot;If-Modified-Since&quot;);  </span><br><span class="line">                if(ifModifiedSince &lt; errMsg) &#123;  </span><br><span class="line">                    this.maybeSetLastModified(resp, errMsg);  </span><br><span class="line">                    this.doGet(req, resp);  </span><br><span class="line">                &#125; else &#123;  </span><br><span class="line">                    resp.setStatus(304);  </span><br><span class="line">                &#125;  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125; else if(method.equals(&quot;HEAD&quot;)) &#123;  </span><br><span class="line">            errMsg = this.getLastModified(req);  </span><br><span class="line">            this.maybeSetLastModified(resp, errMsg);  </span><br><span class="line">            this.doHead(req, resp);  </span><br><span class="line">        &#125; else if(method.equals(&quot;POST&quot;)) &#123;  </span><br><span class="line">            this.doPost(req, resp);  </span><br><span class="line">        &#125; else if(method.equals(&quot;PUT&quot;)) &#123;  </span><br><span class="line">            this.doPut(req, resp);  </span><br><span class="line">        &#125; else if(method.equals(&quot;DELETE&quot;)) &#123;  </span><br><span class="line">            this.doDelete(req, resp);  </span><br><span class="line">        &#125; else if(method.equals(&quot;OPTIONS&quot;)) &#123;  </span><br><span class="line">            this.doOptions(req, resp);  </span><br><span class="line">        &#125; else if(method.equals(&quot;TRACE&quot;)) &#123;  </span><br><span class="line">            this.doTrace(req, resp);  </span><br><span class="line">        &#125; else &#123;  </span><br><span class="line">            String errMsg1 = lStrings.getString(&quot;http.method_not_implemented&quot;);  </span><br><span class="line">            Object[] errArgs = new Object[]&#123;method&#125;;  </span><br><span class="line">            errMsg1 = MessageFormat.format(errMsg1, errArgs);  </span><br><span class="line">            resp.sendError(501, errMsg1);  </span><br><span class="line">        &#125;  </span><br><span class="line">  </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>这个方法里面会根据不同的请求类型，来调用不同的处理方法，比如会调用doGet或者doPost方法来分别处理get请求和post请求，跟踪这些方法，可以发现，最终是调用了DispatcherServlet的doService方法，代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">protected void doService(HttpServletRequest request, HttpServletResponse response) throws Exception &#123;  </span><br><span class="line">        try &#123;  </span><br><span class="line">            this.doDispatch(request, response);  </span><br><span class="line">        &#125; finally &#123;  </span><br><span class="line">            if(!WebAsyncUtils.getAsyncManager(request).isConcurrentHandlingStarted() &amp;&amp; attributesSnapshot1 != null) &#123;  </span><br><span class="line">                this.restoreAttributesAfterInclude(request, attributesSnapshot1);  </span><br><span class="line">            &#125;  </span><br><span class="line">  </span><br><span class="line">        &#125;  </span><br><span class="line">  </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>可以看到该方法调用了doDispatch来进行处理，doDispatch是MVC模式的主要部分</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://denglinjie.com/2016/09/18/2016-09-18-Spring源码分析之lazy-init属性的配置/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="jasonjie">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="jasonjie">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2016/09/18/2016-09-18-Spring源码分析之lazy-init属性的配置/" itemprop="url">Spring源码分析之lazy-init属性的配置</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2016-09-18T00:00:00+08:00">
                2016-09-18
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/Java开发/" itemprop="url" rel="index">
                    <span itemprop="name">Java开发</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>AbstractApplicationContext类默认在容器初始化的过程中就会执行依赖注入，即等价于配置lazy-init属性为false，bean的配置如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;</span><br><span class="line">       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span><br><span class="line">       xmlns:context=&quot;http://www.springframework.org/schema/context&quot;</span><br><span class="line">       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans</span><br><span class="line">        http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd&quot;&gt;</span><br><span class="line"></span><br><span class="line">    &lt;bean id=&quot;studentService&quot; class=&quot;com.verify.constant.StudentService&quot; init-method=&quot;initMethod&quot; lazy-init=&quot;false&quot;/&gt;</span><br><span class="line">&lt;/beans&gt;</span><br></pre></td></tr></table></figure></p>
<p>容器的初始化是在AbstractApplicationContext的refresh()方法中执行的，如下代码对lazy-init进行了处理：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">finishBeanFactoryInitialization(beanFactory);</span><br></pre></td></tr></table></figure></p>
<p>跟踪下去可以找到真正的读取lazy-init属性进行懒加载相关处理的地方<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">	public void preInstantiateSingletons() throws BeansException &#123;</span><br><span class="line">		if (this.logger.isDebugEnabled()) &#123;</span><br><span class="line">			this.logger.debug(&quot;Pre-instantiating singletons in &quot; + this);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		// Iterate over a copy to allow for init methods which in turn register new bean definitions.</span><br><span class="line">		// While this may not be part of the regular factory bootstrap, it does otherwise work fine.</span><br><span class="line">		List&lt;String&gt; beanNames = new ArrayList&lt;String&gt;(this.beanDefinitionNames);</span><br><span class="line"></span><br><span class="line">		// Trigger initialization of all non-lazy singleton beans...</span><br><span class="line">		for (String beanName : beanNames) &#123;</span><br><span class="line">			RootBeanDefinition bd = getMergedLocalBeanDefinition(beanName);</span><br><span class="line">			if (!bd.isAbstract() &amp;&amp; bd.isSingleton() &amp;&amp; !bd.isLazyInit()) &#123;</span><br><span class="line">				if (isFactoryBean(beanName)) &#123;</span><br><span class="line">					final FactoryBean&lt;?&gt; factory = (FactoryBean&lt;?&gt;) getBean(FACTORY_BEAN_PREFIX + beanName);</span><br><span class="line">					boolean isEagerInit;</span><br><span class="line">					if (System.getSecurityManager() != null &amp;&amp; factory instanceof SmartFactoryBean) &#123;</span><br><span class="line">						isEagerInit = AccessController.doPrivileged(new PrivilegedAction&lt;Boolean&gt;() &#123;</span><br><span class="line">							@Override</span><br><span class="line">							public Boolean run() &#123;</span><br><span class="line">								return ((SmartFactoryBean&lt;?&gt;) factory).isEagerInit();</span><br><span class="line">							&#125;</span><br><span class="line">						&#125;, getAccessControlContext());</span><br><span class="line">					&#125;</span><br><span class="line">					else &#123;</span><br><span class="line">						isEagerInit = (factory instanceof SmartFactoryBean &amp;&amp;</span><br><span class="line">								((SmartFactoryBean&lt;?&gt;) factory).isEagerInit());</span><br><span class="line">					&#125;</span><br><span class="line">					if (isEagerInit) &#123;</span><br><span class="line">						getBean(beanName);</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">				else &#123;</span><br><span class="line">					getBean(beanName);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		// Trigger post-initialization callback for all applicable beans...</span><br><span class="line">		for (String beanName : beanNames) &#123;</span><br><span class="line">			Object singletonInstance = getSingleton(beanName);</span><br><span class="line">			if (singletonInstance instanceof SmartInitializingSingleton) &#123;</span><br><span class="line">				final SmartInitializingSingleton smartSingleton = (SmartInitializingSingleton) singletonInstance;</span><br><span class="line">				if (System.getSecurityManager() != null) &#123;</span><br><span class="line">					AccessController.doPrivileged(new PrivilegedAction&lt;Object&gt;() &#123;</span><br><span class="line">						@Override</span><br><span class="line">						public Object run() &#123;</span><br><span class="line">							smartSingleton.afterSingletonsInstantiated();</span><br><span class="line">							return null;</span><br><span class="line">						&#125;</span><br><span class="line">					&#125;, getAccessControlContext());</span><br><span class="line">				&#125;</span><br><span class="line">				else &#123;</span><br><span class="line">					smartSingleton.afterSingletonsInstantiated();</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure></p>
<p>可以看到代码中对所有注册的bean，即this.beanDefinitionNames，对于每个bean都会做如下判断，如果成立就会执行依赖注入：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">if (!bd.isAbstract() &amp;&amp; bd.isSingleton() &amp;&amp; !bd.isLazyInit())</span><br></pre></td></tr></table></figure></p>
<p>可以看出，只有单例的bean才有可能在容器初始化的时候就完成依赖注入，当lazy-init属性不配置(默认值)或者配置为false的时候，上述if就会成立，当然这里默认不配置abstract属性，所以它默认也是false。if成立，就会执行getBean从而进行依赖注入，这样在容器初始化的过程中就已经实例化了Bean，当真正的请求bean的时候，其实只是从缓存中读取而已。<br>而如果lazy-init属性配置为true，那么就会进行懒加载了，这样在容器初始化的过程中不会进行依赖注入，只有当第一个getBean的时候才会实例化Bean。<br>最后抛出一个我还没有搞明白的问题：<br>书上说的是容器在初始化的过程中默认情况下其实并没有发生依赖注入，而是在第一次getBean的时候才会进行依赖注入，但是这个说法与上述AbstractApplicationContext的容器初始化过程好像是不一致的？还是说AbstractApplicationContext默认是进行依赖注入，但是BeanFactory默认不进行依赖注入？</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://denglinjie.com/2016/09/17/2016-09-17-Spring源码分析之BeanPostProcessor接口和BeanFactoryPostProcessor接口方法不执行原因分析/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="jasonjie">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="jasonjie">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2016/09/17/2016-09-17-Spring源码分析之BeanPostProcessor接口和BeanFactoryPostProcessor接口方法不执行原因分析/" itemprop="url">Spring源码分析之BeanPostProcessor接口和BeanFactoryPostProcessor接口方法不执行原因分析</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2016-09-17T00:00:00+08:00">
                2016-09-17
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/Java开发/" itemprop="url" rel="index">
                    <span itemprop="name">Java开发</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>首先下面是我的Bean<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line"> * Copyright 2002-2017 the original author or authors.</span><br><span class="line"> *</span><br><span class="line"> * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);</span><br><span class="line"> * you may not use this file except in compliance with the License.</span><br><span class="line"> * You may obtain a copy of the License at</span><br><span class="line"> *</span><br><span class="line"> *      http://www.apache.org/licenses/LICENSE-2.0</span><br><span class="line"> *</span><br><span class="line"> * Unless required by applicable law or agreed to in writing, software</span><br><span class="line"> * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,</span><br><span class="line"> * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.</span><br><span class="line"> * See the License for the specific language governing permissions and</span><br><span class="line"> * limitations under the License.</span><br><span class="line"> */</span><br><span class="line">package com.verify.constant;</span><br><span class="line"></span><br><span class="line">import org.springframework.beans.BeansException;</span><br><span class="line">import org.springframework.beans.PropertyValues;</span><br><span class="line">import org.springframework.beans.factory.*;</span><br><span class="line">import org.springframework.beans.factory.config.BeanFactoryPostProcessor;</span><br><span class="line">import org.springframework.beans.factory.config.BeanPostProcessor;</span><br><span class="line">import org.springframework.beans.factory.config.ConfigurableListableBeanFactory;</span><br><span class="line">import org.springframework.beans.factory.config.InstantiationAwareBeanPostProcessor;</span><br><span class="line"></span><br><span class="line">import java.beans.PropertyDescriptor;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * TODO</span><br><span class="line"> *</span><br><span class="line"> * @author linjiedeng</span><br><span class="line"> * @date 17/5/8 下午10:47</span><br><span class="line"> * @since TODO</span><br><span class="line"> */</span><br><span class="line">public class StudentService implements BeanPostProcessor, InitializingBean, BeanFactoryPostProcessor, BeanNameAware, BeanClassLoaderAware, BeanFactoryAware &#123;</span><br><span class="line"></span><br><span class="line">    private ClassLoader classLoader;</span><br><span class="line"></span><br><span class="line">    private BeanFactory beanFactory;</span><br><span class="line"></span><br><span class="line">    private String name;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void setBeanClassLoader(ClassLoader classLoader) &#123;</span><br><span class="line">        this.classLoader = classLoader; //实现BeanClassLoaderAware接口可以获取到对应的classLoader</span><br><span class="line">        System.out.println(&quot;set bean class loader&quot;);</span><br><span class="line">        System.out.println(classLoader);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void setBeanFactory(BeanFactory beanFactory) throws BeansException &#123;</span><br><span class="line">        this.beanFactory = beanFactory; //实现BeanFactoryAware接口获取该Bean的beanFactory</span><br><span class="line">        System.out.println(&quot;set bean factory&quot;);</span><br><span class="line">        System.out.println(beanFactory);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void setBeanName(String name) &#123;</span><br><span class="line">        this.name = name;   //实现BeanNameAware接口获取该Bean的名字</span><br><span class="line">        System.out.println(&quot;set bean name&quot;);</span><br><span class="line">        System.out.println(name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void initMethod() &#123;</span><br><span class="line">        System.out.println(&quot;init method&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void afterPropertiesSet() throws Exception &#123;</span><br><span class="line">        System.out.println(&quot;afterPropertiesSet&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public Object postProcessBeforeInitialization(Object bean, String beanName) throws BeansException &#123;</span><br><span class="line">        System.out.println(&quot;postProcessBeforeInitialization&quot;);</span><br><span class="line">        return bean;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public Object postProcessAfterInitialization(Object bean, String beanName) throws BeansException &#123;</span><br><span class="line">        System.out.println(&quot;postProcessAfterInitialization&quot;);</span><br><span class="line">        return bean;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void postProcessBeanFactory(ConfigurableListableBeanFactory beanFactory) throws BeansException &#123;</span><br><span class="line">        System.out.println(&quot;postProcessBeanFactory&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void read() &#123;</span><br><span class="line">        System.out.println(&quot;Student service read&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>bean的配置文件applicationContext.xml内容如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;</span><br><span class="line">       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span><br><span class="line">       xmlns:context=&quot;http://www.springframework.org/schema/context&quot;</span><br><span class="line">       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans</span><br><span class="line">        http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd&quot;&gt;</span><br><span class="line"></span><br><span class="line">    &lt;bean id=&quot;studentService&quot; class=&quot;com.verify.constant.StudentService&quot; init-method=&quot;initMethod&quot;/&gt;</span><br><span class="line">&lt;/beans&gt;</span><br></pre></td></tr></table></figure></p>
<p>测试代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">@Test</span><br><span class="line">    public void test2() &#123;</span><br><span class="line">        ClassPathResource resource = new ClassPathResource(&quot;applicationContext.xml&quot;);</span><br><span class="line">        DefaultListableBeanFactory factory = new DefaultListableBeanFactory();</span><br><span class="line">        XmlBeanDefinitionReader reader = new XmlBeanDefinitionReader(factory);</span><br><span class="line">        reader.loadBeanDefinitions(resource);</span><br><span class="line">        StudentService studentService = (StudentService)factory.getBean(&quot;studentService&quot;);</span><br><span class="line">        studentService.read();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>测试代码执行后，其他方法都执行了，但是唯独BeanPostProcessor接口的两个方法postProcessBeforeInitialization和postProcessAfterInitialization以及<br>BeanFactoryPostProcessor接口的方法没有执行，这我就有点疑惑了，这是咋回事？其实这两个接口应该是在bean初始化的过程中被调用，是在AbstractAutowireCapableBeanFactory接口的initializeBean初始化方法中被调用的，代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">protected Object initializeBean(final String beanName, final Object bean, RootBeanDefinition mbd) &#123;</span><br><span class="line">		if (System.getSecurityManager() != null) &#123;</span><br><span class="line">			AccessController.doPrivileged(new PrivilegedAction&lt;Object&gt;() &#123;</span><br><span class="line">				@Override</span><br><span class="line">				public Object run() &#123;</span><br><span class="line">					invokeAwareMethods(beanName, bean);</span><br><span class="line">					return null;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;, getAccessControlContext());</span><br><span class="line">		&#125;</span><br><span class="line">		else &#123;</span><br><span class="line">			invokeAwareMethods(beanName, bean);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		Object wrappedBean = bean;</span><br><span class="line">		if (mbd == null || !mbd.isSynthetic()) &#123;</span><br><span class="line">			//执行BeanPostProcessor扩展点的PostProcessBeforeInitialization进行修改实例化Bean</span><br><span class="line">			wrappedBean = applyBeanPostProcessorsBeforeInitialization(wrappedBean, beanName);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		try &#123;</span><br><span class="line">			//调用Bean的初始化方法,这个初始化方法是在BeanDefinition中通过定义init-method属性指定的</span><br><span class="line">			//同时,如果Bean实现了InitializingBean接口,那么这个Bean的afterPropertiesSet实现也不会被调用</span><br><span class="line">			invokeInitMethods(beanName, wrappedBean, mbd);</span><br><span class="line">		&#125;</span><br><span class="line">		catch (Throwable ex) &#123;</span><br><span class="line">			throw new BeanCreationException(</span><br><span class="line">					(mbd != null ? mbd.getResourceDescription() : null),</span><br><span class="line">					beanName, &quot;Invocation of init method failed&quot;, ex);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		if (mbd == null || !mbd.isSynthetic()) &#123;</span><br><span class="line">			//执行BeanPostProcessor扩展点的PostProcessAfterInitialization进行修改实例化Bean</span><br><span class="line">			wrappedBean = applyBeanPostProcessorsAfterInitialization(wrappedBean, beanName);</span><br><span class="line">		&#125;</span><br><span class="line">		return wrappedBean;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure></p>
<p>initializeBean方法是Bean的初始化方法，在该初始化方法中会调用Bean的一些初始化方法，比如如下方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">private void invokeAwareMethods(final String beanName, final Object bean) &#123;</span><br><span class="line">		if (bean instanceof Aware) &#123;</span><br><span class="line">			if (bean instanceof BeanNameAware) &#123;</span><br><span class="line">				((BeanNameAware) bean).setBeanName(beanName);</span><br><span class="line">			&#125;</span><br><span class="line">			if (bean instanceof BeanClassLoaderAware) &#123;</span><br><span class="line">				((BeanClassLoaderAware) bean).setBeanClassLoader(getBeanClassLoader());</span><br><span class="line">			&#125;</span><br><span class="line">			if (bean instanceof BeanFactoryAware) &#123;</span><br><span class="line">				((BeanFactoryAware) bean).setBeanFactory(AbstractAutowireCapableBeanFactory.this);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure></p>
<p>即只要Bean实现了BeanNameAware接口，这里就会帮你调用，BeanClassLoaderAware和BeanFactory接口同样如此，上述我的代码中就实现了这三个接口，启动的过程中都被调用了，再实现的方法中可以获取这些信息，并存储。<br>再比如如下方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public Object applyBeanPostProcessorsBeforeInitialization(Object existingBean, String beanName)</span><br><span class="line">			throws BeansException &#123;</span><br><span class="line"></span><br><span class="line">		Object result = existingBean;</span><br><span class="line">		for (BeanPostProcessor beanProcessor : getBeanPostProcessors()) &#123;</span><br><span class="line">			result = beanProcessor.postProcessBeforeInitialization(result, beanName);</span><br><span class="line">			if (result == null) &#123;</span><br><span class="line">				return result;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		return result;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure></p>
<p>这里其实是如果Bean实现了BeanPostProcessor接口，这里就会调用bean实现的postProcessBeforeInitialization方法，这是在bean的真正初始化之前被调用<br>对应的BeanPostProcessor接口的另外一个方法，是在bean的初始化之后被调用，如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public Object applyBeanPostProcessorsAfterInitialization(Object existingBean, String beanName)</span><br><span class="line">			throws BeansException &#123;</span><br><span class="line"></span><br><span class="line">		Object result = existingBean;</span><br><span class="line">		for (BeanPostProcessor beanProcessor : getBeanPostProcessors()) &#123;</span><br><span class="line">			result = beanProcessor.postProcessAfterInitialization(result, beanName);</span><br><span class="line">			if (result == null) &#123;</span><br><span class="line">				return result;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		return result;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure></p>
<p>真正的初始化是在如下方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">protected void invokeInitMethods(String beanName, final Object bean, RootBeanDefinition mbd)</span><br><span class="line">			throws Throwable &#123;</span><br><span class="line"></span><br><span class="line">		boolean isInitializingBean = (bean instanceof InitializingBean);</span><br><span class="line">		if (isInitializingBean &amp;&amp; (mbd == null || !mbd.isExternallyManagedInitMethod(&quot;afterPropertiesSet&quot;))) &#123;</span><br><span class="line">			if (logger.isDebugEnabled()) &#123;</span><br><span class="line">				logger.debug(&quot;Invoking afterPropertiesSet() on bean with name &apos;&quot; + beanName + &quot;&apos;&quot;);</span><br><span class="line">			&#125;</span><br><span class="line">			if (System.getSecurityManager() != null) &#123;</span><br><span class="line">				try &#123;</span><br><span class="line">					AccessController.doPrivileged(new PrivilegedExceptionAction&lt;Object&gt;() &#123;</span><br><span class="line">						@Override</span><br><span class="line">						public Object run() throws Exception &#123;</span><br><span class="line">							((InitializingBean) bean).afterPropertiesSet();</span><br><span class="line">							return null;</span><br><span class="line">						&#125;</span><br><span class="line">					&#125;, getAccessControlContext());</span><br><span class="line">				&#125;</span><br><span class="line">				catch (PrivilegedActionException pae) &#123;</span><br><span class="line">					throw pae.getException();</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			else &#123;</span><br><span class="line">				((InitializingBean) bean).afterPropertiesSet();	//启动afterPropertiesSet,afterPropertiesSet是InitializingBean接口的方法</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		if (mbd != null) &#123;</span><br><span class="line">			String initMethodName = mbd.getInitMethodName();	//获取用户自定义的初始化方法</span><br><span class="line">			if (initMethodName != null &amp;&amp; !(isInitializingBean &amp;&amp; &quot;afterPropertiesSet&quot;.equals(initMethodName)) &amp;&amp;</span><br><span class="line">					!mbd.isExternallyManagedInitMethod(initMethodName)) &#123;</span><br><span class="line">				invokeCustomInitMethod(beanName, bean, mbd);	//调用自定义的初始化方法</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure></p>
<p>可以看到，上述代码实际上是在调用Bean实现的initializingBean接口的afterPropertiesSet方法来初始化Bean，接下来还调用了用户自定义的init-method方法，可以看到上面我的applicationContext.xml配置文件中配置的有一个initMethod方法，这就是自定义的初始化方法，这个方法也是在这里被调用的</p>
<p>好，代码分析到这，也可以看到了，既然这里初始化的时候调用了BeanPostProcessor的那两个方法，但是我的测试代码为什么没有执行这两个方法呢？<br>其实可以看到真正执行BeanPostProcessor接口的代码是如下代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public Object applyBeanPostProcessorsBeforeInitialization(Object existingBean, String beanName)</span><br><span class="line">			throws BeansException &#123;</span><br><span class="line"></span><br><span class="line">		Object result = existingBean;</span><br><span class="line">		for (BeanPostProcessor beanProcessor : getBeanPostProcessors()) &#123;</span><br><span class="line">			result = beanProcessor.postProcessBeforeInitialization(result, beanName);</span><br><span class="line">			if (result == null) &#123;</span><br><span class="line">				return result;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		return result;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure></p>
<p>其中的getBeanPostProcessors()方法获取的实际就是AbstractBeanFactory的this.beanPostProcessors属性值，看来是这个属性值为空，所以执行的时候没有调用<br>那接下来要分析的原因就是为什么this.beanPostProcessors属性值为空呢？或者说bean的载入时为什么没有载入进来呢？那就要看它是在哪里载入的了，最终定位到载入是在<br>AbstractApplicationContext中执行的<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">	public void refresh() throws BeansException, IllegalStateException &#123;</span><br><span class="line">		synchronized (this.startupShutdownMonitor) &#123;</span><br><span class="line">			// Prepare this context for refreshing.</span><br><span class="line">			prepareRefresh();</span><br><span class="line"></span><br><span class="line">			//这是在子类中启动refreshBeanFactory的地方</span><br><span class="line">			// Tell the subclass to refresh the internal bean factory.</span><br><span class="line">			ConfigurableListableBeanFactory beanFactory = obtainFreshBeanFactory();</span><br><span class="line"></span><br><span class="line">			// Prepare the bean factory for use in this context.</span><br><span class="line">			prepareBeanFactory(beanFactory);</span><br><span class="line"></span><br><span class="line">			try &#123;</span><br><span class="line">				// Allows post-processing of the bean factory in context subclasses.</span><br><span class="line">				// 设置BeanFactory的后置处理</span><br><span class="line">				postProcessBeanFactory(beanFactory);</span><br><span class="line"></span><br><span class="line">				// Invoke factory processors registered as beans in the context.</span><br><span class="line">				// 调用BeanFactory的后处理器,这些后处理器是在Bean定义中向容器注册的</span><br><span class="line">				invokeBeanFactoryPostProcessors(beanFactory);</span><br><span class="line"></span><br><span class="line">				// Register bean processors that intercept bean creation.</span><br><span class="line">				// 注册Bean的后处理器,在Bean创建过程中调用</span><br><span class="line">				registerBeanPostProcessors(beanFactory);</span><br><span class="line"></span><br><span class="line">				// Initialize message source for this context.</span><br><span class="line">				// 对上下文中的消息源进行初始化</span><br><span class="line">				initMessageSource();</span><br><span class="line"></span><br><span class="line">				// Initialize event multicaster for this context.</span><br><span class="line">				// 初始化上下文中的事件机制</span><br><span class="line">				initApplicationEventMulticaster();</span><br><span class="line"></span><br><span class="line">				// Initialize other special beans in specific context subclasses.</span><br><span class="line">				// 初始化其他的特殊Bean</span><br><span class="line">				onRefresh();</span><br><span class="line"></span><br><span class="line">				// Check for listener beans and register them.</span><br><span class="line">				// 检查监听Bean,并且将这些Bean向容器注册</span><br><span class="line">				registerListeners();</span><br><span class="line"></span><br><span class="line">				// Instantiate all remaining (non-lazy-init) singletons.这里是对lazy-init属性进行处理的地方</span><br><span class="line">				finishBeanFactoryInitialization(beanFactory);</span><br><span class="line"></span><br><span class="line">				// Last step: publish corresponding event.</span><br><span class="line">				// 发布容器事件,结束Refresh过程</span><br><span class="line">				finishRefresh();</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			catch (BeansException ex) &#123;</span><br><span class="line">				if (logger.isWarnEnabled()) &#123;</span><br><span class="line">					logger.warn(&quot;Exception encountered during context initialization - &quot; +</span><br><span class="line">							&quot;cancelling refresh attempt: &quot; + ex);</span><br><span class="line">				&#125;</span><br><span class="line"></span><br><span class="line">				// Destroy already created singletons to avoid dangling resources.</span><br><span class="line">				// 为防止Bean资环占用,在异常处理中,销毁已经在前面过程中生成的单件Bean</span><br><span class="line">				destroyBeans();</span><br><span class="line"></span><br><span class="line">				// Reset &apos;active&apos; flag.</span><br><span class="line">				cancelRefresh(ex);</span><br><span class="line"></span><br><span class="line">				// Propagate exception to caller.</span><br><span class="line">				throw ex;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			finally &#123;</span><br><span class="line">				// Reset common introspection caches in Spring&apos;s core, since we</span><br><span class="line">				// might not ever need metadata for singleton beans anymore...</span><br><span class="line">				resetCommonCaches();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure></p>
<p>registerBeanPostProcessors(beanFactory)是载入Bean实现的BeanPostProcessor接口，具体载入代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line">public static void registerBeanPostProcessors(</span><br><span class="line">			ConfigurableListableBeanFactory beanFactory, AbstractApplicationContext applicationContext) &#123;</span><br><span class="line"></span><br><span class="line">		String[] postProcessorNames = beanFactory.getBeanNamesForType(BeanPostProcessor.class, true, false);</span><br><span class="line"></span><br><span class="line">		// Register BeanPostProcessorChecker that logs an info message when</span><br><span class="line">		// a bean is created during BeanPostProcessor instantiation, i.e. when</span><br><span class="line">		// a bean is not eligible for getting processed by all BeanPostProcessors.</span><br><span class="line">		int beanProcessorTargetCount = beanFactory.getBeanPostProcessorCount() + 1 + postProcessorNames.length;</span><br><span class="line">		beanFactory.addBeanPostProcessor(new BeanPostProcessorChecker(beanFactory, beanProcessorTargetCount));</span><br><span class="line"></span><br><span class="line">		// Separate between BeanPostProcessors that implement PriorityOrdered,</span><br><span class="line">		// Ordered, and the rest.</span><br><span class="line">		List&lt;BeanPostProcessor&gt; priorityOrderedPostProcessors = new ArrayList&lt;&gt;();</span><br><span class="line">		List&lt;BeanPostProcessor&gt; internalPostProcessors = new ArrayList&lt;&gt;();</span><br><span class="line">		List&lt;String&gt; orderedPostProcessorNames = new ArrayList&lt;&gt;();</span><br><span class="line">		List&lt;String&gt; nonOrderedPostProcessorNames = new ArrayList&lt;&gt;();</span><br><span class="line">		for (String ppName : postProcessorNames) &#123;</span><br><span class="line">			if (beanFactory.isTypeMatch(ppName, PriorityOrdered.class)) &#123;</span><br><span class="line">				BeanPostProcessor pp = beanFactory.getBean(ppName, BeanPostProcessor.class);</span><br><span class="line">				priorityOrderedPostProcessors.add(pp);</span><br><span class="line">				if (pp instanceof MergedBeanDefinitionPostProcessor) &#123;</span><br><span class="line">					internalPostProcessors.add(pp);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			else if (beanFactory.isTypeMatch(ppName, Ordered.class)) &#123;</span><br><span class="line">				orderedPostProcessorNames.add(ppName);</span><br><span class="line">			&#125;</span><br><span class="line">			else &#123;</span><br><span class="line">				nonOrderedPostProcessorNames.add(ppName);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		// First, register the BeanPostProcessors that implement PriorityOrdered.</span><br><span class="line">		sortPostProcessors(beanFactory, priorityOrderedPostProcessors);</span><br><span class="line">		registerBeanPostProcessors(beanFactory, priorityOrderedPostProcessors);</span><br><span class="line"></span><br><span class="line">		// Next, register the BeanPostProcessors that implement Ordered.</span><br><span class="line">		List&lt;BeanPostProcessor&gt; orderedPostProcessors = new ArrayList&lt;&gt;();</span><br><span class="line">		for (String ppName : orderedPostProcessorNames) &#123;</span><br><span class="line">			BeanPostProcessor pp = beanFactory.getBean(ppName, BeanPostProcessor.class);</span><br><span class="line">			orderedPostProcessors.add(pp);</span><br><span class="line">			if (pp instanceof MergedBeanDefinitionPostProcessor) &#123;</span><br><span class="line">				internalPostProcessors.add(pp);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		sortPostProcessors(beanFactory, orderedPostProcessors);</span><br><span class="line">		registerBeanPostProcessors(beanFactory, orderedPostProcessors);</span><br><span class="line"></span><br><span class="line">		// Now, register all regular BeanPostProcessors.</span><br><span class="line">		List&lt;BeanPostProcessor&gt; nonOrderedPostProcessors = new ArrayList&lt;&gt;();</span><br><span class="line">		for (String ppName : nonOrderedPostProcessorNames) &#123;</span><br><span class="line">			BeanPostProcessor pp = beanFactory.getBean(ppName, BeanPostProcessor.class);</span><br><span class="line">			nonOrderedPostProcessors.add(pp);</span><br><span class="line">			if (pp instanceof MergedBeanDefinitionPostProcessor) &#123;</span><br><span class="line">				internalPostProcessors.add(pp);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		registerBeanPostProcessors(beanFactory, nonOrderedPostProcessors);</span><br><span class="line"></span><br><span class="line">		// Finally, re-register all internal BeanPostProcessors.</span><br><span class="line">		sortPostProcessors(beanFactory, internalPostProcessors);</span><br><span class="line">		registerBeanPostProcessors(beanFactory, internalPostProcessors);</span><br><span class="line"></span><br><span class="line">		beanFactory.addBeanPostProcessor(new ApplicationListenerDetector(applicationContext));</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure></p>
<p>invokeBeanFactoryPostProcessors(beanFactory)是载入Bean实现的BeanFactoryPostProcessor接口，具体载入如下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br></pre></td><td class="code"><pre><span class="line">public static void invokeBeanFactoryPostProcessors(</span><br><span class="line">			ConfigurableListableBeanFactory beanFactory, List&lt;BeanFactoryPostProcessor&gt; beanFactoryPostProcessors) &#123;</span><br><span class="line"></span><br><span class="line">		// Invoke BeanDefinitionRegistryPostProcessors first, if any.</span><br><span class="line">		Set&lt;String&gt; processedBeans = new HashSet&lt;&gt;();</span><br><span class="line"></span><br><span class="line">		if (beanFactory instanceof BeanDefinitionRegistry) &#123;</span><br><span class="line">			BeanDefinitionRegistry registry = (BeanDefinitionRegistry) beanFactory;</span><br><span class="line">			List&lt;BeanFactoryPostProcessor&gt; regularPostProcessors = new LinkedList&lt;&gt;();</span><br><span class="line">			List&lt;BeanDefinitionRegistryPostProcessor&gt; registryPostProcessors =</span><br><span class="line">					new LinkedList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">			for (BeanFactoryPostProcessor postProcessor : beanFactoryPostProcessors) &#123;</span><br><span class="line">				if (postProcessor instanceof BeanDefinitionRegistryPostProcessor) &#123;</span><br><span class="line">					BeanDefinitionRegistryPostProcessor registryPostProcessor =</span><br><span class="line">							(BeanDefinitionRegistryPostProcessor) postProcessor;</span><br><span class="line">					registryPostProcessor.postProcessBeanDefinitionRegistry(registry);</span><br><span class="line">					registryPostProcessors.add(registryPostProcessor);</span><br><span class="line">				&#125;</span><br><span class="line">				else &#123;</span><br><span class="line">					regularPostProcessors.add(postProcessor);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			// Do not initialize FactoryBeans here: We need to leave all regular beans</span><br><span class="line">			// uninitialized to let the bean factory post-processors apply to them!</span><br><span class="line">			// Separate between BeanDefinitionRegistryPostProcessors that implement</span><br><span class="line">			// PriorityOrdered, Ordered, and the rest.</span><br><span class="line">			String[] postProcessorNames =</span><br><span class="line">					beanFactory.getBeanNamesForType(BeanDefinitionRegistryPostProcessor.class, true, false);</span><br><span class="line"></span><br><span class="line">			// First, invoke the BeanDefinitionRegistryPostProcessors that implement PriorityOrdered.</span><br><span class="line">			List&lt;BeanDefinitionRegistryPostProcessor&gt; priorityOrderedPostProcessors = new ArrayList&lt;&gt;();</span><br><span class="line">			for (String ppName : postProcessorNames) &#123;</span><br><span class="line">				if (beanFactory.isTypeMatch(ppName, PriorityOrdered.class)) &#123;</span><br><span class="line">					priorityOrderedPostProcessors.add(beanFactory.getBean(ppName, BeanDefinitionRegistryPostProcessor.class));</span><br><span class="line">					processedBeans.add(ppName);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			sortPostProcessors(beanFactory, priorityOrderedPostProcessors);</span><br><span class="line">			registryPostProcessors.addAll(priorityOrderedPostProcessors);</span><br><span class="line">			invokeBeanDefinitionRegistryPostProcessors(priorityOrderedPostProcessors, registry);</span><br><span class="line"></span><br><span class="line">			// Next, invoke the BeanDefinitionRegistryPostProcessors that implement Ordered.</span><br><span class="line">			postProcessorNames = beanFactory.getBeanNamesForType(BeanDefinitionRegistryPostProcessor.class, true, false);</span><br><span class="line">			List&lt;BeanDefinitionRegistryPostProcessor&gt; orderedPostProcessors = new ArrayList&lt;&gt;();</span><br><span class="line">			for (String ppName : postProcessorNames) &#123;</span><br><span class="line">				if (!processedBeans.contains(ppName) &amp;&amp; beanFactory.isTypeMatch(ppName, Ordered.class)) &#123;</span><br><span class="line">					orderedPostProcessors.add(beanFactory.getBean(ppName, BeanDefinitionRegistryPostProcessor.class));</span><br><span class="line">					processedBeans.add(ppName);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			sortPostProcessors(beanFactory, orderedPostProcessors);</span><br><span class="line">			registryPostProcessors.addAll(orderedPostProcessors);</span><br><span class="line">			invokeBeanDefinitionRegistryPostProcessors(orderedPostProcessors, registry);</span><br><span class="line"></span><br><span class="line">			// Finally, invoke all other BeanDefinitionRegistryPostProcessors until no further ones appear.</span><br><span class="line">			boolean reiterate = true;</span><br><span class="line">			while (reiterate) &#123;</span><br><span class="line">				reiterate = false;</span><br><span class="line">				postProcessorNames = beanFactory.getBeanNamesForType(BeanDefinitionRegistryPostProcessor.class, true, false);</span><br><span class="line">				for (String ppName : postProcessorNames) &#123;</span><br><span class="line">					if (!processedBeans.contains(ppName)) &#123;</span><br><span class="line">						BeanDefinitionRegistryPostProcessor pp = beanFactory.getBean(ppName, BeanDefinitionRegistryPostProcessor.class);</span><br><span class="line">						registryPostProcessors.add(pp);</span><br><span class="line">						processedBeans.add(ppName);</span><br><span class="line">						pp.postProcessBeanDefinitionRegistry(registry);</span><br><span class="line">						reiterate = true;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			// Now, invoke the postProcessBeanFactory callback of all processors handled so far.</span><br><span class="line">			invokeBeanFactoryPostProcessors(registryPostProcessors, beanFactory);</span><br><span class="line">			invokeBeanFactoryPostProcessors(regularPostProcessors, beanFactory);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		else &#123;</span><br><span class="line">			// Invoke factory processors registered with the context instance.</span><br><span class="line">			invokeBeanFactoryPostProcessors(beanFactoryPostProcessors, beanFactory);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		// Do not initialize FactoryBeans here: We need to leave all regular beans</span><br><span class="line">		// uninitialized to let the bean factory post-processors apply to them!</span><br><span class="line">		String[] postProcessorNames =</span><br><span class="line">				beanFactory.getBeanNamesForType(BeanFactoryPostProcessor.class, true, false);</span><br><span class="line"></span><br><span class="line">		// Separate between BeanFactoryPostProcessors that implement PriorityOrdered,</span><br><span class="line">		// Ordered, and the rest.</span><br><span class="line">		List&lt;BeanFactoryPostProcessor&gt; priorityOrderedPostProcessors = new ArrayList&lt;&gt;();</span><br><span class="line">		List&lt;String&gt; orderedPostProcessorNames = new ArrayList&lt;&gt;();</span><br><span class="line">		List&lt;String&gt; nonOrderedPostProcessorNames = new ArrayList&lt;&gt;();</span><br><span class="line">		for (String ppName : postProcessorNames) &#123;</span><br><span class="line">			if (processedBeans.contains(ppName)) &#123;</span><br><span class="line">				// skip - already processed in first phase above</span><br><span class="line">			&#125;</span><br><span class="line">			else if (beanFactory.isTypeMatch(ppName, PriorityOrdered.class)) &#123;</span><br><span class="line">				priorityOrderedPostProcessors.add(beanFactory.getBean(ppName, BeanFactoryPostProcessor.class));</span><br><span class="line">			&#125;</span><br><span class="line">			else if (beanFactory.isTypeMatch(ppName, Ordered.class)) &#123;</span><br><span class="line">				orderedPostProcessorNames.add(ppName);</span><br><span class="line">			&#125;</span><br><span class="line">			else &#123;</span><br><span class="line">				nonOrderedPostProcessorNames.add(ppName);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		// First, invoke the BeanFactoryPostProcessors that implement PriorityOrdered.</span><br><span class="line">		sortPostProcessors(beanFactory, priorityOrderedPostProcessors);</span><br><span class="line">		invokeBeanFactoryPostProcessors(priorityOrderedPostProcessors, beanFactory);</span><br><span class="line"></span><br><span class="line">		// Next, invoke the BeanFactoryPostProcessors that implement Ordered.</span><br><span class="line">		List&lt;BeanFactoryPostProcessor&gt; orderedPostProcessors = new ArrayList&lt;&gt;();</span><br><span class="line">		for (String postProcessorName : orderedPostProcessorNames) &#123;</span><br><span class="line">			orderedPostProcessors.add(beanFactory.getBean(postProcessorName, BeanFactoryPostProcessor.class));</span><br><span class="line">		&#125;</span><br><span class="line">		sortPostProcessors(beanFactory, orderedPostProcessors);</span><br><span class="line">		invokeBeanFactoryPostProcessors(orderedPostProcessors, beanFactory);</span><br><span class="line"></span><br><span class="line">		// Finally, invoke all other BeanFactoryPostProcessors.</span><br><span class="line">		List&lt;BeanFactoryPostProcessor&gt; nonOrderedPostProcessors = new ArrayList&lt;&gt;();</span><br><span class="line">		for (String postProcessorName : nonOrderedPostProcessorNames) &#123;</span><br><span class="line">			nonOrderedPostProcessors.add(beanFactory.getBean(postProcessorName, BeanFactoryPostProcessor.class));</span><br><span class="line">		&#125;</span><br><span class="line">		invokeBeanFactoryPostProcessors(nonOrderedPostProcessors, beanFactory);</span><br><span class="line"></span><br><span class="line">		// Clear cached merged bean definitions since the post-processors might have</span><br><span class="line">		// modified the original metadata, e.g. replacing placeholders in values...</span><br><span class="line">		beanFactory.clearMetadataCache();</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure></p>
<p>所以我们可以看到BeanPostProcessor接口和BeanFactoryPostProcessor接口的载入只在abstractApplicationContext中执行了，而在DefaultListableBeanFactory<br>中没有执行，而我们测试用的工厂就是DefaultListableBeanFactory，所以实际是根本没有载入上面两个接口。<br>接下来我把测试代码换成如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@Test</span><br><span class="line">    public void test3() &#123;</span><br><span class="line">        ApplicationContext applicationContext = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;);</span><br><span class="line">        StudentService studentService = (StudentService)applicationContext.getBean(&quot;studentService&quot;);</span><br><span class="line">        studentService.read();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>然后执行，可以很清楚的看到那两个接口的方法都执行了。<br>原因是：ClassPathXmlApplicationContext是abstractApplicationContext的实现，所以使用这个工厂来管理bean，会载入如上两个接口。<br>总结：<br>其实我们两个测试代码分别使用了DefaultListableBeanFactory和ClassPathXmlApplicationContext作为Bean工厂，ClassPathXmlApplicationContext底层其实<br>也是使用的DefaultListableBeanFactory作为Bean工厂，但是ClassPathXmlApplicationContext在DefaultListableBeanFactory的基础上额外载入了<br>BeanPostProcessor接口和BeanFactoryPostProcessor接口，这个载入是在其父接口AbstractApplicationContext中执行的，这就是为什么test2测试代码不执行这两个接口的方法的原因。<br>此外，对于两个工厂而言，真正的在初始化的过程中调用这些接口的地方都是在底层工厂DefaultListableBeanFactory中,而DefaultListableBeanFactory<br>实际是调用的父接口AbstractAutowireCapableBeanFactory的initializeBean方法来进行初始化，从而调用那些初始化接口的方法</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://denglinjie.com/2016/09/17/2016-09-17-Spring源码分析之doDispatch分发请求逻辑/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="jasonjie">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="jasonjie">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2016/09/17/2016-09-17-Spring源码分析之doDispatch分发请求逻辑/" itemprop="url">Spring源码分析之doDispatch分发请求逻辑</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2016-09-17T00:00:00+08:00">
                2016-09-17
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/Java开发/" itemprop="url" rel="index">
                    <span itemprop="name">Java开发</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>首先，我的另外一篇博客已经讲述了DispatcherServlet的整个初始化过程，地址如下：<br><a href="http://blog.csdn.net/u011734144/article/details/74136168" target="_blank" rel="noopener">http://blog.csdn.net/u011734144/article/details/74136168</a></p>
<p>下面说说DispatcherServlet是如何分发请求的<br>分发请求是由该类的doDispatch方法来完成的，先看下具体代码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line">protected void doDispatch(HttpServletRequest request, HttpServletResponse response) throws Exception &#123;</span><br><span class="line">		HttpServletRequest processedRequest = request;</span><br><span class="line">		HandlerExecutionChain mappedHandler = null;</span><br><span class="line">		boolean multipartRequestParsed = false;</span><br><span class="line"></span><br><span class="line">		WebAsyncManager asyncManager = WebAsyncUtils.getAsyncManager(request);</span><br><span class="line"></span><br><span class="line">		try &#123;</span><br><span class="line">			// 这里为视图准备好一个ModelAndView,这个ModelAndView持有handler处理请求的结果</span><br><span class="line">			ModelAndView mv = null;</span><br><span class="line">			Exception dispatchException = null;</span><br><span class="line"></span><br><span class="line">			try &#123;</span><br><span class="line">				processedRequest = checkMultipart(request);</span><br><span class="line">				multipartRequestParsed = (processedRequest != request);</span><br><span class="line"></span><br><span class="line">				// Determine handler for the current request.</span><br><span class="line">				// 根据请求得到对应的Handler</span><br><span class="line">				mappedHandler = getHandler(processedRequest);</span><br><span class="line">				if (mappedHandler == null || mappedHandler.getHandler() == null) &#123;</span><br><span class="line">					noHandlerFound(processedRequest, response);</span><br><span class="line">					return;</span><br><span class="line">				&#125;</span><br><span class="line"></span><br><span class="line">				// Determine handler adapter for the current request.</span><br><span class="line">				// 这里是实际调用handler的地方,在执行handler之前,用handlerAdapter先先检查一下handler的合法性: 即是不是按spring的要求编写的handler</span><br><span class="line">				// handler处理的结果封装到ModelAndView中,为视图提供展现数据</span><br><span class="line">				HandlerAdapter ha = getHandlerAdapter(mappedHandler.getHandler());</span><br><span class="line"></span><br><span class="line">				// Process last-modified header, if supported by the handler.</span><br><span class="line">				String method = request.getMethod();</span><br><span class="line">				boolean isGet = &quot;GET&quot;.equals(method);</span><br><span class="line">				if (isGet || &quot;HEAD&quot;.equals(method)) &#123;</span><br><span class="line">					long lastModified = ha.getLastModified(request, mappedHandler.getHandler());</span><br><span class="line">					if (logger.isDebugEnabled()) &#123;</span><br><span class="line">						logger.debug(&quot;Last-Modified value for [&quot; + getRequestUri(request) + &quot;] is: &quot; + lastModified);</span><br><span class="line">					&#125;</span><br><span class="line">					if (new ServletWebRequest(request, response).checkNotModified(lastModified) &amp;&amp; isGet) &#123;</span><br><span class="line">						return;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line"></span><br><span class="line">				if (!mappedHandler.applyPreHandle(processedRequest, response)) &#123;</span><br><span class="line">					return;</span><br><span class="line">				&#125;</span><br><span class="line"></span><br><span class="line">				// Actually invoke the handler.</span><br><span class="line">				// 通过调用handlerAdapter的handle方法,实际上触发对Controller的handleRequest方法的调用</span><br><span class="line">				mv = ha.handle(processedRequest, response, mappedHandler.getHandler());</span><br><span class="line"></span><br><span class="line">				if (asyncManager.isConcurrentHandlingStarted()) &#123;</span><br><span class="line">					return;</span><br><span class="line">				&#125;</span><br><span class="line"></span><br><span class="line">				applyDefaultViewName(processedRequest, mv);</span><br><span class="line">				mappedHandler.applyPostHandle(processedRequest, response, mv);</span><br><span class="line">			&#125;</span><br><span class="line">			</span><br><span class="line">			processDispatchResult(processedRequest, response, mappedHandler, mv, dispatchException);</span><br><span class="line">		&#125;</span><br><span class="line">	</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure></p>
<p>首先可以看到，这里为视图准备好一个ModelAndView,这个ModelAndView持有handler处理请求的结果<br>然后如下代码：<br>mappedHandler = getHandler(processedRequest)<br>可以根据请求得到对应的handler，如果获取不到对应的handler，就会调用noHandlerFound方法来进行处理，表示找不到对应的处理器，从而抛出异常<br>在执行handler之前,用handlerAdapter先先检查一下handler的合法性: 即是不是按spring的要求编写的handler，即需要判断这个handler是不是Controller接口的实现<br>这个判断是通过HandlerAdapter来判断的，以SimpleControllerHandlerAdapter的实现为例来了解这个判断是如何起作用的，这个判断是通过support方法来实现，<br>判断当前的handler是不是Controller对象，具体代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">public class SimpleControllerHandlerAdapter implements HandlerAdapter &#123;</span><br><span class="line"></span><br><span class="line">	// 判断将要调用handler是不是controller</span><br><span class="line">	@Override</span><br><span class="line">	public boolean supports(Object handler) &#123;</span><br><span class="line">		return (handler instanceof Controller);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	@Override</span><br><span class="line">	public ModelAndView handle(HttpServletRequest request, HttpServletResponse response, Object handler)</span><br><span class="line">			throws Exception &#123;</span><br><span class="line">		//对http请求响应的处理.生成各种需要的数据,并把这些数据封装到ModelAndView中去</span><br><span class="line">		return ((Controller) handler).handleRequest(request, response);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	@Override</span><br><span class="line">	public long getLastModified(HttpServletRequest request, Object handler) &#123;</span><br><span class="line">		if (handler instanceof LastModified) &#123;</span><br><span class="line">			return ((LastModified) handler).getLastModified(request);</span><br><span class="line">		&#125;</span><br><span class="line">		return -1L;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接下来mappedHandler.applyPreHandle方法，代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">boolean applyPreHandle(HttpServletRequest request, HttpServletResponse response) throws Exception &#123;</span><br><span class="line">		HandlerInterceptor[] interceptors = getInterceptors();</span><br><span class="line">		if (!ObjectUtils.isEmpty(interceptors)) &#123;</span><br><span class="line">			for (int i = 0; i &lt; interceptors.length; i++) &#123;</span><br><span class="line">				HandlerInterceptor interceptor = interceptors[i];</span><br><span class="line">				if (!interceptor.preHandle(request, response, this.handler)) &#123;</span><br><span class="line">					triggerAfterCompletion(request, response, null);</span><br><span class="line">					return false;</span><br><span class="line">				&#125;</span><br><span class="line">				this.interceptorIndex = i;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		return true;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure></p>
<p>这是调用为handler配置的拦截器，从HanlderExecutionChain中取出所有的拦截器Interceptor进行前置处理<br>mv = ha.handle(processedRequest, response, mappedHandler.getHandler()); 是真正调用handler进行处理的地方，实际是触发对Controller的<br>handleRequest方法的调用来进行http请求的处理<br>mappedHandler.applyPostHandle方法与前置处理方法applyPreHandle类似，是handle的拦截器的后置处理，具体代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">void applyPostHandle(HttpServletRequest request, HttpServletResponse response, ModelAndView mv) throws Exception &#123;</span><br><span class="line">		HandlerInterceptor[] interceptors = getInterceptors();</span><br><span class="line">		if (!ObjectUtils.isEmpty(interceptors)) &#123;</span><br><span class="line">			for (int i = interceptors.length - 1; i &gt;= 0; i--) &#123;</span><br><span class="line">				HandlerInterceptor interceptor = interceptors[i];</span><br><span class="line">				interceptor.postHandle(request, response, this.handler, mv);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure></p>
<p>最后的processDispatchResult方法就是使用视图对ModelAndView数据的展现<br>到这里，主流程我们就分析完了。<br>接下来我们看下具体的获取handler的过程，也就是getHandler方法的代码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">protected HandlerExecutionChain getHandler(HttpServletRequest request) throws Exception &#123;</span><br><span class="line">		// 这里是从HandlerMapping中去取handler的调用</span><br><span class="line">		for (HandlerMapping hm : this.handlerMappings) &#123;</span><br><span class="line">			if (logger.isTraceEnabled()) &#123;</span><br><span class="line">				logger.trace(</span><br><span class="line">						&quot;Testing handler map [&quot; + hm + &quot;] in DispatcherServlet with name &apos;&quot; + getServletName() + &quot;&apos;&quot;);</span><br><span class="line">			&#125;</span><br><span class="line">			HandlerExecutionChain handler = hm.getHandler(request);</span><br><span class="line">			if (handler != null) &#123;</span><br><span class="line">				return handler;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		return null;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure></p>
<p>可以看到它其实就是从handlerMappings中获取对应的处理器，也就是遍历当前所持有的所有的HanlderMapping，因为在DispatcherServlet中可能定义了不止一个<br>handlerMapping，在这一系列handlerMapping中只要找到了一个需要的handler，就会停止查找，在找到了handler以后，通过hanler返回的是一个HandlerExecutionChain<br>对象，其中包含了最终的Controller和定义的一个拦截器链，拦截器链是为了对handler其实也就是目标Controller进行增强。这样就会按照上面的步骤，先来调用拦截器链的前置处理方法，然后调用Controller来进行请求处理，然后调用<br>拦截器链的后置处理方法。<br>那么接下来我们想知道的就是handlerMappings中的拦截器链和Controller是何时注册进去的<br>下面我们以HandlerMapping的其中一个实现SimpleUrlHandlerMapping来进行讲解，根据名字，可以看出他是根据Url来进行映射，并注册Handler和Interceptor，从而<br>维护一个反映这种url到handler和Interceptor的映射关系的handlerMap，当需要匹配Http请求的时候就需要查询这个handlerMap中的信息来得到对应的<br>HandlerExecutionChain，而这个对象里面就封装了url对应的handler和Interceptor，这个过程就是在SimpleUrlHandlerMapping的如下方法中完成的：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public void initApplicationContext() throws BeansException &#123;</span><br><span class="line">   super.initApplicationContext();</span><br><span class="line">   registerHandlers(this.urlMap);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">public abstract class ApplicationObjectSupport implements ApplicationContextAware &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	@Override</span><br><span class="line">	public final void setApplicationContext(ApplicationContext context) throws BeansException &#123;</span><br><span class="line">		if (context == null &amp;&amp; !isContextRequired()) &#123;</span><br><span class="line">			// Reset internal context state.</span><br><span class="line">			this.applicationContext = null;</span><br><span class="line">			this.messageSourceAccessor = null;</span><br><span class="line">		&#125;</span><br><span class="line">		else if (this.applicationContext == null) &#123;</span><br><span class="line">			// Initialize with passed-in context.</span><br><span class="line">			if (!requiredContextClass().isInstance(context)) &#123;</span><br><span class="line">				throw new ApplicationContextException(</span><br><span class="line">						&quot;Invalid application context: needs to be of type [&quot; + requiredContextClass().getName() + &quot;]&quot;);</span><br><span class="line">			&#125;</span><br><span class="line">			this.applicationContext = context;</span><br><span class="line">			this.messageSourceAccessor = new MessageSourceAccessor(context);</span><br><span class="line">			initApplicationContext(context);</span><br><span class="line">		&#125;</span><br><span class="line">		else &#123;</span><br><span class="line">			// Ignore reinitialization if same context passed in.</span><br><span class="line">			if (this.applicationContext != context) &#123;</span><br><span class="line">				throw new ApplicationContextException(</span><br><span class="line">						&quot;Cannot reinitialize with different application context: current one is [&quot; +</span><br><span class="line">						this.applicationContext + &quot;], passed-in one is [&quot; + context + &quot;]&quot;);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到这个类实现了ApplicationContextAware接口，我们知道在类进行初始化的时候，系统会自动帮我们调用ApplicationContextAware类的<br>setApplicationContext方法，来让bean获取对IOC容器的感知，这个调用在我的其他文章中也有具体的介绍，这里不做过多的说明。我们可以看到这个方法里面就是调用<br>initApplicationContext的地方，即这里来完成启动对映射关系的注册</p>
<p>接着说上面的初始化方法，其中的registerHandlers方法其实是调用的基类AbstractUrlHandlerMapping的registerHandlers方法来进行的注册，具体代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">protected void registerHandler(String urlPath, Object handler) throws BeansException, IllegalStateException &#123;</span><br><span class="line">		Assert.notNull(urlPath, &quot;URL path must not be null&quot;);</span><br><span class="line">		Assert.notNull(handler, &quot;Handler object must not be null&quot;);</span><br><span class="line">		Object resolvedHandler = handler;</span><br><span class="line"></span><br><span class="line">		// Eagerly resolve handler if referencing singleton via name.</span><br><span class="line">		// 如果直接使用bean名称进行映射,那就直接从容器中获取handler</span><br><span class="line">		if (!this.lazyInitHandlers &amp;&amp; handler instanceof String) &#123;</span><br><span class="line">			String handlerName = (String) handler;</span><br><span class="line">			if (getApplicationContext().isSingleton(handlerName)) &#123;</span><br><span class="line">				resolvedHandler = getApplicationContext().getBean(handlerName);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		Object mappedHandler = this.handlerMap.get(urlPath);</span><br><span class="line">		if (mappedHandler != null) &#123;</span><br><span class="line">			if (mappedHandler != resolvedHandler) &#123;</span><br><span class="line">				throw new IllegalStateException(</span><br><span class="line">						&quot;Cannot map &quot; + getHandlerDescription(handler) + &quot; to URL path [&quot; + urlPath +</span><br><span class="line">						&quot;]: There is already &quot; + getHandlerDescription(mappedHandler) + &quot; mapped.&quot;);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		else &#123;</span><br><span class="line">			// 处理URL是&quot;/&quot;的映射,把这个&quot;/&quot;映射的controller设置到rootHandler中</span><br><span class="line">			if (urlPath.equals(&quot;/&quot;)) &#123;</span><br><span class="line">				if (logger.isInfoEnabled()) &#123;</span><br><span class="line">					logger.info(&quot;Root mapping to &quot; + getHandlerDescription(handler));</span><br><span class="line">				&#125;</span><br><span class="line">				setRootHandler(resolvedHandler);</span><br><span class="line">			&#125;</span><br><span class="line">			// 处理URL是&quot;/*&quot;的映射,把这个&quot;/&quot;映射的controller设置到defaultHandler中</span><br><span class="line">			else if (urlPath.equals(&quot;/*&quot;)) &#123;</span><br><span class="line">				if (logger.isInfoEnabled()) &#123;</span><br><span class="line">					logger.info(&quot;Default mapping to &quot; + getHandlerDescription(handler));</span><br><span class="line">				&#125;</span><br><span class="line">				setDefaultHandler(resolvedHandler);</span><br><span class="line">			&#125;</span><br><span class="line">			// 处理正常的URL映射,设置handlerMap的key和value,分别对应于URL和映射的controller</span><br><span class="line">			else &#123;</span><br><span class="line">				this.handlerMap.put(urlPath, resolvedHandler);</span><br><span class="line">				if (logger.isInfoEnabled()) &#123;</span><br><span class="line">					logger.info(&quot;Mapped URL path [&quot; + urlPath + &quot;] onto &quot; + getHandlerDescription(handler));</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure></p>
<p>在这个处理过程中，如果使用Bean的名称作为映射，那么直接从容器中获取这个Http映射对应的Bean，然后还要对不同的URL配置进行解析处理，比如在Http请求中配置<br>成“/”和通配符“/*”的URL，以及正常的URL请求，完成这个解析处理过程以后，会把URL和handler作为键值对放到上面说到的handlerMap中去，handlerMap其实就是<br>一个hashMap，其中保存了URL请求到Controller的映射关系，这个handlerMap是在AbstractUrlHandlerMapping中定义的</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://denglinjie.com/2016/09/14/2016-09-14-Spring源码分析之Aop中拦截器,适配器,通知之间的关系/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="jasonjie">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="jasonjie">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2016/09/14/2016-09-14-Spring源码分析之Aop中拦截器,适配器,通知之间的关系/" itemprop="url">Spring源码分析之Aop中拦截器,适配器,通知之间的关系</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2016-09-14T00:00:00+08:00">
                2016-09-14
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/Java开发/" itemprop="url" rel="index">
                    <span itemprop="name">Java开发</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>首先举一个例子：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">public class MethodBeforeAdviceInterceptor implements MethodInterceptor, Serializable &#123;  </span><br><span class="line">  </span><br><span class="line">    private MethodBeforeAdvice advice;  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">    /**  </span><br><span class="line">     * Create a new MethodBeforeAdviceInterceptor for the given advice.  </span><br><span class="line">     * @param advice the MethodBeforeAdvice to wrap  </span><br><span class="line">     */  </span><br><span class="line">    public MethodBeforeAdviceInterceptor(MethodBeforeAdvice advice) &#123;  </span><br><span class="line">        Assert.notNull(advice, &quot;Advice must not be null&quot;);  </span><br><span class="line">        this.advice = advice;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    //这个invoke方法是拦截器的回调方法,会在代理对象的方法被调用时触发回调  </span><br><span class="line">    @Override  </span><br><span class="line">    public Object invoke(MethodInvocation mi) throws Throwable &#123;  </span><br><span class="line">        //首先触发advise的before回调  </span><br><span class="line">        this.advice.before(mi.getMethod(), mi.getArguments(), mi.getThis() );  </span><br><span class="line">        //然后才是MethodInvocation的proceed方法调用  </span><br><span class="line">        return mi.proceed();  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>上面是MethodBeforeAdviceInterceptor拦截器的源码，MethodBeforeAdvice是对应的通知，另外还有一个角色类是MethodBeforeAdviceAdapter适配器类，这个适配器的源码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">class MethodBeforeAdviceAdapter implements AdvisorAdapter, Serializable &#123;  </span><br><span class="line">  </span><br><span class="line">    @Override  </span><br><span class="line">    public boolean supportsAdvice(Advice advice) &#123;  </span><br><span class="line">        return (advice instanceof MethodBeforeAdvice);  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    @Override  </span><br><span class="line">    public MethodInterceptor getInterceptor(Advisor advisor) &#123;  </span><br><span class="line">        MethodBeforeAdvice advice = (MethodBeforeAdvice) advisor.getAdvice();  </span><br><span class="line">        return new MethodBeforeAdviceInterceptor(advice);  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>可以看到，它的主要作用是，将通知advisor.getAdvice()转换或者说适配成对应的拦截器，有如下三种适配：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1. MethodBeforeAdviceAdapter将MethodBeforeAdvice适配成MethodBeforeAdviceInterceptor  </span><br><span class="line">2. AfterReturningAdviceAdapter将AfterReturningAdvice适配成AfterReturningAdviceInterceptor  </span><br><span class="line">3.ThrowsAdviceAdapter将ThrowsAdvice适配成ThrowsAdviceInterceptor</span><br></pre></td></tr></table></figure></p>
<p>这样适配的目的是什么呢？<br>还得回到我们最初的MethodBeforeAdviceInterceptor的源码中去看<br>首先我们得知道通知是什么，通知就是在调用目标方法之前或者之后等要被调用的增强的方法，比如这里的MethodBeforeAdvice的before方法需要在调用目标方法之前被调用，AfterReturningAdvice的afterReturning方法需要在目标方法被调用之后调用，这个调用逻辑（调用顺序）就是由通知对应的拦截器来完成的，可以看到MethodBeforeAdviceInterceptor由于是前置通知的适配器，所以它的invoke方法在执行下一个拦截器的时候先调用了通知的before方法，然后进入到了下一个拦截器。<br>也就是说，通知只是定义了增强时将要被调用的方法，而方法具体何时调用需要由通知对应的拦截器来进行管理，而适配器的作用就是根据通知得到其对应的拦截器<br>再可以看看AfterReturningAdviceInterceptor拦截器<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">public class AfterReturningAdviceInterceptor implements MethodInterceptor, AfterAdvice, Serializable &#123;  </span><br><span class="line">  </span><br><span class="line">    private final AfterReturningAdvice advice;  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">    /**  </span><br><span class="line">     * Create a new AfterReturningAdviceInterceptor for the given advice.  </span><br><span class="line">     * @param advice the AfterReturningAdvice to wrap  </span><br><span class="line">     */  </span><br><span class="line">    public AfterReturningAdviceInterceptor(AfterReturningAdvice advice) &#123;  </span><br><span class="line">        Assert.notNull(advice, &quot;Advice must not be null&quot;);  </span><br><span class="line">        this.advice = advice;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    @Override  </span><br><span class="line">    public Object invoke(MethodInvocation mi) throws Throwable &#123;  </span><br><span class="line">        Object retVal = mi.proceed();  </span><br><span class="line">        this.advice.afterReturning(retVal, mi.getMethod(), mi.getArguments(), mi.getThis());  </span><br><span class="line">        return retVal;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这个后置通知拦截器就是在先进入到下一个拦截器后，然后再调用的对应通知AfterReturningAdvice的afterReturning方法<br>所以我们可以看到，这几个拦截器实现的功能其实非常类似于动态代理设计模式里面实现了InvocationHandler接口的那个类，比如如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">public class ProxyHandler implements InvocationHandler &#123;  </span><br><span class="line">  </span><br><span class="line">    private Object target;  </span><br><span class="line">  </span><br><span class="line">    public ProxyHandler(Object target) &#123;  </span><br><span class="line">        this.target = target;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123;  </span><br><span class="line">  </span><br><span class="line">        System.out.println(&quot;call before target&quot;);  </span><br><span class="line">  </span><br><span class="line">        Object proxyObject = method.invoke(target, args);   //这里是要调用目标对象target的目标方法method  </span><br><span class="line">  </span><br><span class="line">        System.out.println(&quot;call after target&quot;);  </span><br><span class="line">  </span><br><span class="line">        return proxyObject;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这里目标target的方法被调用前，会被这个类的invoke方法拦截，method.invoke(target, args) 是调用目标方法，这里可以在其前后做一些增强方法</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://denglinjie.com/2016/09/12/2016-09-12-Spring IOC学习心得之源码级分析ContextLoaderListener的作用(IOC容器初始化入口)/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="jasonjie">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="jasonjie">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2016/09/12/2016-09-12-Spring IOC学习心得之源码级分析ContextLoaderListener的作用(IOC容器初始化入口)/" itemprop="url">Spring IOC学习心得之源码级分析ContextLoaderListener的作用(IOC容器初始化入口)</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2016-09-12T00:00:00+08:00">
                2016-09-12
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/Java开发/" itemprop="url" rel="index">
                    <span itemprop="name">Java开发</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>ContextLoaderListener类是负责初始化IOC容器，即在我们的web项目中，这里就是IOC容器初始化的入口，由这个类启动IOC容器的初始化。<br>它配置在web.xml中，比如如下配置：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;context-param&gt;  </span><br><span class="line">        &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;  </span><br><span class="line">        &lt;param-value&gt;classpath:context/applicationContext.xml&lt;/param-value&gt;  </span><br><span class="line">    &lt;/context-param&gt;  </span><br><span class="line">  </span><br><span class="line">    &lt;!-- Spring监听器 --&gt;  </span><br><span class="line">    &lt;listener&gt;  </span><br><span class="line">        &lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;/listener-class&gt;  </span><br><span class="line">    &lt;/listener&gt;</span><br></pre></td></tr></table></figure></p>
<p>跟踪ContextLoaderListener类，可以看到有一个如下方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">protected void configureAndRefreshWebApplicationContext(ConfigurableWebApplicationContext wac, ServletContext sc) &#123;  </span><br><span class="line">        String configLocationParam;  </span><br><span class="line">        if(ObjectUtils.identityToString(wac).equals(wac.getId())) &#123;  </span><br><span class="line">            configLocationParam = sc.getInitParameter(&quot;contextId&quot;);  </span><br><span class="line">            if(configLocationParam != null) &#123;  </span><br><span class="line">                wac.setId(configLocationParam);  </span><br><span class="line">            &#125; else &#123;  </span><br><span class="line">                wac.setId(ConfigurableWebApplicationContext.APPLICATION_CONTEXT_ID_PREFIX + ObjectUtils.getDisplayString(sc.getContextPath()));  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">  </span><br><span class="line">        wac.setServletContext(sc);  </span><br><span class="line">        configLocationParam = sc.getInitParameter(&quot;contextConfigLocation&quot;); //很显然这里就是读取web.xml中配置的资源文件的路径，也就是上述context-param  </span><br><span class="line">标签配置的参数  </span><br><span class="line">        if(configLocationParam != null) &#123;  </span><br><span class="line">            wac.setConfigLocation(configLocationParam);  </span><br><span class="line">        &#125;  </span><br><span class="line">  </span><br><span class="line">        ConfigurableEnvironment env = wac.getEnvironment();  </span><br><span class="line">        if(env instanceof ConfigurableWebEnvironment) &#123;  </span><br><span class="line">            ((ConfigurableWebEnvironment)env).initPropertySources(sc, (ServletConfig)null);  </span><br><span class="line">        &#125;  </span><br><span class="line">  </span><br><span class="line">        this.customizeContext(sc, wac);  </span><br><span class="line">        wac.refresh();  //有了资源文件后，在这里开启IOC容器的初始化  </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>refresh方法的实现是在AbstractApplicationContext类中，代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">public void refresh() throws BeansException, IllegalStateException &#123;  </span><br><span class="line">        Object var1 = this.startupShutdownMonitor;  </span><br><span class="line">        synchronized(this.startupShutdownMonitor) &#123;  </span><br><span class="line">            this.prepareRefresh();  </span><br><span class="line">            ConfigurableListableBeanFactory beanFactory = this.obtainFreshBeanFactory();  </span><br><span class="line">            this.prepareBeanFactory(beanFactory);  </span><br><span class="line">  </span><br><span class="line">            try &#123;  </span><br><span class="line">                this.postProcessBeanFactory(beanFactory);  </span><br><span class="line">                this.invokeBeanFactoryPostProcessors(beanFactory);  </span><br><span class="line">                this.registerBeanPostProcessors(beanFactory);  </span><br><span class="line">                this.initMessageSource();  </span><br><span class="line">                this.initApplicationEventMulticaster();  </span><br><span class="line">                this.onRefresh();  </span><br><span class="line">                this.registerListeners();  </span><br><span class="line">                this.finishBeanFactoryInitialization(beanFactory);  </span><br><span class="line">                this.finishRefresh();  </span><br><span class="line">            &#125; catch (BeansException var9) &#123;  </span><br><span class="line">                if(this.logger.isWarnEnabled()) &#123;  </span><br><span class="line">                    this.logger.warn(&quot;Exception encountered during context initialization - cancelling refresh attempt: &quot; + var9);  </span><br><span class="line">                &#125;  </span><br><span class="line">  </span><br><span class="line">                this.destroyBeans();  </span><br><span class="line">                this.cancelRefresh(var9);  </span><br><span class="line">                throw var9;  </span><br><span class="line">            &#125; finally &#123;  </span><br><span class="line">                this.resetCommonCaches();  </span><br><span class="line">            &#125;  </span><br><span class="line">  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>上述代码就会进行完整的IOC容器的初始化</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://denglinjie.com/2016/09/12/2016-09-12-Spring IOC学习心得之注册bean的依赖关系/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="jasonjie">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="jasonjie">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2016/09/12/2016-09-12-Spring IOC学习心得之注册bean的依赖关系/" itemprop="url">Spring IOC学习心得之注册bean的依赖关系</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2016-09-12T00:00:00+08:00">
                2016-09-12
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/Java开发/" itemprop="url" rel="index">
                    <span itemprop="name">Java开发</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>registerDependentBean方法的解析（注册bean的依赖关系）<br>源码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">public void registerDependentBean(String beanName, String dependentBeanName) &#123;  </span><br><span class="line">        // A quick check for an existing entry upfront, avoiding synchronization...  </span><br><span class="line">        String canonicalName = canonicalName(beanName);  </span><br><span class="line">        /*  </span><br><span class="line">        dependentBeanMap中存储的是目前已经注册的依赖这个bean的所有bean,这里从这个集合中获取目前所有已经注册的依赖beanName的bean集合,  </span><br><span class="line">        然后看这个集合中是否包含dependentBeanName,即是否已经注册,如果包含则表示已经注册,则直接返回,否则,将bean依赖关系添加到两个map缓存即完成注册  </span><br><span class="line">            */  </span><br><span class="line">        Set&lt;String&gt; dependentBeans = this.dependentBeanMap.get(canonicalName);  </span><br><span class="line">        if (dependentBeans != null &amp;&amp; dependentBeans.contains(dependentBeanName)) &#123;  </span><br><span class="line">            return;  </span><br><span class="line">        &#125;  </span><br><span class="line">  </span><br><span class="line">        // No entry yet -&gt; fully synchronized manipulation of the dependentBeans Set  </span><br><span class="line">        synchronized (this.dependentBeanMap) &#123;  </span><br><span class="line">            dependentBeans = this.dependentBeanMap.get(canonicalName);  </span><br><span class="line">            if (dependentBeans == null) &#123;  </span><br><span class="line">                dependentBeans = new LinkedHashSet&lt;&gt;(8);  </span><br><span class="line">                this.dependentBeanMap.put(canonicalName, dependentBeans);  </span><br><span class="line">            &#125;  </span><br><span class="line">            dependentBeans.add(dependentBeanName);  </span><br><span class="line">        &#125;  </span><br><span class="line">        synchronized (this.dependenciesForBeanMap) &#123;  </span><br><span class="line">            Set&lt;String&gt; dependenciesForBean = this.dependenciesForBeanMap.get(dependentBeanName);  </span><br><span class="line">            if (dependenciesForBean == null) &#123;  </span><br><span class="line">                dependenciesForBean = new LinkedHashSet&lt;&gt;(8);  </span><br><span class="line">                this.dependenciesForBeanMap.put(dependentBeanName, dependenciesForBean);  </span><br><span class="line">            &#125;  </span><br><span class="line">            dependenciesForBean.add(canonicalName);  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>解释下上述代码中用到的两个map缓存集合，如下：<br>private final Map&lt;String, Set<string>&gt; dependentBeanMap = new ConcurrentHashMap&lt;String, Set<string>&gt;(); //指定的bean与目前已经注册的依赖这个指定的bean的所有bean的依赖关系的缓存（我依赖的）<br>private final Map&lt;String, Set<string>&gt; dependenciesForBeanMap = new ConcurrentHashMap&lt;String, Set<string>&gt;(); //指定bean与目前已经注册的创建这个bean所需依赖的所有bean的依赖关系的缓存（依赖我的）<br>知道了这两个集合的意思，再参考上述源码中的注释，就不难理解这段代码的意思了</string></string></string></string></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope="" itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">jasonjie</p>
              <p class="site-description motion-element" itemprop="description">生活不只眼前的苟且，还有诗和远方的田野</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">14</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">2</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">4</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">jasonjie</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Muse</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
