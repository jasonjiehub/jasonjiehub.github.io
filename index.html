<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT">










<meta name="description" content="生活不只眼前的苟且，还有诗和远方的田野">
<meta property="og:type" content="website">
<meta property="og:title" content="jasonjie">
<meta property="og:url" content="http://denglinjie.com/index.html">
<meta property="og:site_name" content="jasonjie">
<meta property="og:description" content="生活不只眼前的苟且，还有诗和远方的田野">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="jasonjie">
<meta name="twitter:description" content="生活不只眼前的苟且，还有诗和远方的田野">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://denglinjie.com/">





  <title>jasonjie</title>
  








</head>

<body itemscope="" itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope="" itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">jasonjie</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br>
            
            关于作者
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://denglinjie.com/2018/12/18/一篇测试/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="jasonjie">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="jasonjie">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/12/18/一篇测试/" itemprop="url">一篇测试</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-12-18T11:22:54+08:00">
                2018-12-18
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://denglinjie.com/2017/09/08/2017-09-12-我是如何解决jobtracker.info could only be replicated to 0 nodes, instead of 1这个问题的/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="jasonjie">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="jasonjie">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/09/08/2017-09-12-我是如何解决jobtracker.info could only be replicated to 0 nodes, instead of 1这个问题的/" itemprop="url">我是如何解决jobtracker.info could only be replicated to 0 nodes, instead of 1这个问题的</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-09-08T00:00:00+08:00">
                2017-09-08
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>我按照慕课网上的教程来学习搭建hadoop-1.2.1环境，可是在start-all.sh这步的时候一直通不过，命令行报如下错误<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[@soguo /home/denglinjie/hadoop]# start-all.sh   </span><br><span class="line">Warning: $HADOOP_HOME is deprecated.  </span><br><span class="line">  </span><br><span class="line">starting namenode, logging to /home/denglinjie/hadoop-1.2.1/logs/hadoop-denglinjie-namenode-bjzw_30_4.out  </span><br><span class="line">localhost: ssh_exchange_identification: Connection closed by remote host  </span><br><span class="line">localhost: ssh_exchange_identification: Connection closed by remote host  </span><br><span class="line">starting jobtracker, logging to /home/denglinjie/hadoop-1.2.1/logs/hadoop-denglinjie-jobtracker-bjzw_30_4.out  </span><br><span class="line">localhost: ssh_exchange_identification: Connection closed by remote host</span><br></pre></td></tr></table></figure></p>
<p>日志文件报如下错误：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">2017-03-02 19:28:00,951 WARN org.apache.hadoop.hdfs.DFSClient: Error Recovery for null bad datanode[0] nodes == null  </span><br><span class="line">2017-03-02 19:28:00,952 WARN org.apache.hadoop.hdfs.DFSClient: Could not get block locations. Source file &quot;/home/denglinjie/hadoop/tmp/mapred/system/jobtracker.info&quot; - Aborting  </span><br><span class="line">...  </span><br><span class="line">2017-03-02 19:28:00,952 WARN org.apache.hadoop.mapred.JobTracker: Writing to file hdfs://localhost:9063/home/denglinjie/hadoop/tmp/mapred/system/jobtracker.info failed!  </span><br><span class="line">2017-03-02 19:28:00,952 WARN org.apache.hadoop.mapred.JobTracker: FileSystem is not ready yet!  </span><br><span class="line">2017-03-02 19:28:00,954 WARN org.apache.hadoop.mapred.JobTracker: Failed to initialize recovery manager.   </span><br><span class="line">org.apache.hadoop.ipc.RemoteException: java.io.IOException: File /home/denglinjie/hadoop/tmp/mapred/system/jobtracker.info could only be replicated to 0 nodes, instead of 1  </span><br><span class="line">    at org.apache.hadoop.hdfs.server.namenode.FSNamesystem.getAdditionalBlock(FSNamesystem.java:1920)  </span><br><span class="line">    at org.apache.hadoop.hdfs.server.namenode.NameNode.addBlock(NameNode.java:783)  </span><br><span class="line">    at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)  </span><br><span class="line">    at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39)  </span><br><span class="line">    at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25)  </span><br><span class="line">    at java.lang.reflect.Method.invoke(Method.java:597)  </span><br><span class="line">    at org.apache.hadoop.ipc.RPC$Server.call(RPC.java:587)  </span><br><span class="line">    at org.apache.hadoop.ipc.Server$Handler$1.run(Server.java:1432)  </span><br><span class="line">    at org.apache.hadoop.ipc.Server$Handler$1.run(Server.java:1428)  </span><br><span class="line">    at java.security.AccessController.doPrivileged(Native Method)  </span><br><span class="line">    at javax.security.auth.Subject.doAs(Subject.java:396)  </span><br><span class="line">    at org.apache.hadoop.security.UserGroupInformation.doAs(UserGroupInformation.java:1190)  </span><br><span class="line">    at org.apache.hadoop.ipc.Server$Handler.run(Server.java:1426)  </span><br><span class="line">  </span><br><span class="line">    at org.apache.hadoop.ipc.Client.call(Client.java:1113)  </span><br><span class="line">    at org.apache.hadoop.ipc.RPC$Invoker.invoke(RPC.java:229)  </span><br><span class="line">    at com.sun.proxy.$Proxy7.addBlock(Unknown Source)  </span><br><span class="line">    at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)  </span><br><span class="line">    at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39)  </span><br><span class="line">    at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25)  </span><br><span class="line">    at java.lang.reflect.Method.invoke(Method.java:597)  </span><br><span class="line">    at org.apache.hadoop.io.retry.RetryInvocationHandler.invokeMethod(RetryInvocationHandler.java:85)  </span><br><span class="line">    at org.apache.hadoop.io.retry.RetryInvocationHandler.invoke(RetryInvocationHandler.java:62)  </span><br><span class="line">    at com.sun.proxy.$Proxy7.addBlock(Unknown Source)  </span><br><span class="line">    at org.apache.hadoop.hdfs.DFSClient$DFSOutputStream.locateFollowingBlock(DFSClient.java:3720)  </span><br><span class="line">    at org.apache.hadoop.hdfs.DFSClient$DFSOutputStream.nextBlockOutputStream(DFSClient.java:3580)  </span><br><span class="line">    at org.apache.hadoop.hdfs.DFSClient$DFSOutputStream.access$2600(DFSClient.java:2783)  </span><br><span class="line">    at org.apache.hadoop.hdfs.DFSClient$DFSOutputStream$DataStreamer.run(DFSClient.java:3023)</span><br></pre></td></tr></table></figure></p>
<p>首先解决命令行报的错误：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">localhost: ssh_exchange_identification: Connection closed by remote host</span><br></pre></td></tr></table></figure></p>
<p>从google中找问题，发现网上的解决办法千奇百怪，有的说要修改slaves和masters文件中的主机名为ip地址，有的说是因为主机名不能有下划线，但是其实我的主机名用的默认的localhost，总之尝试了网上的各种解决办法，都失败，网上大多数办法都是集中在如下几个配置文件配置的问题上：<br>core-site.xml,  mapred-site.xml,  hdfs-site.xml<br>不过无论我怎么配置都不行，于是一下午都没有找到原因<br>第二天来之后，我想了下也许慕课网那个视频教程是精简版的呢，于是我索性自己从google上搜索了一篇hadoop-1.2.1搭建本地伪分布式安装的教程，按照别人的教程来，文章地址如下：<br><a href="https://hexo2hexo.github.io/hadoop1.2.1%E5%AE%89%E8%A3%85/" target="_blank" rel="noopener">https://hexo2hexo.github.io/hadoop1.2.1%E5%AE%89%E8%A3%85/</a><br>这篇文章中的步骤其实和慕课网的视频教程步骤基本雷同，但是多了如下步骤：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1.生成秘钥  </span><br><span class="line">ssh-keygen -t rsa  </span><br><span class="line">2.一直回车即可,然后进入.ssh目录,执行命令  </span><br><span class="line">cd ~/.ssh  </span><br><span class="line">cp id_rsa.pub authorized_keys  </span><br><span class="line">3.检查是否需要密码  </span><br><span class="line">ssh localhost</span><br></pre></td></tr></table></figure></p>
<p>这很显然是设置免密码登陆啊，于是我按照它的步骤操作了一遍，发现执行到ssh localhost这步的时候，报了如下错误：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh_exchange_identification: Connection closed by remote host</span><br></pre></td></tr></table></figure></p>
<p>我一看，这步跟我启动hadoop的时候报的错误是一样的吗？感情启动hadoop的时候就是在执行ssh  localhost这步呢，于是原因也找到了，<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jobtracker.info could only be replicated to 0 nodes, instead of 1</span><br></pre></td></tr></table></figure></p>
<p>上面这个应该只是ssh执行失败的结果，而不是造成问题的主要原因，既然这样那只要保证ssh  localhost成功登陆本地主机不就OK了吗<br>于是又在网上一通找，</p>
<p>首先开启了/etc/ssh/sshd_config配置文件中的如下几个选项<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">RSAAuthentication yes  </span><br><span class="line">PubkeyAuthentication yes  </span><br><span class="line">AuthorizedKeysFile  .ssh/authorized_key</span><br></pre></td></tr></table></figure></p>
<p>然后重启ssh服务</p>
<h1 id="service-sshd-restart"><a href="#service-sshd-restart" class="headerlink" title="service  sshd   restart"></a>service  sshd   restart</h1><p>发现不好使，还是登陆不上，然后又把/etc/hosts.deny文件中的</p>
<h1 id="sshd-ALL"><a href="#sshd-ALL" class="headerlink" title="sshd  ALL"></a>sshd  ALL</h1><p>这行注释打开，重启sshd服务，再次登陆成功了！<br>于是迫不及待的重新执行<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># stop-all.sh  </span><br><span class="line"># hadoop namenode -format  </span><br><span class="line"># start-all.sh</span><br></pre></td></tr></table></figure></p>
<p>成功了！！！<br>执行jps命令，成功看到了如下输出：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[@sohuo ~/hadoop-1.2.1]$ jps  </span><br><span class="line">30999 Jps  </span><br><span class="line">30510 DataNode  </span><br><span class="line">30651 SecondaryNameNode  </span><br><span class="line">30885 TaskTracker  </span><br><span class="line">30395 NameNode  </span><br><span class="line">30760 JobTracker</span><br></pre></td></tr></table></figure></p>
<p>然后说下日志文件报的错误：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jobtracker.info could only be replicated to 0 nodes, instead of 1</span><br></pre></td></tr></table></figure></p>
<p>这个问题，网上的解决办法也是多种多样，有的说是防火墙没关闭，但是其实我的机器根本没有防火墙。有的说是目录没有删除干净等等。<br>当然最后解决我问题的还是磁盘空间不足的问题。<br>在core-site.xml文件和hdfs-site.xml文件中配置的有namenode和datanode放置的目录，我的机器上，这个目录所在盘已经满了，于是我修改这两个文件配置到了另外一个盘上，问题就解决了。<br>其实一开始，我把hadoop-1.2.1.tar.gz文件解压到我自己的用户家目录下的时候就发现莫名其妙的异常，就是加压后的一些脚本文件内容都是空的，我以为是解压的过程中丢失了，于是我重新解压，才发现日志中说磁盘空间不足。<br>但是我又想在自己用户下工作，怎么办呢？于是我将hadoop-1.2.1.tar.gz文件移动到了一个剩余空间充裕的磁盘目录下，并解压，然后在我自己的家目录下为解压后的hadoop目录创建了软的符号链接，这样就可以了。<br>但是我没有意识到，我在core-site.xml文件和hdfs-site.xml文件中为hadoop指定的namenode和datanode存放的目录还是在我自己的家目录下，而这些目录就不是符号链接了，导致空间不足，所以报了上述错误，终于圆满解决。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://denglinjie.com/2017/09/08/2017-09-08-Spring IOC学习心得之IOC容器的初始化过程/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="jasonjie">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="jasonjie">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/09/08/2017-09-08-Spring IOC学习心得之IOC容器的初始化过程/" itemprop="url">Spring IOC学习心得之IOC容器的初始化过程</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-09-08T00:00:00+08:00">
                2017-09-08
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>注：本文大多数内容都是摘自《Spring技术内幕》这本书<br>简单来说，Ioc容器的初始化过程是在refresh（）方法中启动的，包括BeanDefinition的Resource定位，载入和注册三个过程。<br>第一：Resource的定位<br>这个Resource指的是BeanDefinition的资源定位，由ResourceLoader通过统一的Resource接口来完成。文件系统中的Bean定义信息可以使用FileSystemResource来进行抽象，类路径中的Bean定义信息可以使用ClassPathResource来抽象。</p>
<p>第二： BeanDefinition的载入<br>上面已经定位了资源Resource的位置，接下来就是将Bean定义表示成Ioc容器内部的结果，即读取进来封装成BeanDefinition。</p>
<p>第三：向IOc容器注册这些BeanDefinition<br>实际上就是将BeanDefinition注册到Hashmap中去，IOC就是通过这个HashMap来持有这些BeanDefinition数据的</p>
<p>但是请注意，上面三个过程不包含Bean依赖注入的过程，依赖注入一般发生在应用第一次通过getBean向容器索取Bean的时候，但是有一个例外是，可以设置Bean的lazyinit属性，那么这个Bean的依赖注入就再IOC容器初始化时就预先完成了</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://denglinjie.com/2017/09/08/2017-09-08-Spring IOC学习心得之注册bean的依赖关系/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="jasonjie">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="jasonjie">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/09/08/2017-09-08-Spring IOC学习心得之注册bean的依赖关系/" itemprop="url">Spring IOC学习心得之注册bean的依赖关系</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-09-08T00:00:00+08:00">
                2017-09-08
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>registerDependentBean方法的解析（注册bean的依赖关系）<br>源码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">public void registerDependentBean(String beanName, String dependentBeanName) &#123;  </span><br><span class="line">        // A quick check for an existing entry upfront, avoiding synchronization...  </span><br><span class="line">        String canonicalName = canonicalName(beanName);  </span><br><span class="line">        /*  </span><br><span class="line">        dependentBeanMap中存储的是目前已经注册的依赖这个bean的所有bean,这里从这个集合中获取目前所有已经注册的依赖beanName的bean集合,  </span><br><span class="line">        然后看这个集合中是否包含dependentBeanName,即是否已经注册,如果包含则表示已经注册,则直接返回,否则,将bean依赖关系添加到两个map缓存即完成注册  </span><br><span class="line">            */  </span><br><span class="line">        Set&lt;String&gt; dependentBeans = this.dependentBeanMap.get(canonicalName);  </span><br><span class="line">        if (dependentBeans != null &amp;&amp; dependentBeans.contains(dependentBeanName)) &#123;  </span><br><span class="line">            return;  </span><br><span class="line">        &#125;  </span><br><span class="line">  </span><br><span class="line">        // No entry yet -&gt; fully synchronized manipulation of the dependentBeans Set  </span><br><span class="line">        synchronized (this.dependentBeanMap) &#123;  </span><br><span class="line">            dependentBeans = this.dependentBeanMap.get(canonicalName);  </span><br><span class="line">            if (dependentBeans == null) &#123;  </span><br><span class="line">                dependentBeans = new LinkedHashSet&lt;&gt;(8);  </span><br><span class="line">                this.dependentBeanMap.put(canonicalName, dependentBeans);  </span><br><span class="line">            &#125;  </span><br><span class="line">            dependentBeans.add(dependentBeanName);  </span><br><span class="line">        &#125;  </span><br><span class="line">        synchronized (this.dependenciesForBeanMap) &#123;  </span><br><span class="line">            Set&lt;String&gt; dependenciesForBean = this.dependenciesForBeanMap.get(dependentBeanName);  </span><br><span class="line">            if (dependenciesForBean == null) &#123;  </span><br><span class="line">                dependenciesForBean = new LinkedHashSet&lt;&gt;(8);  </span><br><span class="line">                this.dependenciesForBeanMap.put(dependentBeanName, dependenciesForBean);  </span><br><span class="line">            &#125;  </span><br><span class="line">            dependenciesForBean.add(canonicalName);  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>解释下上述代码中用到的两个map缓存集合，如下：<br>private final Map&lt;String, Set<string>&gt; dependentBeanMap = new ConcurrentHashMap&lt;String, Set<string>&gt;(); //指定的bean与目前已经注册的依赖这个指定的bean的所有bean的依赖关系的缓存（我依赖的）<br>private final Map&lt;String, Set<string>&gt; dependenciesForBeanMap = new ConcurrentHashMap&lt;String, Set<string>&gt;(); //指定bean与目前已经注册的创建这个bean所需依赖的所有bean的依赖关系的缓存（依赖我的）<br>知道了这两个集合的意思，再参考上述源码中的注释，就不难理解这段代码的意思了</string></string></string></string></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://denglinjie.com/2017/09/08/2017-09-08-Spring IOC学习心得之源码级分析ContextLoaderListener的作用(IOC容器初始化入口)/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="jasonjie">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="jasonjie">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/09/08/2017-09-08-Spring IOC学习心得之源码级分析ContextLoaderListener的作用(IOC容器初始化入口)/" itemprop="url">Spring IOC学习心得之源码级分析ContextLoaderListener的作用(IOC容器初始化入口)</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-09-08T00:00:00+08:00">
                2017-09-08
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>ContextLoaderListener类是负责初始化IOC容器，即在我们的web项目中，这里就是IOC容器初始化的入口，由这个类启动IOC容器的初始化。<br>它配置在web.xml中，比如如下配置：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;context-param&gt;  </span><br><span class="line">        &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;  </span><br><span class="line">        &lt;param-value&gt;classpath:context/applicationContext.xml&lt;/param-value&gt;  </span><br><span class="line">    &lt;/context-param&gt;  </span><br><span class="line">  </span><br><span class="line">    &lt;!-- Spring监听器 --&gt;  </span><br><span class="line">    &lt;listener&gt;  </span><br><span class="line">        &lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;/listener-class&gt;  </span><br><span class="line">    &lt;/listener&gt;</span><br></pre></td></tr></table></figure></p>
<p>跟踪ContextLoaderListener类，可以看到有一个如下方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">protected void configureAndRefreshWebApplicationContext(ConfigurableWebApplicationContext wac, ServletContext sc) &#123;  </span><br><span class="line">        String configLocationParam;  </span><br><span class="line">        if(ObjectUtils.identityToString(wac).equals(wac.getId())) &#123;  </span><br><span class="line">            configLocationParam = sc.getInitParameter(&quot;contextId&quot;);  </span><br><span class="line">            if(configLocationParam != null) &#123;  </span><br><span class="line">                wac.setId(configLocationParam);  </span><br><span class="line">            &#125; else &#123;  </span><br><span class="line">                wac.setId(ConfigurableWebApplicationContext.APPLICATION_CONTEXT_ID_PREFIX + ObjectUtils.getDisplayString(sc.getContextPath()));  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">  </span><br><span class="line">        wac.setServletContext(sc);  </span><br><span class="line">        configLocationParam = sc.getInitParameter(&quot;contextConfigLocation&quot;); //很显然这里就是读取web.xml中配置的资源文件的路径，也就是上述context-param  </span><br><span class="line">标签配置的参数  </span><br><span class="line">        if(configLocationParam != null) &#123;  </span><br><span class="line">            wac.setConfigLocation(configLocationParam);  </span><br><span class="line">        &#125;  </span><br><span class="line">  </span><br><span class="line">        ConfigurableEnvironment env = wac.getEnvironment();  </span><br><span class="line">        if(env instanceof ConfigurableWebEnvironment) &#123;  </span><br><span class="line">            ((ConfigurableWebEnvironment)env).initPropertySources(sc, (ServletConfig)null);  </span><br><span class="line">        &#125;  </span><br><span class="line">  </span><br><span class="line">        this.customizeContext(sc, wac);  </span><br><span class="line">        wac.refresh();  //有了资源文件后，在这里开启IOC容器的初始化  </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>refresh方法的实现是在AbstractApplicationContext类中，代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">public void refresh() throws BeansException, IllegalStateException &#123;  </span><br><span class="line">        Object var1 = this.startupShutdownMonitor;  </span><br><span class="line">        synchronized(this.startupShutdownMonitor) &#123;  </span><br><span class="line">            this.prepareRefresh();  </span><br><span class="line">            ConfigurableListableBeanFactory beanFactory = this.obtainFreshBeanFactory();  </span><br><span class="line">            this.prepareBeanFactory(beanFactory);  </span><br><span class="line">  </span><br><span class="line">            try &#123;  </span><br><span class="line">                this.postProcessBeanFactory(beanFactory);  </span><br><span class="line">                this.invokeBeanFactoryPostProcessors(beanFactory);  </span><br><span class="line">                this.registerBeanPostProcessors(beanFactory);  </span><br><span class="line">                this.initMessageSource();  </span><br><span class="line">                this.initApplicationEventMulticaster();  </span><br><span class="line">                this.onRefresh();  </span><br><span class="line">                this.registerListeners();  </span><br><span class="line">                this.finishBeanFactoryInitialization(beanFactory);  </span><br><span class="line">                this.finishRefresh();  </span><br><span class="line">            &#125; catch (BeansException var9) &#123;  </span><br><span class="line">                if(this.logger.isWarnEnabled()) &#123;  </span><br><span class="line">                    this.logger.warn(&quot;Exception encountered during context initialization - cancelling refresh attempt: &quot; + var9);  </span><br><span class="line">                &#125;  </span><br><span class="line">  </span><br><span class="line">                this.destroyBeans();  </span><br><span class="line">                this.cancelRefresh(var9);  </span><br><span class="line">                throw var9;  </span><br><span class="line">            &#125; finally &#123;  </span><br><span class="line">                this.resetCommonCaches();  </span><br><span class="line">            &#125;  </span><br><span class="line">  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>上述代码就会进行完整的IOC容器的初始化</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://denglinjie.com/2017/09/08/2017-09-08-Spring源码分析之Aop中拦截器,适配器,通知之间的关系/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="jasonjie">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="jasonjie">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/09/08/2017-09-08-Spring源码分析之Aop中拦截器,适配器,通知之间的关系/" itemprop="url">Spring源码分析之Aop中拦截器,适配器,通知之间的关系</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-09-08T00:00:00+08:00">
                2017-09-08
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>首先举一个例子：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">public class MethodBeforeAdviceInterceptor implements MethodInterceptor, Serializable &#123;  </span><br><span class="line">  </span><br><span class="line">    private MethodBeforeAdvice advice;  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">    /**  </span><br><span class="line">     * Create a new MethodBeforeAdviceInterceptor for the given advice.  </span><br><span class="line">     * @param advice the MethodBeforeAdvice to wrap  </span><br><span class="line">     */  </span><br><span class="line">    public MethodBeforeAdviceInterceptor(MethodBeforeAdvice advice) &#123;  </span><br><span class="line">        Assert.notNull(advice, &quot;Advice must not be null&quot;);  </span><br><span class="line">        this.advice = advice;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    //这个invoke方法是拦截器的回调方法,会在代理对象的方法被调用时触发回调  </span><br><span class="line">    @Override  </span><br><span class="line">    public Object invoke(MethodInvocation mi) throws Throwable &#123;  </span><br><span class="line">        //首先触发advise的before回调  </span><br><span class="line">        this.advice.before(mi.getMethod(), mi.getArguments(), mi.getThis() );  </span><br><span class="line">        //然后才是MethodInvocation的proceed方法调用  </span><br><span class="line">        return mi.proceed();  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>上面是MethodBeforeAdviceInterceptor拦截器的源码，MethodBeforeAdvice是对应的通知，另外还有一个角色类是MethodBeforeAdviceAdapter适配器类，这个适配器的源码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">class MethodBeforeAdviceAdapter implements AdvisorAdapter, Serializable &#123;  </span><br><span class="line">  </span><br><span class="line">    @Override  </span><br><span class="line">    public boolean supportsAdvice(Advice advice) &#123;  </span><br><span class="line">        return (advice instanceof MethodBeforeAdvice);  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    @Override  </span><br><span class="line">    public MethodInterceptor getInterceptor(Advisor advisor) &#123;  </span><br><span class="line">        MethodBeforeAdvice advice = (MethodBeforeAdvice) advisor.getAdvice();  </span><br><span class="line">        return new MethodBeforeAdviceInterceptor(advice);  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>可以看到，它的主要作用是，将通知advisor.getAdvice()转换或者说适配成对应的拦截器，有如下三种适配：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1. MethodBeforeAdviceAdapter将MethodBeforeAdvice适配成MethodBeforeAdviceInterceptor  </span><br><span class="line">2. AfterReturningAdviceAdapter将AfterReturningAdvice适配成AfterReturningAdviceInterceptor  </span><br><span class="line">3.ThrowsAdviceAdapter将ThrowsAdvice适配成ThrowsAdviceInterceptor</span><br></pre></td></tr></table></figure></p>
<p>这样适配的目的是什么呢？<br>还得回到我们最初的MethodBeforeAdviceInterceptor的源码中去看<br>首先我们得知道通知是什么，通知就是在调用目标方法之前或者之后等要被调用的增强的方法，比如这里的MethodBeforeAdvice的before方法需要在调用目标方法之前被调用，AfterReturningAdvice的afterReturning方法需要在目标方法被调用之后调用，这个调用逻辑（调用顺序）就是由通知对应的拦截器来完成的，可以看到MethodBeforeAdviceInterceptor由于是前置通知的适配器，所以它的invoke方法在执行下一个拦截器的时候先调用了通知的before方法，然后进入到了下一个拦截器。<br>也就是说，通知只是定义了增强时将要被调用的方法，而方法具体何时调用需要由通知对应的拦截器来进行管理，而适配器的作用就是根据通知得到其对应的拦截器<br>再可以看看AfterReturningAdviceInterceptor拦截器<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">public class AfterReturningAdviceInterceptor implements MethodInterceptor, AfterAdvice, Serializable &#123;  </span><br><span class="line">  </span><br><span class="line">    private final AfterReturningAdvice advice;  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">    /**  </span><br><span class="line">     * Create a new AfterReturningAdviceInterceptor for the given advice.  </span><br><span class="line">     * @param advice the AfterReturningAdvice to wrap  </span><br><span class="line">     */  </span><br><span class="line">    public AfterReturningAdviceInterceptor(AfterReturningAdvice advice) &#123;  </span><br><span class="line">        Assert.notNull(advice, &quot;Advice must not be null&quot;);  </span><br><span class="line">        this.advice = advice;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    @Override  </span><br><span class="line">    public Object invoke(MethodInvocation mi) throws Throwable &#123;  </span><br><span class="line">        Object retVal = mi.proceed();  </span><br><span class="line">        this.advice.afterReturning(retVal, mi.getMethod(), mi.getArguments(), mi.getThis());  </span><br><span class="line">        return retVal;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这个后置通知拦截器就是在先进入到下一个拦截器后，然后再调用的对应通知AfterReturningAdvice的afterReturning方法<br>所以我们可以看到，这几个拦截器实现的功能其实非常类似于动态代理设计模式里面实现了InvocationHandler接口的那个类，比如如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">public class ProxyHandler implements InvocationHandler &#123;  </span><br><span class="line">  </span><br><span class="line">    private Object target;  </span><br><span class="line">  </span><br><span class="line">    public ProxyHandler(Object target) &#123;  </span><br><span class="line">        this.target = target;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123;  </span><br><span class="line">  </span><br><span class="line">        System.out.println(&quot;call before target&quot;);  </span><br><span class="line">  </span><br><span class="line">        Object proxyObject = method.invoke(target, args);   //这里是要调用目标对象target的目标方法method  </span><br><span class="line">  </span><br><span class="line">        System.out.println(&quot;call after target&quot;);  </span><br><span class="line">  </span><br><span class="line">        return proxyObject;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这里目标target的方法被调用前，会被这个类的invoke方法拦截，method.invoke(target, args) 是调用目标方法，这里可以在其前后做一些增强方法</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://denglinjie.com/2017/09/08/2017-09-08-Spring源码分析之lazy-init属性的配置/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="jasonjie">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="jasonjie">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/09/08/2017-09-08-Spring源码分析之lazy-init属性的配置/" itemprop="url">Spring源码分析之lazy-init属性的配置</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-09-08T00:00:00+08:00">
                2017-09-08
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>AbstractApplicationContext类默认在容器初始化的过程中就会执行依赖注入，即等价于配置lazy-init属性为false，bean的配置如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;</span><br><span class="line">       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span><br><span class="line">       xmlns:context=&quot;http://www.springframework.org/schema/context&quot;</span><br><span class="line">       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans</span><br><span class="line">        http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd&quot;&gt;</span><br><span class="line"></span><br><span class="line">    &lt;bean id=&quot;studentService&quot; class=&quot;com.verify.constant.StudentService&quot; init-method=&quot;initMethod&quot; lazy-init=&quot;false&quot;/&gt;</span><br><span class="line">&lt;/beans&gt;</span><br></pre></td></tr></table></figure></p>
<p>容器的初始化是在AbstractApplicationContext的refresh()方法中执行的，如下代码对lazy-init进行了处理：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">finishBeanFactoryInitialization(beanFactory);</span><br></pre></td></tr></table></figure></p>
<p>跟踪下去可以找到真正的读取lazy-init属性进行懒加载相关处理的地方<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">	public void preInstantiateSingletons() throws BeansException &#123;</span><br><span class="line">		if (this.logger.isDebugEnabled()) &#123;</span><br><span class="line">			this.logger.debug(&quot;Pre-instantiating singletons in &quot; + this);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		// Iterate over a copy to allow for init methods which in turn register new bean definitions.</span><br><span class="line">		// While this may not be part of the regular factory bootstrap, it does otherwise work fine.</span><br><span class="line">		List&lt;String&gt; beanNames = new ArrayList&lt;String&gt;(this.beanDefinitionNames);</span><br><span class="line"></span><br><span class="line">		// Trigger initialization of all non-lazy singleton beans...</span><br><span class="line">		for (String beanName : beanNames) &#123;</span><br><span class="line">			RootBeanDefinition bd = getMergedLocalBeanDefinition(beanName);</span><br><span class="line">			if (!bd.isAbstract() &amp;&amp; bd.isSingleton() &amp;&amp; !bd.isLazyInit()) &#123;</span><br><span class="line">				if (isFactoryBean(beanName)) &#123;</span><br><span class="line">					final FactoryBean&lt;?&gt; factory = (FactoryBean&lt;?&gt;) getBean(FACTORY_BEAN_PREFIX + beanName);</span><br><span class="line">					boolean isEagerInit;</span><br><span class="line">					if (System.getSecurityManager() != null &amp;&amp; factory instanceof SmartFactoryBean) &#123;</span><br><span class="line">						isEagerInit = AccessController.doPrivileged(new PrivilegedAction&lt;Boolean&gt;() &#123;</span><br><span class="line">							@Override</span><br><span class="line">							public Boolean run() &#123;</span><br><span class="line">								return ((SmartFactoryBean&lt;?&gt;) factory).isEagerInit();</span><br><span class="line">							&#125;</span><br><span class="line">						&#125;, getAccessControlContext());</span><br><span class="line">					&#125;</span><br><span class="line">					else &#123;</span><br><span class="line">						isEagerInit = (factory instanceof SmartFactoryBean &amp;&amp;</span><br><span class="line">								((SmartFactoryBean&lt;?&gt;) factory).isEagerInit());</span><br><span class="line">					&#125;</span><br><span class="line">					if (isEagerInit) &#123;</span><br><span class="line">						getBean(beanName);</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">				else &#123;</span><br><span class="line">					getBean(beanName);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		// Trigger post-initialization callback for all applicable beans...</span><br><span class="line">		for (String beanName : beanNames) &#123;</span><br><span class="line">			Object singletonInstance = getSingleton(beanName);</span><br><span class="line">			if (singletonInstance instanceof SmartInitializingSingleton) &#123;</span><br><span class="line">				final SmartInitializingSingleton smartSingleton = (SmartInitializingSingleton) singletonInstance;</span><br><span class="line">				if (System.getSecurityManager() != null) &#123;</span><br><span class="line">					AccessController.doPrivileged(new PrivilegedAction&lt;Object&gt;() &#123;</span><br><span class="line">						@Override</span><br><span class="line">						public Object run() &#123;</span><br><span class="line">							smartSingleton.afterSingletonsInstantiated();</span><br><span class="line">							return null;</span><br><span class="line">						&#125;</span><br><span class="line">					&#125;, getAccessControlContext());</span><br><span class="line">				&#125;</span><br><span class="line">				else &#123;</span><br><span class="line">					smartSingleton.afterSingletonsInstantiated();</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure></p>
<p>可以看到代码中对所有注册的bean，即this.beanDefinitionNames，对于每个bean都会做如下判断，如果成立就会执行依赖注入：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">if (!bd.isAbstract() &amp;&amp; bd.isSingleton() &amp;&amp; !bd.isLazyInit())</span><br></pre></td></tr></table></figure></p>
<p>可以看出，只有单例的bean才有可能在容器初始化的时候就完成依赖注入，当lazy-init属性不配置(默认值)或者配置为false的时候，上述if就会成立，当然这里默认不配置abstract属性，所以它默认也是false。if成立，就会执行getBean从而进行依赖注入，这样在容器初始化的过程中就已经实例化了Bean，当真正的请求bean的时候，其实只是从缓存中读取而已。<br>而如果lazy-init属性配置为true，那么就会进行懒加载了，这样在容器初始化的过程中不会进行依赖注入，只有当第一个getBean的时候才会实例化Bean。<br>最后抛出一个我还没有搞明白的问题：<br>书上说的是容器在初始化的过程中默认情况下其实并没有发生依赖注入，而是在第一次getBean的时候才会进行依赖注入，但是这个说法与上述AbstractApplicationContext的容器初始化过程好像是不一致的？还是说AbstractApplicationContext默认是进行依赖注入，但是BeanFactory默认不进行依赖注入？</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://denglinjie.com/2017/09/08/2017-09-08-Spring IOC学习心得之Bean对IOC容器的感知/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="jasonjie">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="jasonjie">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/09/08/2017-09-08-Spring IOC学习心得之Bean对IOC容器的感知/" itemprop="url">Spring IOC学习心得之Bean对IOC容器的感知</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-09-08T00:00:00+08:00">
                2017-09-08
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>容器管理的Bean一般不需要了解容器的状态和直接使用Bean，但是在某些情况下，是需要在Bean中直接对IOC容器进行操作的，这时候，就需要在Bean中设定对容器的感知。Spring IOC也提供了该功能，它是通过特定的aware接口来完成的。aware接口有如下这些：<br>BeanNameAware：可以在Bean中得到它在IOC容器中的Bean的实例名称<br>BeanFactoryAware：可以在Bean中得到Bean所在的IOC容器，从而直接在Bean中使用IOC容器的服务<br>ApplicationContextAware：可以在Bean中得到Bean所在的应用上下文，从而直接在Bean中使用应用上下文的服务<br>MessageSourceAware：在Bean中可以得到消息源<br>ApplicationEventPublisherAware：在Bean中可以得到应用上下文的事件发布器，从而可以在Bean中发布应用上下文的事件<br>ResourceLoaderAware：在Bean中可以得到resourceloader，从而在Bean中使用ResourceLoader加载外部对应的Resource资源<br>要在自定义的Bean中获取上述资源，只需要让Bean实现对应的接口，并覆写set方法，如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public class TestSpring implements ApplicationContextAware&#123;  </span><br><span class="line">    private ApplicationContext applicationContext;  </span><br><span class="line">  </span><br><span class="line">    @Override  </span><br><span class="line">    public void setApplicationContext(ApplicationContext applicationContext) throws BeansException &#123;  </span><br><span class="line">        this.applicationContext = applicationContext;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这样这个Bean实现了ApplicationContextAware接口，并覆写setApplicationContext方法，就可以获取到ApplicationContext对象。<br>这个setApplicationContext方法的回调是容器自动完成的，容器调用该方法的时候，我们就可以将容器传入的参数applicationContext保存起来以供使用<br>setApplicationContext方法被容器的自动调用是在BeanPostProcessor接口的方法postProcessBeforeInitialization中完成的，实现是在ApplicationContextAwareProcessor类中，具体代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line">class ApplicationContextAwareProcessor implements BeanPostProcessor &#123;  </span><br><span class="line">  </span><br><span class="line">    private final ConfigurableApplicationContext applicationContext;  </span><br><span class="line">  </span><br><span class="line">    private final StringValueResolver embeddedValueResolver;  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">    /**  </span><br><span class="line">     * Create a new ApplicationContextAwareProcessor for the given context.  </span><br><span class="line">     */  </span><br><span class="line">    public ApplicationContextAwareProcessor(ConfigurableApplicationContext applicationContext) &#123;  </span><br><span class="line">        this.applicationContext = applicationContext;  </span><br><span class="line">        this.embeddedValueResolver = new EmbeddedValueResolver(applicationContext.getBeanFactory());  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">    @Override  </span><br><span class="line">    public Object postProcessBeforeInitialization(final Object bean, String beanName) throws BeansException &#123;  </span><br><span class="line">        AccessControlContext acc = null;  </span><br><span class="line">  </span><br><span class="line">        if (System.getSecurityManager() != null &amp;&amp;  </span><br><span class="line">                (bean instanceof EnvironmentAware || bean instanceof EmbeddedValueResolverAware ||  </span><br><span class="line">                        bean instanceof ResourceLoaderAware || bean instanceof ApplicationEventPublisherAware ||  </span><br><span class="line">                        bean instanceof MessageSourceAware || bean instanceof ApplicationContextAware)) &#123;  </span><br><span class="line">            acc = this.applicationContext.getBeanFactory().getAccessControlContext();  </span><br><span class="line">        &#125;  </span><br><span class="line">  </span><br><span class="line">        if (acc != null) &#123;  </span><br><span class="line">            AccessController.doPrivileged(new PrivilegedAction&lt;Object&gt;() &#123;  </span><br><span class="line">                @Override  </span><br><span class="line">                public Object run() &#123;  </span><br><span class="line">                    invokeAwareInterfaces(bean);  </span><br><span class="line">                    return null;  </span><br><span class="line">                &#125;  </span><br><span class="line">            &#125;, acc);  </span><br><span class="line">        &#125;  </span><br><span class="line">        else &#123;  </span><br><span class="line">            invokeAwareInterfaces(bean);  </span><br><span class="line">        &#125;  </span><br><span class="line">  </span><br><span class="line">        return bean;  </span><br><span class="line">    &#125;  </span><br><span class="line">//这里就是容器自动调用set方法的地方，其实就是调用自定义的TestSpring类实现的setApplicationContext方法，这样TestSpring类就获取到了applicationContext  </span><br><span class="line">    private void invokeAwareInterfaces(Object bean) &#123;  </span><br><span class="line">        if (bean instanceof Aware) &#123;  </span><br><span class="line">            if (bean instanceof EnvironmentAware) &#123;  </span><br><span class="line">                ((EnvironmentAware) bean).setEnvironment(this.applicationContext.getEnvironment());  </span><br><span class="line">            &#125;  </span><br><span class="line">            if (bean instanceof EmbeddedValueResolverAware) &#123;  </span><br><span class="line">                ((EmbeddedValueResolverAware) bean).setEmbeddedValueResolver(this.embeddedValueResolver);  </span><br><span class="line">            &#125;  </span><br><span class="line">            if (bean instanceof ResourceLoaderAware) &#123;  </span><br><span class="line">                ((ResourceLoaderAware) bean).setResourceLoader(this.applicationContext);  </span><br><span class="line">            &#125;  </span><br><span class="line">            if (bean instanceof ApplicationEventPublisherAware) &#123;  </span><br><span class="line">                ((ApplicationEventPublisherAware) bean).setApplicationEventPublisher(this.applicationContext);  </span><br><span class="line">            &#125;  </span><br><span class="line">            if (bean instanceof MessageSourceAware) &#123;  </span><br><span class="line">                ((MessageSourceAware) bean).setMessageSource(this.applicationContext);  </span><br><span class="line">            &#125;  </span><br><span class="line">            if (bean instanceof ApplicationContextAware) &#123;  </span><br><span class="line">                ((ApplicationContextAware) bean).setApplicationContext(this.applicationContext);  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    @Override  </span><br><span class="line">    public Object postProcessAfterInitialization(Object bean, String beanName) &#123;  </span><br><span class="line">        return bean;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://denglinjie.com/2017/09/08/2017-09-08-Spring AOP中declare-parents为特定的类增加新的功能/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="jasonjie">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="jasonjie">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/09/08/2017-09-08-Spring AOP中declare-parents为特定的类增加新的功能/" itemprop="url">Spring AOP中declare-parents为特定的类增加新的功能</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-09-08T00:00:00+08:00">
                2017-09-08
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>如果有这样一个需求，为一个已知的API添加一个新的功能。</p>
<p>由于是已知的API，我们不能修改其类，只能通过外部包装。但是如果通过之前的AOP前置或后置通知，又不太合理，最简单的办法就是实现某个我们自定义的接口，这个接口包含了想要添加的方法。</p>
<p>但是JAVA不是一门动态的语言，无法再编译后动态添加新的功能，这个时候就可以使用 aop:declare-parents 来做了.</p>
<p>如果是可以改写的类，直接实现自定义的接口就行了，下面看看AOP是如何做的！</p>
<p>最开始使用的类和接口：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">package com.spring.test.declareparents;</span><br><span class="line"></span><br><span class="line">public interface Chinese &#123;</span><br><span class="line">    public void Say();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public class LiLei implements Chinese&#123;</span><br><span class="line">    public void Say() &#123;</span><br><span class="line">        System.out.println(&quot;我是中国人！&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>想要添加的新功能和接口<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">package com.spring.test.declareparents;</span><br><span class="line"></span><br><span class="line">public interface Add &#123;</span><br><span class="line">    public void Todo();</span><br><span class="line">&#125;</span><br><span class="line">public class DoSomething implements Add&#123;</span><br><span class="line">    public void Todo() &#123;</span><br><span class="line">        System.out.println(&quot;我爱中国！&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>通过配置AOP，实现两种功能的耦合<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;beans&gt;</span><br><span class="line">    &lt;bean id=&quot;lilei&quot; class=&quot;com.spring.test.declareparents.LiLei&quot;/&gt;</span><br><span class="line">    &lt;bean id=&quot;doSomething&quot; class=&quot;com.spring.test.declareparents.DoSomething&quot;/&gt;</span><br><span class="line">    </span><br><span class="line">    &lt;aop:config proxy-target-class=&quot;true&quot;&gt;</span><br><span class="line">        &lt;aop:aspect&gt;</span><br><span class="line">            &lt;aop:declare-parents </span><br><span class="line">            types-matching=&quot;com.spring.test.declareparents.LiLei&quot;</span><br><span class="line">            implement-interface=&quot;com.spring.test.declareparents.Add&quot; </span><br><span class="line">            default-impl=&quot;com.spring.test.declareparents.DoSomething&quot;/&gt;</span><br><span class="line">        &lt;/aop:aspect&gt;</span><br><span class="line">    &lt;/aop:config&gt;</span><br><span class="line">&lt;/beans&gt;</span><br></pre></td></tr></table></figure></p>
<p>其中types-mathcing是之前原始的类，implement-interface是想要添加的功能的接口，default-impl是新功能的默认的实现。</p>
<p>在使用时，直接通过getBean获得bean转换成相应的接口就可以使用了。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Chinese lilei = (Chinese)ctx.getBean(&quot;lilei&quot;);</span><br><span class="line">lilei.Say();</span><br><span class="line"></span><br><span class="line">Add lilei2 = (Add)ctx.getBean(&quot;lilei&quot;);</span><br><span class="line">lilei2.Todo();</span><br></pre></td></tr></table></figure></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://denglinjie.com/2017/09/08/2017-09-08-Spring IOC学习心得之BeanPostProcessor，BeanNameAware，BeanClassLoaderAware，BeanFactoryAware接口是如何起作用的/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="jasonjie">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="jasonjie">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/09/08/2017-09-08-Spring IOC学习心得之BeanPostProcessor，BeanNameAware，BeanClassLoaderAware，BeanFactoryAware接口是如何起作用的/" itemprop="url">Spring IOC学习心得之BeanPostProcessor，BeanNameAware，BeanClassLoaderAware，BeanFactoryAware接口是如何起作用的</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-09-08T00:00:00+08:00">
                2017-09-08
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <ol>
<li>首先说下BeanPostProcessor接口中的两个方法，如下：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">package org.springframework.beans.factory.config;  </span><br><span class="line">  </span><br><span class="line">import org.springframework.beans.BeansException;  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">public interface BeanPostProcessor &#123;  </span><br><span class="line">  </span><br><span class="line">        //Bean初始化的前置处理器  </span><br><span class="line">    Object postProcessBeforeInitialization(Object bean, String beanName) throws BeansException;  </span><br><span class="line">  </span><br><span class="line">    //Bean初始化的后置处理器  </span><br><span class="line">    Object postProcessAfterInitialization(Object bean, String beanName) throws BeansException;  </span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>应用中自定义的Bean，可以实现这个接口，并覆盖这两个方法来控制Bean的初始化过程，即在Bean的初始化之前做一件事，即调用postProcessBeforeInitialization方法，也可以在Bean的初始化之后做一件事，即调用postProcessAfterInitialization方法。那么这两个方法究竟是如何被Spring调用的呢？</p>
<ol start="2">
<li><p>在Bean的初始化过程中，会调用initializeBean方法，该方法的源码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">protected Object initializeBean(final String beanName, final Object bean, RootBeanDefinition mbd) &#123;  </span><br><span class="line">        if (System.getSecurityManager() != null) &#123;  </span><br><span class="line">            AccessController.doPrivileged(new PrivilegedAction&lt;Object&gt;() &#123;  </span><br><span class="line">                @Override  </span><br><span class="line">                public Object run() &#123;  </span><br><span class="line">                    invokeAwareMethods(beanName, bean);  </span><br><span class="line">                    return null;  </span><br><span class="line">                &#125;  </span><br><span class="line">            &#125;, getAccessControlContext());  </span><br><span class="line">        &#125;  </span><br><span class="line">        else &#123;  </span><br><span class="line">            invokeAwareMethods(beanName, bean);  </span><br><span class="line">        &#125;  </span><br><span class="line">  </span><br><span class="line">        Object wrappedBean = bean;  </span><br><span class="line">        if (mbd == null || !mbd.isSynthetic()) &#123;  </span><br><span class="line">            //执行BeanPostProcessor扩展点的PostProcessBeforeInitialization进行修改实例化Bean  </span><br><span class="line">            wrappedBean = applyBeanPostProcessorsBeforeInitialization(wrappedBean, beanName);  </span><br><span class="line">        &#125;  </span><br><span class="line">  </span><br><span class="line">        try &#123;  </span><br><span class="line">            //调用Bean的初始化方法,这个初始化方法是在BeanDefinition中通过定义init-method属性指定的  </span><br><span class="line">            //同时,如果Bean实现了InitializingBean接口,那么这个Bean的afterPropertiesSet实现也不会被调用  </span><br><span class="line">            invokeInitMethods(beanName, wrappedBean, mbd);  </span><br><span class="line">        &#125;  </span><br><span class="line">        catch (Throwable ex) &#123;  </span><br><span class="line">            throw new BeanCreationException(  </span><br><span class="line">                    (mbd != null ? mbd.getResourceDescription() : null),  </span><br><span class="line">                    beanName, &quot;Invocation of init method failed&quot;, ex);  </span><br><span class="line">        &#125;  </span><br><span class="line">  </span><br><span class="line">        if (mbd == null || !mbd.isSynthetic()) &#123;  </span><br><span class="line">            //执行BeanPostProcessor扩展点的PostProcessAfterInitialization进行修改实例化Bean  </span><br><span class="line">            wrappedBean = applyBeanPostProcessorsAfterInitialization(wrappedBean, beanName);  </span><br><span class="line">        &#125;  </span><br><span class="line">        return wrappedBean;  </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>BeanPostProcessor起作用的方式<br>先说下invokeInitMethods方法，这个是真正的Bean的初始化方法，我们可以看到在该方法之前有一个方法applyBeanPostProcessorsBeforeInitialization，该方法实现Bean初始化的前置处理，可以看下该方法的源码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">@Override  </span><br><span class="line">    public Object applyBeanPostProcessorsBeforeInitialization(Object existingBean, String beanName)  </span><br><span class="line">            throws BeansException &#123;  </span><br><span class="line">  </span><br><span class="line">        Object result = existingBean;  </span><br><span class="line">        for (BeanPostProcessor beanProcessor : getBeanPostProcessors()) &#123;  </span><br><span class="line">            result = beanProcessor.postProcessBeforeInitialization(result, beanName);  </span><br><span class="line">            if (result == null) &#123;  </span><br><span class="line">                return result;  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">        return result;  </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>这个方法中会通过getBeanPostProcessors方法去获取Bean所实现的所有的BeanPostProcessor接口，并调用其postProcessBeforeInitialization方法来实现在Bean的初始化之前做一些预处理<br>在invokeInitMethods方法之后，有一个applyBeanPostProcessorsAfterInitialization方法，该方法实现Bean的初始化的后置处理，可以看下该方法的源码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">@Override  </span><br><span class="line">    public Object applyBeanPostProcessorsAfterInitialization(Object existingBean, String beanName)  </span><br><span class="line">            throws BeansException &#123;  </span><br><span class="line">  </span><br><span class="line">        Object result = existingBean;  </span><br><span class="line">        for (BeanPostProcessor beanProcessor : getBeanPostProcessors()) &#123;  </span><br><span class="line">            result = beanProcessor.postProcessAfterInitialization(result, beanName);  </span><br><span class="line">            if (result == null) &#123;  </span><br><span class="line">                return result;  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">        return result;  </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>与前置处理类似，也是获取Bean实现的所有BeanPostProcessor接口，然后调用所有接口的postProcessAfterInitialization后置处理方法</p>
<ol start="4">
<li>BeanNameAware，BeanClassLoaderAware，BeanFactoryAware接口起作用的方式<br>大家注意到initializebean方法中有一个invokeAwareMethods方法，先看下这个方法的源码：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">private void invokeAwareMethods(final String beanName, final Object bean) &#123;  </span><br><span class="line">        if (bean instanceof Aware) &#123;  </span><br><span class="line">            if (bean instanceof BeanNameAware) &#123;  </span><br><span class="line">                ((BeanNameAware) bean).setBeanName(beanName);  </span><br><span class="line">            &#125;  </span><br><span class="line">            if (bean instanceof BeanClassLoaderAware) &#123;  </span><br><span class="line">                ((BeanClassLoaderAware) bean).setBeanClassLoader(getBeanClassLoader());  </span><br><span class="line">            &#125;  </span><br><span class="line">            if (bean instanceof BeanFactoryAware) &#123;  </span><br><span class="line">                ((BeanFactoryAware) bean).setBeanFactory(AbstractAutowireCapableBeanFactory.this);  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>举例来说，当应用自定义的Bean实现了BeanNameAware接口，如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public class MyBean implements BeanNameAware &#123;  </span><br><span class="line">    private String beanName;  </span><br><span class="line">  </span><br><span class="line">    void setBeanName(String name) &#123;  </span><br><span class="line">        this.beanName = name;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这样就可以获取到该Bean在Spring容器中的名字，原理就是上述invokeAwareMethods方法中，判断了如果bean实现了BeanNameAware接口，就会调用该Bean覆盖的BeanNameAware接口的setBeanName方法，这样MyBean中就获取到了该Bean在Spring容器中的名字。<br>BeanClassLoaderAware接口和BeanFactoryAware接口同理，可以分别获取Bean的类装载器和bean工厂</p>
<ol start="5">
<li>InitializeBean接口起作用的方式<br>最后来说下真正的初始化方法invokeInitMethods，该方法的源码如下：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">protected void invokeInitMethods(String beanName, final Object bean, RootBeanDefinition mbd)  </span><br><span class="line">            throws Throwable &#123;  </span><br><span class="line">  </span><br><span class="line">        boolean isInitializingBean = (bean instanceof InitializingBean);  </span><br><span class="line">        if (isInitializingBean &amp;&amp; (mbd == null || !mbd.isExternallyManagedInitMethod(&quot;afterPropertiesSet&quot;))) &#123;  </span><br><span class="line">            if (logger.isDebugEnabled()) &#123;  </span><br><span class="line">                logger.debug(&quot;Invoking afterPropertiesSet() on bean with name &apos;&quot; + beanName + &quot;&apos;&quot;);  </span><br><span class="line">            &#125;  </span><br><span class="line">            if (System.getSecurityManager() != null) &#123;  </span><br><span class="line">                try &#123;  </span><br><span class="line">                    AccessController.doPrivileged(new PrivilegedExceptionAction&lt;Object&gt;() &#123;  </span><br><span class="line">                        @Override  </span><br><span class="line">                        public Object run() throws Exception &#123;  </span><br><span class="line">                            ((InitializingBean) bean).afterPropertiesSet();  </span><br><span class="line">                            return null;  </span><br><span class="line">                        &#125;  </span><br><span class="line">                    &#125;, getAccessControlContext());  </span><br><span class="line">                &#125;  </span><br><span class="line">                catch (PrivilegedActionException pae) &#123;  </span><br><span class="line">                    throw pae.getException();  </span><br><span class="line">                &#125;  </span><br><span class="line">            &#125;  </span><br><span class="line">            else &#123;  </span><br><span class="line">                ((InitializingBean) bean).afterPropertiesSet(); //启动afterPropertiesSet,afterPropertiesSet是InitializingBean接口的方法  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">  </span><br><span class="line">        if (mbd != null) &#123;  </span><br><span class="line">            String initMethodName = mbd.getInitMethodName();    //获取用户自定义的初始化方法  </span><br><span class="line">            if (initMethodName != null &amp;&amp; !(isInitializingBean &amp;&amp; &quot;afterPropertiesSet&quot;.equals(initMethodName)) &amp;&amp;  </span><br><span class="line">                    !mbd.isExternallyManagedInitMethod(initMethodName)) &#123;  </span><br><span class="line">                invokeCustomInitMethod(beanName, bean, mbd);    //调用自定义的初始化方法  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>可以看到方法中判断了如果该Bean实现了InitializeBean接口，即bean instanceof InitializingBean == true，就会调用该Bean实现的Initializebean接口的afterPropertiesSet方法</p>
<ol start="6">
<li>自定义的初始化方法起作用的方式<br>上述代码中有一个方法getInitMethodName，可以获取用户自定义的初始化方法，然后通过调用invokeCustomInitMethod方法来执行用户自定义的初始化方法</li>
</ol>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope="" itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">jasonjie</p>
              <p class="site-description motion-element" itemprop="description">生活不只眼前的苟且，还有诗和远方的田野</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">14</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            

            
              
              
              <div class="site-state-item site-state-tags">
                
                  <span class="site-state-item-count">4</span>
                  <span class="site-state-item-name">标签</span>
                
              </div>
            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">jasonjie</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Muse</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
