<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT">










<meta name="description" content="生活不只眼前的苟且，还有诗和远方的田野">
<meta property="og:type" content="website">
<meta property="og:title" content="jasonjie">
<meta property="og:url" content="http://denglinjie.com/index.html">
<meta property="og:site_name" content="jasonjie">
<meta property="og:description" content="生活不只眼前的苟且，还有诗和远方的田野">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="jasonjie">
<meta name="twitter:description" content="生活不只眼前的苟且，还有诗和远方的田野">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://denglinjie.com/">





  <title>jasonjie</title>
  








</head>

<body itemscope="" itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope="" itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">jasonjie</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br>
            
            关于作者
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br>
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://denglinjie.com/2018/12/18/一篇测试/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="jasonjie">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="jasonjie">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/12/18/一篇测试/" itemprop="url">一篇测试</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-12-18T11:22:54+08:00">
                2018-12-18
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://denglinjie.com/2017/09/08/2017-09-12-我是如何解决jobtracker.info could only be replicated to 0 nodes, instead of 1这个问题的/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="jasonjie">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="jasonjie">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/09/08/2017-09-12-我是如何解决jobtracker.info could only be replicated to 0 nodes, instead of 1这个问题的/" itemprop="url">我是如何解决jobtracker.info could only be replicated to 0 nodes, instead of 1这个问题的</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-09-08T00:00:00+08:00">
                2017-09-08
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/Hadoop开发/" itemprop="url" rel="index">
                    <span itemprop="name">Hadoop开发</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>tags:</p>
<pre><code>- hadoop
</code></pre><hr>
<p>我按照慕课网上的教程来学习搭建hadoop-1.2.1环境，可是在start-all.sh这步的时候一直通不过，命令行报如下错误<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[@soguo /home/denglinjie/hadoop]# start-all.sh   </span><br><span class="line">Warning: $HADOOP_HOME is deprecated.  </span><br><span class="line">  </span><br><span class="line">starting namenode, logging to /home/denglinjie/hadoop-1.2.1/logs/hadoop-denglinjie-namenode-bjzw_30_4.out  </span><br><span class="line">localhost: ssh_exchange_identification: Connection closed by remote host  </span><br><span class="line">localhost: ssh_exchange_identification: Connection closed by remote host  </span><br><span class="line">starting jobtracker, logging to /home/denglinjie/hadoop-1.2.1/logs/hadoop-denglinjie-jobtracker-bjzw_30_4.out  </span><br><span class="line">localhost: ssh_exchange_identification: Connection closed by remote host</span><br></pre></td></tr></table></figure></p>
<p>日志文件报如下错误：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">2017-03-02 19:28:00,951 WARN org.apache.hadoop.hdfs.DFSClient: Error Recovery for null bad datanode[0] nodes == null  </span><br><span class="line">2017-03-02 19:28:00,952 WARN org.apache.hadoop.hdfs.DFSClient: Could not get block locations. Source file &quot;/home/denglinjie/hadoop/tmp/mapred/system/jobtracker.info&quot; - Aborting  </span><br><span class="line">...  </span><br><span class="line">2017-03-02 19:28:00,952 WARN org.apache.hadoop.mapred.JobTracker: Writing to file hdfs://localhost:9063/home/denglinjie/hadoop/tmp/mapred/system/jobtracker.info failed!  </span><br><span class="line">2017-03-02 19:28:00,952 WARN org.apache.hadoop.mapred.JobTracker: FileSystem is not ready yet!  </span><br><span class="line">2017-03-02 19:28:00,954 WARN org.apache.hadoop.mapred.JobTracker: Failed to initialize recovery manager.   </span><br><span class="line">org.apache.hadoop.ipc.RemoteException: java.io.IOException: File /home/denglinjie/hadoop/tmp/mapred/system/jobtracker.info could only be replicated to 0 nodes, instead of 1  </span><br><span class="line">    at org.apache.hadoop.hdfs.server.namenode.FSNamesystem.getAdditionalBlock(FSNamesystem.java:1920)  </span><br><span class="line">    at org.apache.hadoop.hdfs.server.namenode.NameNode.addBlock(NameNode.java:783)  </span><br><span class="line">    at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)  </span><br><span class="line">    at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39)  </span><br><span class="line">    at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25)  </span><br><span class="line">    at java.lang.reflect.Method.invoke(Method.java:597)  </span><br><span class="line">    at org.apache.hadoop.ipc.RPC$Server.call(RPC.java:587)  </span><br><span class="line">    at org.apache.hadoop.ipc.Server$Handler$1.run(Server.java:1432)  </span><br><span class="line">    at org.apache.hadoop.ipc.Server$Handler$1.run(Server.java:1428)  </span><br><span class="line">    at java.security.AccessController.doPrivileged(Native Method)  </span><br><span class="line">    at javax.security.auth.Subject.doAs(Subject.java:396)  </span><br><span class="line">    at org.apache.hadoop.security.UserGroupInformation.doAs(UserGroupInformation.java:1190)  </span><br><span class="line">    at org.apache.hadoop.ipc.Server$Handler.run(Server.java:1426)  </span><br><span class="line">  </span><br><span class="line">    at org.apache.hadoop.ipc.Client.call(Client.java:1113)  </span><br><span class="line">    at org.apache.hadoop.ipc.RPC$Invoker.invoke(RPC.java:229)  </span><br><span class="line">    at com.sun.proxy.$Proxy7.addBlock(Unknown Source)  </span><br><span class="line">    at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)  </span><br><span class="line">    at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39)  </span><br><span class="line">    at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25)  </span><br><span class="line">    at java.lang.reflect.Method.invoke(Method.java:597)  </span><br><span class="line">    at org.apache.hadoop.io.retry.RetryInvocationHandler.invokeMethod(RetryInvocationHandler.java:85)  </span><br><span class="line">    at org.apache.hadoop.io.retry.RetryInvocationHandler.invoke(RetryInvocationHandler.java:62)  </span><br><span class="line">    at com.sun.proxy.$Proxy7.addBlock(Unknown Source)  </span><br><span class="line">    at org.apache.hadoop.hdfs.DFSClient$DFSOutputStream.locateFollowingBlock(DFSClient.java:3720)  </span><br><span class="line">    at org.apache.hadoop.hdfs.DFSClient$DFSOutputStream.nextBlockOutputStream(DFSClient.java:3580)  </span><br><span class="line">    at org.apache.hadoop.hdfs.DFSClient$DFSOutputStream.access$2600(DFSClient.java:2783)  </span><br><span class="line">    at org.apache.hadoop.hdfs.DFSClient$DFSOutputStream$DataStreamer.run(DFSClient.java:3023)</span><br></pre></td></tr></table></figure></p>
<p>首先解决命令行报的错误：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">localhost: ssh_exchange_identification: Connection closed by remote host</span><br></pre></td></tr></table></figure></p>
<p>从google中找问题，发现网上的解决办法千奇百怪，有的说要修改slaves和masters文件中的主机名为ip地址，有的说是因为主机名不能有下划线，但是其实我的主机名用的默认的localhost，总之尝试了网上的各种解决办法，都失败，网上大多数办法都是集中在如下几个配置文件配置的问题上：<br>core-site.xml,  mapred-site.xml,  hdfs-site.xml<br>不过无论我怎么配置都不行，于是一下午都没有找到原因<br>第二天来之后，我想了下也许慕课网那个视频教程是精简版的呢，于是我索性自己从google上搜索了一篇hadoop-1.2.1搭建本地伪分布式安装的教程，按照别人的教程来，文章地址如下：<br><a href="https://hexo2hexo.github.io/hadoop1.2.1%E5%AE%89%E8%A3%85/" target="_blank" rel="noopener">https://hexo2hexo.github.io/hadoop1.2.1%E5%AE%89%E8%A3%85/</a><br>这篇文章中的步骤其实和慕课网的视频教程步骤基本雷同，但是多了如下步骤：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1.生成秘钥  </span><br><span class="line">ssh-keygen -t rsa  </span><br><span class="line">2.一直回车即可,然后进入.ssh目录,执行命令  </span><br><span class="line">cd ~/.ssh  </span><br><span class="line">cp id_rsa.pub authorized_keys  </span><br><span class="line">3.检查是否需要密码  </span><br><span class="line">ssh localhost</span><br></pre></td></tr></table></figure></p>
<p>这很显然是设置免密码登陆啊，于是我按照它的步骤操作了一遍，发现执行到ssh localhost这步的时候，报了如下错误：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh_exchange_identification: Connection closed by remote host</span><br></pre></td></tr></table></figure></p>
<p>我一看，这步跟我启动hadoop的时候报的错误是一样的吗？感情启动hadoop的时候就是在执行ssh  localhost这步呢，于是原因也找到了，<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jobtracker.info could only be replicated to 0 nodes, instead of 1</span><br></pre></td></tr></table></figure></p>
<p>上面这个应该只是ssh执行失败的结果，而不是造成问题的主要原因，既然这样那只要保证ssh  localhost成功登陆本地主机不就OK了吗<br>于是又在网上一通找，</p>
<p>首先开启了/etc/ssh/sshd_config配置文件中的如下几个选项<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">RSAAuthentication yes  </span><br><span class="line">PubkeyAuthentication yes  </span><br><span class="line">AuthorizedKeysFile  .ssh/authorized_key</span><br></pre></td></tr></table></figure></p>
<p>然后重启ssh服务</p>
<h1 id="service-sshd-restart"><a href="#service-sshd-restart" class="headerlink" title="service  sshd   restart"></a>service  sshd   restart</h1><p>发现不好使，还是登陆不上，然后又把/etc/hosts.deny文件中的</p>
<h1 id="sshd-ALL"><a href="#sshd-ALL" class="headerlink" title="sshd  ALL"></a>sshd  ALL</h1><p>这行注释打开，重启sshd服务，再次登陆成功了！<br>于是迫不及待的重新执行<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># stop-all.sh  </span><br><span class="line"># hadoop namenode -format  </span><br><span class="line"># start-all.sh</span><br></pre></td></tr></table></figure></p>
<p>成功了！！！<br>执行jps命令，成功看到了如下输出：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[@sohuo ~/hadoop-1.2.1]$ jps  </span><br><span class="line">30999 Jps  </span><br><span class="line">30510 DataNode  </span><br><span class="line">30651 SecondaryNameNode  </span><br><span class="line">30885 TaskTracker  </span><br><span class="line">30395 NameNode  </span><br><span class="line">30760 JobTracker</span><br></pre></td></tr></table></figure></p>
<p>然后说下日志文件报的错误：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jobtracker.info could only be replicated to 0 nodes, instead of 1</span><br></pre></td></tr></table></figure></p>
<p>这个问题，网上的解决办法也是多种多样，有的说是防火墙没关闭，但是其实我的机器根本没有防火墙。有的说是目录没有删除干净等等。<br>当然最后解决我问题的还是磁盘空间不足的问题。<br>在core-site.xml文件和hdfs-site.xml文件中配置的有namenode和datanode放置的目录，我的机器上，这个目录所在盘已经满了，于是我修改这两个文件配置到了另外一个盘上，问题就解决了。<br>其实一开始，我把hadoop-1.2.1.tar.gz文件解压到我自己的用户家目录下的时候就发现莫名其妙的异常，就是加压后的一些脚本文件内容都是空的，我以为是解压的过程中丢失了，于是我重新解压，才发现日志中说磁盘空间不足。<br>但是我又想在自己用户下工作，怎么办呢？于是我将hadoop-1.2.1.tar.gz文件移动到了一个剩余空间充裕的磁盘目录下，并解压，然后在我自己的家目录下为解压后的hadoop目录创建了软的符号链接，这样就可以了。<br>但是我没有意识到，我在core-site.xml文件和hdfs-site.xml文件中为hadoop指定的namenode和datanode存放的目录还是在我自己的家目录下，而这些目录就不是符号链接了，导致空间不足，所以报了上述错误，终于圆满解决。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://denglinjie.com/2017/09/08/2017-09-08-Spring IOC学习心得之IOC容器的初始化过程/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="jasonjie">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="jasonjie">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/09/08/2017-09-08-Spring IOC学习心得之IOC容器的初始化过程/" itemprop="url">Spring IOC学习心得之IOC容器的初始化过程</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-09-08T00:00:00+08:00">
                2017-09-08
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/Java开发/" itemprop="url" rel="index">
                    <span itemprop="name">Java开发</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>tags:</p>
<pre><code>- Spring
- Java
- Linux
</code></pre><hr>
<p>注：本文大多数内容都是摘自《Spring技术内幕》这本书<br>简单来说，Ioc容器的初始化过程是在refresh（）方法中启动的，包括BeanDefinition的Resource定位，载入和注册三个过程。<br>第一：Resource的定位<br>这个Resource指的是BeanDefinition的资源定位，由ResourceLoader通过统一的Resource接口来完成。文件系统中的Bean定义信息可以使用FileSystemResource来进行抽象，类路径中的Bean定义信息可以使用ClassPathResource来抽象。</p>
<p>第二： BeanDefinition的载入<br>上面已经定位了资源Resource的位置，接下来就是将Bean定义表示成Ioc容器内部的结果，即读取进来封装成BeanDefinition。</p>
<p>第三：向IOc容器注册这些BeanDefinition<br>实际上就是将BeanDefinition注册到Hashmap中去，IOC就是通过这个HashMap来持有这些BeanDefinition数据的</p>
<p>但是请注意，上面三个过程不包含Bean依赖注入的过程，依赖注入一般发生在应用第一次通过getBean向容器索取Bean的时候，但是有一个例外是，可以设置Bean的lazyinit属性，那么这个Bean的依赖注入就再IOC容器初始化时就预先完成了</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://denglinjie.com/2017/09/08/2017-09-08-Spring IOC学习心得之注册bean的依赖关系/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="jasonjie">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="jasonjie">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/09/08/2017-09-08-Spring IOC学习心得之注册bean的依赖关系/" itemprop="url">Spring IOC学习心得之注册bean的依赖关系</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-09-08T00:00:00+08:00">
                2017-09-08
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/Java开发/" itemprop="url" rel="index">
                    <span itemprop="name">Java开发</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>tags:</p>
<pre><code>- Spring
- Java
- Linux
</code></pre><hr>
<p>registerDependentBean方法的解析（注册bean的依赖关系）<br>源码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">public void registerDependentBean(String beanName, String dependentBeanName) &#123;  </span><br><span class="line">        // A quick check for an existing entry upfront, avoiding synchronization...  </span><br><span class="line">        String canonicalName = canonicalName(beanName);  </span><br><span class="line">        /*  </span><br><span class="line">        dependentBeanMap中存储的是目前已经注册的依赖这个bean的所有bean,这里从这个集合中获取目前所有已经注册的依赖beanName的bean集合,  </span><br><span class="line">        然后看这个集合中是否包含dependentBeanName,即是否已经注册,如果包含则表示已经注册,则直接返回,否则,将bean依赖关系添加到两个map缓存即完成注册  </span><br><span class="line">            */  </span><br><span class="line">        Set&lt;String&gt; dependentBeans = this.dependentBeanMap.get(canonicalName);  </span><br><span class="line">        if (dependentBeans != null &amp;&amp; dependentBeans.contains(dependentBeanName)) &#123;  </span><br><span class="line">            return;  </span><br><span class="line">        &#125;  </span><br><span class="line">  </span><br><span class="line">        // No entry yet -&gt; fully synchronized manipulation of the dependentBeans Set  </span><br><span class="line">        synchronized (this.dependentBeanMap) &#123;  </span><br><span class="line">            dependentBeans = this.dependentBeanMap.get(canonicalName);  </span><br><span class="line">            if (dependentBeans == null) &#123;  </span><br><span class="line">                dependentBeans = new LinkedHashSet&lt;&gt;(8);  </span><br><span class="line">                this.dependentBeanMap.put(canonicalName, dependentBeans);  </span><br><span class="line">            &#125;  </span><br><span class="line">            dependentBeans.add(dependentBeanName);  </span><br><span class="line">        &#125;  </span><br><span class="line">        synchronized (this.dependenciesForBeanMap) &#123;  </span><br><span class="line">            Set&lt;String&gt; dependenciesForBean = this.dependenciesForBeanMap.get(dependentBeanName);  </span><br><span class="line">            if (dependenciesForBean == null) &#123;  </span><br><span class="line">                dependenciesForBean = new LinkedHashSet&lt;&gt;(8);  </span><br><span class="line">                this.dependenciesForBeanMap.put(dependentBeanName, dependenciesForBean);  </span><br><span class="line">            &#125;  </span><br><span class="line">            dependenciesForBean.add(canonicalName);  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>解释下上述代码中用到的两个map缓存集合，如下：<br>private final Map&lt;String, Set<string>&gt; dependentBeanMap = new ConcurrentHashMap&lt;String, Set<string>&gt;(); //指定的bean与目前已经注册的依赖这个指定的bean的所有bean的依赖关系的缓存（我依赖的）<br>private final Map&lt;String, Set<string>&gt; dependenciesForBeanMap = new ConcurrentHashMap&lt;String, Set<string>&gt;(); //指定bean与目前已经注册的创建这个bean所需依赖的所有bean的依赖关系的缓存（依赖我的）<br>知道了这两个集合的意思，再参考上述源码中的注释，就不难理解这段代码的意思了</string></string></string></string></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://denglinjie.com/2017/09/08/2017-09-08-Spring IOC学习心得之源码级分析ContextLoaderListener的作用(IOC容器初始化入口)/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="jasonjie">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="jasonjie">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/09/08/2017-09-08-Spring IOC学习心得之源码级分析ContextLoaderListener的作用(IOC容器初始化入口)/" itemprop="url">Spring IOC学习心得之源码级分析ContextLoaderListener的作用(IOC容器初始化入口)</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-09-08T00:00:00+08:00">
                2017-09-08
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/Java开发/" itemprop="url" rel="index">
                    <span itemprop="name">Java开发</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>tags:</p>
<pre><code>- Spring
- Java
- Linux
</code></pre><hr>
<p>ContextLoaderListener类是负责初始化IOC容器，即在我们的web项目中，这里就是IOC容器初始化的入口，由这个类启动IOC容器的初始化。<br>它配置在web.xml中，比如如下配置：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;context-param&gt;  </span><br><span class="line">        &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;  </span><br><span class="line">        &lt;param-value&gt;classpath:context/applicationContext.xml&lt;/param-value&gt;  </span><br><span class="line">    &lt;/context-param&gt;  </span><br><span class="line">  </span><br><span class="line">    &lt;!-- Spring监听器 --&gt;  </span><br><span class="line">    &lt;listener&gt;  </span><br><span class="line">        &lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;/listener-class&gt;  </span><br><span class="line">    &lt;/listener&gt;</span><br></pre></td></tr></table></figure></p>
<p>跟踪ContextLoaderListener类，可以看到有一个如下方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">protected void configureAndRefreshWebApplicationContext(ConfigurableWebApplicationContext wac, ServletContext sc) &#123;  </span><br><span class="line">        String configLocationParam;  </span><br><span class="line">        if(ObjectUtils.identityToString(wac).equals(wac.getId())) &#123;  </span><br><span class="line">            configLocationParam = sc.getInitParameter(&quot;contextId&quot;);  </span><br><span class="line">            if(configLocationParam != null) &#123;  </span><br><span class="line">                wac.setId(configLocationParam);  </span><br><span class="line">            &#125; else &#123;  </span><br><span class="line">                wac.setId(ConfigurableWebApplicationContext.APPLICATION_CONTEXT_ID_PREFIX + ObjectUtils.getDisplayString(sc.getContextPath()));  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">  </span><br><span class="line">        wac.setServletContext(sc);  </span><br><span class="line">        configLocationParam = sc.getInitParameter(&quot;contextConfigLocation&quot;); //很显然这里就是读取web.xml中配置的资源文件的路径，也就是上述context-param  </span><br><span class="line">标签配置的参数  </span><br><span class="line">        if(configLocationParam != null) &#123;  </span><br><span class="line">            wac.setConfigLocation(configLocationParam);  </span><br><span class="line">        &#125;  </span><br><span class="line">  </span><br><span class="line">        ConfigurableEnvironment env = wac.getEnvironment();  </span><br><span class="line">        if(env instanceof ConfigurableWebEnvironment) &#123;  </span><br><span class="line">            ((ConfigurableWebEnvironment)env).initPropertySources(sc, (ServletConfig)null);  </span><br><span class="line">        &#125;  </span><br><span class="line">  </span><br><span class="line">        this.customizeContext(sc, wac);  </span><br><span class="line">        wac.refresh();  //有了资源文件后，在这里开启IOC容器的初始化  </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>refresh方法的实现是在AbstractApplicationContext类中，代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">public void refresh() throws BeansException, IllegalStateException &#123;  </span><br><span class="line">        Object var1 = this.startupShutdownMonitor;  </span><br><span class="line">        synchronized(this.startupShutdownMonitor) &#123;  </span><br><span class="line">            this.prepareRefresh();  </span><br><span class="line">            ConfigurableListableBeanFactory beanFactory = this.obtainFreshBeanFactory();  </span><br><span class="line">            this.prepareBeanFactory(beanFactory);  </span><br><span class="line">  </span><br><span class="line">            try &#123;  </span><br><span class="line">                this.postProcessBeanFactory(beanFactory);  </span><br><span class="line">                this.invokeBeanFactoryPostProcessors(beanFactory);  </span><br><span class="line">                this.registerBeanPostProcessors(beanFactory);  </span><br><span class="line">                this.initMessageSource();  </span><br><span class="line">                this.initApplicationEventMulticaster();  </span><br><span class="line">                this.onRefresh();  </span><br><span class="line">                this.registerListeners();  </span><br><span class="line">                this.finishBeanFactoryInitialization(beanFactory);  </span><br><span class="line">                this.finishRefresh();  </span><br><span class="line">            &#125; catch (BeansException var9) &#123;  </span><br><span class="line">                if(this.logger.isWarnEnabled()) &#123;  </span><br><span class="line">                    this.logger.warn(&quot;Exception encountered during context initialization - cancelling refresh attempt: &quot; + var9);  </span><br><span class="line">                &#125;  </span><br><span class="line">  </span><br><span class="line">                this.destroyBeans();  </span><br><span class="line">                this.cancelRefresh(var9);  </span><br><span class="line">                throw var9;  </span><br><span class="line">            &#125; finally &#123;  </span><br><span class="line">                this.resetCommonCaches();  </span><br><span class="line">            &#125;  </span><br><span class="line">  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>上述代码就会进行完整的IOC容器的初始化</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://denglinjie.com/2017/09/08/2017-09-08-Spring源码分析之Aop中拦截器,适配器,通知之间的关系/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="jasonjie">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="jasonjie">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/09/08/2017-09-08-Spring源码分析之Aop中拦截器,适配器,通知之间的关系/" itemprop="url">Spring源码分析之Aop中拦截器,适配器,通知之间的关系</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-09-08T00:00:00+08:00">
                2017-09-08
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/Java开发/" itemprop="url" rel="index">
                    <span itemprop="name">Java开发</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>tags:</p>
<pre><code>- Spring
- Java
- Linux
</code></pre><hr>
<p>首先举一个例子：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">public class MethodBeforeAdviceInterceptor implements MethodInterceptor, Serializable &#123;  </span><br><span class="line">  </span><br><span class="line">    private MethodBeforeAdvice advice;  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">    /**  </span><br><span class="line">     * Create a new MethodBeforeAdviceInterceptor for the given advice.  </span><br><span class="line">     * @param advice the MethodBeforeAdvice to wrap  </span><br><span class="line">     */  </span><br><span class="line">    public MethodBeforeAdviceInterceptor(MethodBeforeAdvice advice) &#123;  </span><br><span class="line">        Assert.notNull(advice, &quot;Advice must not be null&quot;);  </span><br><span class="line">        this.advice = advice;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    //这个invoke方法是拦截器的回调方法,会在代理对象的方法被调用时触发回调  </span><br><span class="line">    @Override  </span><br><span class="line">    public Object invoke(MethodInvocation mi) throws Throwable &#123;  </span><br><span class="line">        //首先触发advise的before回调  </span><br><span class="line">        this.advice.before(mi.getMethod(), mi.getArguments(), mi.getThis() );  </span><br><span class="line">        //然后才是MethodInvocation的proceed方法调用  </span><br><span class="line">        return mi.proceed();  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>上面是MethodBeforeAdviceInterceptor拦截器的源码，MethodBeforeAdvice是对应的通知，另外还有一个角色类是MethodBeforeAdviceAdapter适配器类，这个适配器的源码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">class MethodBeforeAdviceAdapter implements AdvisorAdapter, Serializable &#123;  </span><br><span class="line">  </span><br><span class="line">    @Override  </span><br><span class="line">    public boolean supportsAdvice(Advice advice) &#123;  </span><br><span class="line">        return (advice instanceof MethodBeforeAdvice);  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    @Override  </span><br><span class="line">    public MethodInterceptor getInterceptor(Advisor advisor) &#123;  </span><br><span class="line">        MethodBeforeAdvice advice = (MethodBeforeAdvice) advisor.getAdvice();  </span><br><span class="line">        return new MethodBeforeAdviceInterceptor(advice);  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>可以看到，它的主要作用是，将通知advisor.getAdvice()转换或者说适配成对应的拦截器，有如下三种适配：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1. MethodBeforeAdviceAdapter将MethodBeforeAdvice适配成MethodBeforeAdviceInterceptor  </span><br><span class="line">2. AfterReturningAdviceAdapter将AfterReturningAdvice适配成AfterReturningAdviceInterceptor  </span><br><span class="line">3.ThrowsAdviceAdapter将ThrowsAdvice适配成ThrowsAdviceInterceptor</span><br></pre></td></tr></table></figure></p>
<p>这样适配的目的是什么呢？<br>还得回到我们最初的MethodBeforeAdviceInterceptor的源码中去看<br>首先我们得知道通知是什么，通知就是在调用目标方法之前或者之后等要被调用的增强的方法，比如这里的MethodBeforeAdvice的before方法需要在调用目标方法之前被调用，AfterReturningAdvice的afterReturning方法需要在目标方法被调用之后调用，这个调用逻辑（调用顺序）就是由通知对应的拦截器来完成的，可以看到MethodBeforeAdviceInterceptor由于是前置通知的适配器，所以它的invoke方法在执行下一个拦截器的时候先调用了通知的before方法，然后进入到了下一个拦截器。<br>也就是说，通知只是定义了增强时将要被调用的方法，而方法具体何时调用需要由通知对应的拦截器来进行管理，而适配器的作用就是根据通知得到其对应的拦截器<br>再可以看看AfterReturningAdviceInterceptor拦截器<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">public class AfterReturningAdviceInterceptor implements MethodInterceptor, AfterAdvice, Serializable &#123;  </span><br><span class="line">  </span><br><span class="line">    private final AfterReturningAdvice advice;  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">    /**  </span><br><span class="line">     * Create a new AfterReturningAdviceInterceptor for the given advice.  </span><br><span class="line">     * @param advice the AfterReturningAdvice to wrap  </span><br><span class="line">     */  </span><br><span class="line">    public AfterReturningAdviceInterceptor(AfterReturningAdvice advice) &#123;  </span><br><span class="line">        Assert.notNull(advice, &quot;Advice must not be null&quot;);  </span><br><span class="line">        this.advice = advice;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    @Override  </span><br><span class="line">    public Object invoke(MethodInvocation mi) throws Throwable &#123;  </span><br><span class="line">        Object retVal = mi.proceed();  </span><br><span class="line">        this.advice.afterReturning(retVal, mi.getMethod(), mi.getArguments(), mi.getThis());  </span><br><span class="line">        return retVal;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这个后置通知拦截器就是在先进入到下一个拦截器后，然后再调用的对应通知AfterReturningAdvice的afterReturning方法<br>所以我们可以看到，这几个拦截器实现的功能其实非常类似于动态代理设计模式里面实现了InvocationHandler接口的那个类，比如如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">public class ProxyHandler implements InvocationHandler &#123;  </span><br><span class="line">  </span><br><span class="line">    private Object target;  </span><br><span class="line">  </span><br><span class="line">    public ProxyHandler(Object target) &#123;  </span><br><span class="line">        this.target = target;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123;  </span><br><span class="line">  </span><br><span class="line">        System.out.println(&quot;call before target&quot;);  </span><br><span class="line">  </span><br><span class="line">        Object proxyObject = method.invoke(target, args);   //这里是要调用目标对象target的目标方法method  </span><br><span class="line">  </span><br><span class="line">        System.out.println(&quot;call after target&quot;);  </span><br><span class="line">  </span><br><span class="line">        return proxyObject;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这里目标target的方法被调用前，会被这个类的invoke方法拦截，method.invoke(target, args) 是调用目标方法，这里可以在其前后做一些增强方法</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://denglinjie.com/2017/09/08/2017-09-08-Spring源码分析之lazy-init属性的配置/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="jasonjie">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="jasonjie">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/09/08/2017-09-08-Spring源码分析之lazy-init属性的配置/" itemprop="url">Spring源码分析之lazy-init属性的配置</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-09-08T00:00:00+08:00">
                2017-09-08
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/Java开发/" itemprop="url" rel="index">
                    <span itemprop="name">Java开发</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>tags:</p>
<pre><code>- Spring
- Java
- Linux
</code></pre><hr>
<p>AbstractApplicationContext类默认在容器初始化的过程中就会执行依赖注入，即等价于配置lazy-init属性为false，bean的配置如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;</span><br><span class="line">       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span><br><span class="line">       xmlns:context=&quot;http://www.springframework.org/schema/context&quot;</span><br><span class="line">       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans</span><br><span class="line">        http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd&quot;&gt;</span><br><span class="line"></span><br><span class="line">    &lt;bean id=&quot;studentService&quot; class=&quot;com.verify.constant.StudentService&quot; init-method=&quot;initMethod&quot; lazy-init=&quot;false&quot;/&gt;</span><br><span class="line">&lt;/beans&gt;</span><br></pre></td></tr></table></figure></p>
<p>容器的初始化是在AbstractApplicationContext的refresh()方法中执行的，如下代码对lazy-init进行了处理：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">finishBeanFactoryInitialization(beanFactory);</span><br></pre></td></tr></table></figure></p>
<p>跟踪下去可以找到真正的读取lazy-init属性进行懒加载相关处理的地方<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">	public void preInstantiateSingletons() throws BeansException &#123;</span><br><span class="line">		if (this.logger.isDebugEnabled()) &#123;</span><br><span class="line">			this.logger.debug(&quot;Pre-instantiating singletons in &quot; + this);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		// Iterate over a copy to allow for init methods which in turn register new bean definitions.</span><br><span class="line">		// While this may not be part of the regular factory bootstrap, it does otherwise work fine.</span><br><span class="line">		List&lt;String&gt; beanNames = new ArrayList&lt;String&gt;(this.beanDefinitionNames);</span><br><span class="line"></span><br><span class="line">		// Trigger initialization of all non-lazy singleton beans...</span><br><span class="line">		for (String beanName : beanNames) &#123;</span><br><span class="line">			RootBeanDefinition bd = getMergedLocalBeanDefinition(beanName);</span><br><span class="line">			if (!bd.isAbstract() &amp;&amp; bd.isSingleton() &amp;&amp; !bd.isLazyInit()) &#123;</span><br><span class="line">				if (isFactoryBean(beanName)) &#123;</span><br><span class="line">					final FactoryBean&lt;?&gt; factory = (FactoryBean&lt;?&gt;) getBean(FACTORY_BEAN_PREFIX + beanName);</span><br><span class="line">					boolean isEagerInit;</span><br><span class="line">					if (System.getSecurityManager() != null &amp;&amp; factory instanceof SmartFactoryBean) &#123;</span><br><span class="line">						isEagerInit = AccessController.doPrivileged(new PrivilegedAction&lt;Boolean&gt;() &#123;</span><br><span class="line">							@Override</span><br><span class="line">							public Boolean run() &#123;</span><br><span class="line">								return ((SmartFactoryBean&lt;?&gt;) factory).isEagerInit();</span><br><span class="line">							&#125;</span><br><span class="line">						&#125;, getAccessControlContext());</span><br><span class="line">					&#125;</span><br><span class="line">					else &#123;</span><br><span class="line">						isEagerInit = (factory instanceof SmartFactoryBean &amp;&amp;</span><br><span class="line">								((SmartFactoryBean&lt;?&gt;) factory).isEagerInit());</span><br><span class="line">					&#125;</span><br><span class="line">					if (isEagerInit) &#123;</span><br><span class="line">						getBean(beanName);</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">				else &#123;</span><br><span class="line">					getBean(beanName);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		// Trigger post-initialization callback for all applicable beans...</span><br><span class="line">		for (String beanName : beanNames) &#123;</span><br><span class="line">			Object singletonInstance = getSingleton(beanName);</span><br><span class="line">			if (singletonInstance instanceof SmartInitializingSingleton) &#123;</span><br><span class="line">				final SmartInitializingSingleton smartSingleton = (SmartInitializingSingleton) singletonInstance;</span><br><span class="line">				if (System.getSecurityManager() != null) &#123;</span><br><span class="line">					AccessController.doPrivileged(new PrivilegedAction&lt;Object&gt;() &#123;</span><br><span class="line">						@Override</span><br><span class="line">						public Object run() &#123;</span><br><span class="line">							smartSingleton.afterSingletonsInstantiated();</span><br><span class="line">							return null;</span><br><span class="line">						&#125;</span><br><span class="line">					&#125;, getAccessControlContext());</span><br><span class="line">				&#125;</span><br><span class="line">				else &#123;</span><br><span class="line">					smartSingleton.afterSingletonsInstantiated();</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure></p>
<p>可以看到代码中对所有注册的bean，即this.beanDefinitionNames，对于每个bean都会做如下判断，如果成立就会执行依赖注入：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">if (!bd.isAbstract() &amp;&amp; bd.isSingleton() &amp;&amp; !bd.isLazyInit())</span><br></pre></td></tr></table></figure></p>
<p>可以看出，只有单例的bean才有可能在容器初始化的时候就完成依赖注入，当lazy-init属性不配置(默认值)或者配置为false的时候，上述if就会成立，当然这里默认不配置abstract属性，所以它默认也是false。if成立，就会执行getBean从而进行依赖注入，这样在容器初始化的过程中就已经实例化了Bean，当真正的请求bean的时候，其实只是从缓存中读取而已。<br>而如果lazy-init属性配置为true，那么就会进行懒加载了，这样在容器初始化的过程中不会进行依赖注入，只有当第一个getBean的时候才会实例化Bean。<br>最后抛出一个我还没有搞明白的问题：<br>书上说的是容器在初始化的过程中默认情况下其实并没有发生依赖注入，而是在第一次getBean的时候才会进行依赖注入，但是这个说法与上述AbstractApplicationContext的容器初始化过程好像是不一致的？还是说AbstractApplicationContext默认是进行依赖注入，但是BeanFactory默认不进行依赖注入？</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://denglinjie.com/2017/09/08/2017-09-08-Spring IOC学习心得之Bean对IOC容器的感知/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="jasonjie">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="jasonjie">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/09/08/2017-09-08-Spring IOC学习心得之Bean对IOC容器的感知/" itemprop="url">Spring IOC学习心得之Bean对IOC容器的感知</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-09-08T00:00:00+08:00">
                2017-09-08
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/Java开发/" itemprop="url" rel="index">
                    <span itemprop="name">Java开发</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>tags:</p>
<pre><code>- Spring
- Java
- Linux
</code></pre><hr>
<p>容器管理的Bean一般不需要了解容器的状态和直接使用Bean，但是在某些情况下，是需要在Bean中直接对IOC容器进行操作的，这时候，就需要在Bean中设定对容器的感知。Spring IOC也提供了该功能，它是通过特定的aware接口来完成的。aware接口有如下这些：<br>BeanNameAware：可以在Bean中得到它在IOC容器中的Bean的实例名称<br>BeanFactoryAware：可以在Bean中得到Bean所在的IOC容器，从而直接在Bean中使用IOC容器的服务<br>ApplicationContextAware：可以在Bean中得到Bean所在的应用上下文，从而直接在Bean中使用应用上下文的服务<br>MessageSourceAware：在Bean中可以得到消息源<br>ApplicationEventPublisherAware：在Bean中可以得到应用上下文的事件发布器，从而可以在Bean中发布应用上下文的事件<br>ResourceLoaderAware：在Bean中可以得到resourceloader，从而在Bean中使用ResourceLoader加载外部对应的Resource资源<br>要在自定义的Bean中获取上述资源，只需要让Bean实现对应的接口，并覆写set方法，如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public class TestSpring implements ApplicationContextAware&#123;  </span><br><span class="line">    private ApplicationContext applicationContext;  </span><br><span class="line">  </span><br><span class="line">    @Override  </span><br><span class="line">    public void setApplicationContext(ApplicationContext applicationContext) throws BeansException &#123;  </span><br><span class="line">        this.applicationContext = applicationContext;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这样这个Bean实现了ApplicationContextAware接口，并覆写setApplicationContext方法，就可以获取到ApplicationContext对象。<br>这个setApplicationContext方法的回调是容器自动完成的，容器调用该方法的时候，我们就可以将容器传入的参数applicationContext保存起来以供使用<br>setApplicationContext方法被容器的自动调用是在BeanPostProcessor接口的方法postProcessBeforeInitialization中完成的，实现是在ApplicationContextAwareProcessor类中，具体代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line">class ApplicationContextAwareProcessor implements BeanPostProcessor &#123;  </span><br><span class="line">  </span><br><span class="line">    private final ConfigurableApplicationContext applicationContext;  </span><br><span class="line">  </span><br><span class="line">    private final StringValueResolver embeddedValueResolver;  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">    /**  </span><br><span class="line">     * Create a new ApplicationContextAwareProcessor for the given context.  </span><br><span class="line">     */  </span><br><span class="line">    public ApplicationContextAwareProcessor(ConfigurableApplicationContext applicationContext) &#123;  </span><br><span class="line">        this.applicationContext = applicationContext;  </span><br><span class="line">        this.embeddedValueResolver = new EmbeddedValueResolver(applicationContext.getBeanFactory());  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">    @Override  </span><br><span class="line">    public Object postProcessBeforeInitialization(final Object bean, String beanName) throws BeansException &#123;  </span><br><span class="line">        AccessControlContext acc = null;  </span><br><span class="line">  </span><br><span class="line">        if (System.getSecurityManager() != null &amp;&amp;  </span><br><span class="line">                (bean instanceof EnvironmentAware || bean instanceof EmbeddedValueResolverAware ||  </span><br><span class="line">                        bean instanceof ResourceLoaderAware || bean instanceof ApplicationEventPublisherAware ||  </span><br><span class="line">                        bean instanceof MessageSourceAware || bean instanceof ApplicationContextAware)) &#123;  </span><br><span class="line">            acc = this.applicationContext.getBeanFactory().getAccessControlContext();  </span><br><span class="line">        &#125;  </span><br><span class="line">  </span><br><span class="line">        if (acc != null) &#123;  </span><br><span class="line">            AccessController.doPrivileged(new PrivilegedAction&lt;Object&gt;() &#123;  </span><br><span class="line">                @Override  </span><br><span class="line">                public Object run() &#123;  </span><br><span class="line">                    invokeAwareInterfaces(bean);  </span><br><span class="line">                    return null;  </span><br><span class="line">                &#125;  </span><br><span class="line">            &#125;, acc);  </span><br><span class="line">        &#125;  </span><br><span class="line">        else &#123;  </span><br><span class="line">            invokeAwareInterfaces(bean);  </span><br><span class="line">        &#125;  </span><br><span class="line">  </span><br><span class="line">        return bean;  </span><br><span class="line">    &#125;  </span><br><span class="line">//这里就是容器自动调用set方法的地方，其实就是调用自定义的TestSpring类实现的setApplicationContext方法，这样TestSpring类就获取到了applicationContext  </span><br><span class="line">    private void invokeAwareInterfaces(Object bean) &#123;  </span><br><span class="line">        if (bean instanceof Aware) &#123;  </span><br><span class="line">            if (bean instanceof EnvironmentAware) &#123;  </span><br><span class="line">                ((EnvironmentAware) bean).setEnvironment(this.applicationContext.getEnvironment());  </span><br><span class="line">            &#125;  </span><br><span class="line">            if (bean instanceof EmbeddedValueResolverAware) &#123;  </span><br><span class="line">                ((EmbeddedValueResolverAware) bean).setEmbeddedValueResolver(this.embeddedValueResolver);  </span><br><span class="line">            &#125;  </span><br><span class="line">            if (bean instanceof ResourceLoaderAware) &#123;  </span><br><span class="line">                ((ResourceLoaderAware) bean).setResourceLoader(this.applicationContext);  </span><br><span class="line">            &#125;  </span><br><span class="line">            if (bean instanceof ApplicationEventPublisherAware) &#123;  </span><br><span class="line">                ((ApplicationEventPublisherAware) bean).setApplicationEventPublisher(this.applicationContext);  </span><br><span class="line">            &#125;  </span><br><span class="line">            if (bean instanceof MessageSourceAware) &#123;  </span><br><span class="line">                ((MessageSourceAware) bean).setMessageSource(this.applicationContext);  </span><br><span class="line">            &#125;  </span><br><span class="line">            if (bean instanceof ApplicationContextAware) &#123;  </span><br><span class="line">                ((ApplicationContextAware) bean).setApplicationContext(this.applicationContext);  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    @Override  </span><br><span class="line">    public Object postProcessAfterInitialization(Object bean, String beanName) &#123;  </span><br><span class="line">        return bean;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://denglinjie.com/2017/09/08/2017-09-08-Spring源码分析之BeanPostProcessor接口和BeanFactoryPostProcessor接口方法不执行原因分析/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="jasonjie">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="jasonjie">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/09/08/2017-09-08-Spring源码分析之BeanPostProcessor接口和BeanFactoryPostProcessor接口方法不执行原因分析/" itemprop="url">Spring源码分析之BeanPostProcessor接口和BeanFactoryPostProcessor接口方法不执行原因分析</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-09-08T00:00:00+08:00">
                2017-09-08
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/Java开发/" itemprop="url" rel="index">
                    <span itemprop="name">Java开发</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>tags:</p>
<pre><code>- Spring
- Java
- Linux
</code></pre><hr>
<p>首先下面是我的Bean<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line"> * Copyright 2002-2017 the original author or authors.</span><br><span class="line"> *</span><br><span class="line"> * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);</span><br><span class="line"> * you may not use this file except in compliance with the License.</span><br><span class="line"> * You may obtain a copy of the License at</span><br><span class="line"> *</span><br><span class="line"> *      http://www.apache.org/licenses/LICENSE-2.0</span><br><span class="line"> *</span><br><span class="line"> * Unless required by applicable law or agreed to in writing, software</span><br><span class="line"> * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,</span><br><span class="line"> * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.</span><br><span class="line"> * See the License for the specific language governing permissions and</span><br><span class="line"> * limitations under the License.</span><br><span class="line"> */</span><br><span class="line">package com.verify.constant;</span><br><span class="line"></span><br><span class="line">import org.springframework.beans.BeansException;</span><br><span class="line">import org.springframework.beans.PropertyValues;</span><br><span class="line">import org.springframework.beans.factory.*;</span><br><span class="line">import org.springframework.beans.factory.config.BeanFactoryPostProcessor;</span><br><span class="line">import org.springframework.beans.factory.config.BeanPostProcessor;</span><br><span class="line">import org.springframework.beans.factory.config.ConfigurableListableBeanFactory;</span><br><span class="line">import org.springframework.beans.factory.config.InstantiationAwareBeanPostProcessor;</span><br><span class="line"></span><br><span class="line">import java.beans.PropertyDescriptor;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * TODO</span><br><span class="line"> *</span><br><span class="line"> * @author linjiedeng</span><br><span class="line"> * @date 17/5/8 下午10:47</span><br><span class="line"> * @since TODO</span><br><span class="line"> */</span><br><span class="line">public class StudentService implements BeanPostProcessor, InitializingBean, BeanFactoryPostProcessor, BeanNameAware, BeanClassLoaderAware, BeanFactoryAware &#123;</span><br><span class="line"></span><br><span class="line">    private ClassLoader classLoader;</span><br><span class="line"></span><br><span class="line">    private BeanFactory beanFactory;</span><br><span class="line"></span><br><span class="line">    private String name;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void setBeanClassLoader(ClassLoader classLoader) &#123;</span><br><span class="line">        this.classLoader = classLoader; //实现BeanClassLoaderAware接口可以获取到对应的classLoader</span><br><span class="line">        System.out.println(&quot;set bean class loader&quot;);</span><br><span class="line">        System.out.println(classLoader);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void setBeanFactory(BeanFactory beanFactory) throws BeansException &#123;</span><br><span class="line">        this.beanFactory = beanFactory; //实现BeanFactoryAware接口获取该Bean的beanFactory</span><br><span class="line">        System.out.println(&quot;set bean factory&quot;);</span><br><span class="line">        System.out.println(beanFactory);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void setBeanName(String name) &#123;</span><br><span class="line">        this.name = name;   //实现BeanNameAware接口获取该Bean的名字</span><br><span class="line">        System.out.println(&quot;set bean name&quot;);</span><br><span class="line">        System.out.println(name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void initMethod() &#123;</span><br><span class="line">        System.out.println(&quot;init method&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void afterPropertiesSet() throws Exception &#123;</span><br><span class="line">        System.out.println(&quot;afterPropertiesSet&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public Object postProcessBeforeInitialization(Object bean, String beanName) throws BeansException &#123;</span><br><span class="line">        System.out.println(&quot;postProcessBeforeInitialization&quot;);</span><br><span class="line">        return bean;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public Object postProcessAfterInitialization(Object bean, String beanName) throws BeansException &#123;</span><br><span class="line">        System.out.println(&quot;postProcessAfterInitialization&quot;);</span><br><span class="line">        return bean;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void postProcessBeanFactory(ConfigurableListableBeanFactory beanFactory) throws BeansException &#123;</span><br><span class="line">        System.out.println(&quot;postProcessBeanFactory&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void read() &#123;</span><br><span class="line">        System.out.println(&quot;Student service read&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>bean的配置文件applicationContext.xml内容如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;</span><br><span class="line">       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span><br><span class="line">       xmlns:context=&quot;http://www.springframework.org/schema/context&quot;</span><br><span class="line">       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans</span><br><span class="line">        http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd&quot;&gt;</span><br><span class="line"></span><br><span class="line">    &lt;bean id=&quot;studentService&quot; class=&quot;com.verify.constant.StudentService&quot; init-method=&quot;initMethod&quot;/&gt;</span><br><span class="line">&lt;/beans&gt;</span><br></pre></td></tr></table></figure></p>
<p>测试代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">@Test</span><br><span class="line">    public void test2() &#123;</span><br><span class="line">        ClassPathResource resource = new ClassPathResource(&quot;applicationContext.xml&quot;);</span><br><span class="line">        DefaultListableBeanFactory factory = new DefaultListableBeanFactory();</span><br><span class="line">        XmlBeanDefinitionReader reader = new XmlBeanDefinitionReader(factory);</span><br><span class="line">        reader.loadBeanDefinitions(resource);</span><br><span class="line">        StudentService studentService = (StudentService)factory.getBean(&quot;studentService&quot;);</span><br><span class="line">        studentService.read();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>测试代码执行后，其他方法都执行了，但是唯独BeanPostProcessor接口的两个方法postProcessBeforeInitialization和postProcessAfterInitialization以及<br>BeanFactoryPostProcessor接口的方法没有执行，这我就有点疑惑了，这是咋回事？其实这两个接口应该是在bean初始化的过程中被调用，是在AbstractAutowireCapableBeanFactory接口的initializeBean初始化方法中被调用的，代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">protected Object initializeBean(final String beanName, final Object bean, RootBeanDefinition mbd) &#123;</span><br><span class="line">		if (System.getSecurityManager() != null) &#123;</span><br><span class="line">			AccessController.doPrivileged(new PrivilegedAction&lt;Object&gt;() &#123;</span><br><span class="line">				@Override</span><br><span class="line">				public Object run() &#123;</span><br><span class="line">					invokeAwareMethods(beanName, bean);</span><br><span class="line">					return null;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;, getAccessControlContext());</span><br><span class="line">		&#125;</span><br><span class="line">		else &#123;</span><br><span class="line">			invokeAwareMethods(beanName, bean);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		Object wrappedBean = bean;</span><br><span class="line">		if (mbd == null || !mbd.isSynthetic()) &#123;</span><br><span class="line">			//执行BeanPostProcessor扩展点的PostProcessBeforeInitialization进行修改实例化Bean</span><br><span class="line">			wrappedBean = applyBeanPostProcessorsBeforeInitialization(wrappedBean, beanName);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		try &#123;</span><br><span class="line">			//调用Bean的初始化方法,这个初始化方法是在BeanDefinition中通过定义init-method属性指定的</span><br><span class="line">			//同时,如果Bean实现了InitializingBean接口,那么这个Bean的afterPropertiesSet实现也不会被调用</span><br><span class="line">			invokeInitMethods(beanName, wrappedBean, mbd);</span><br><span class="line">		&#125;</span><br><span class="line">		catch (Throwable ex) &#123;</span><br><span class="line">			throw new BeanCreationException(</span><br><span class="line">					(mbd != null ? mbd.getResourceDescription() : null),</span><br><span class="line">					beanName, &quot;Invocation of init method failed&quot;, ex);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		if (mbd == null || !mbd.isSynthetic()) &#123;</span><br><span class="line">			//执行BeanPostProcessor扩展点的PostProcessAfterInitialization进行修改实例化Bean</span><br><span class="line">			wrappedBean = applyBeanPostProcessorsAfterInitialization(wrappedBean, beanName);</span><br><span class="line">		&#125;</span><br><span class="line">		return wrappedBean;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure></p>
<p>initializeBean方法是Bean的初始化方法，在该初始化方法中会调用Bean的一些初始化方法，比如如下方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">private void invokeAwareMethods(final String beanName, final Object bean) &#123;</span><br><span class="line">		if (bean instanceof Aware) &#123;</span><br><span class="line">			if (bean instanceof BeanNameAware) &#123;</span><br><span class="line">				((BeanNameAware) bean).setBeanName(beanName);</span><br><span class="line">			&#125;</span><br><span class="line">			if (bean instanceof BeanClassLoaderAware) &#123;</span><br><span class="line">				((BeanClassLoaderAware) bean).setBeanClassLoader(getBeanClassLoader());</span><br><span class="line">			&#125;</span><br><span class="line">			if (bean instanceof BeanFactoryAware) &#123;</span><br><span class="line">				((BeanFactoryAware) bean).setBeanFactory(AbstractAutowireCapableBeanFactory.this);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure></p>
<p>即只要Bean实现了BeanNameAware接口，这里就会帮你调用，BeanClassLoaderAware和BeanFactory接口同样如此，上述我的代码中就实现了这三个接口，启动的过程中都被调用了，再实现的方法中可以获取这些信息，并存储。<br>再比如如下方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public Object applyBeanPostProcessorsBeforeInitialization(Object existingBean, String beanName)</span><br><span class="line">			throws BeansException &#123;</span><br><span class="line"></span><br><span class="line">		Object result = existingBean;</span><br><span class="line">		for (BeanPostProcessor beanProcessor : getBeanPostProcessors()) &#123;</span><br><span class="line">			result = beanProcessor.postProcessBeforeInitialization(result, beanName);</span><br><span class="line">			if (result == null) &#123;</span><br><span class="line">				return result;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		return result;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure></p>
<p>这里其实是如果Bean实现了BeanPostProcessor接口，这里就会调用bean实现的postProcessBeforeInitialization方法，这是在bean的真正初始化之前被调用<br>对应的BeanPostProcessor接口的另外一个方法，是在bean的初始化之后被调用，如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public Object applyBeanPostProcessorsAfterInitialization(Object existingBean, String beanName)</span><br><span class="line">			throws BeansException &#123;</span><br><span class="line"></span><br><span class="line">		Object result = existingBean;</span><br><span class="line">		for (BeanPostProcessor beanProcessor : getBeanPostProcessors()) &#123;</span><br><span class="line">			result = beanProcessor.postProcessAfterInitialization(result, beanName);</span><br><span class="line">			if (result == null) &#123;</span><br><span class="line">				return result;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		return result;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure></p>
<p>真正的初始化是在如下方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">protected void invokeInitMethods(String beanName, final Object bean, RootBeanDefinition mbd)</span><br><span class="line">			throws Throwable &#123;</span><br><span class="line"></span><br><span class="line">		boolean isInitializingBean = (bean instanceof InitializingBean);</span><br><span class="line">		if (isInitializingBean &amp;&amp; (mbd == null || !mbd.isExternallyManagedInitMethod(&quot;afterPropertiesSet&quot;))) &#123;</span><br><span class="line">			if (logger.isDebugEnabled()) &#123;</span><br><span class="line">				logger.debug(&quot;Invoking afterPropertiesSet() on bean with name &apos;&quot; + beanName + &quot;&apos;&quot;);</span><br><span class="line">			&#125;</span><br><span class="line">			if (System.getSecurityManager() != null) &#123;</span><br><span class="line">				try &#123;</span><br><span class="line">					AccessController.doPrivileged(new PrivilegedExceptionAction&lt;Object&gt;() &#123;</span><br><span class="line">						@Override</span><br><span class="line">						public Object run() throws Exception &#123;</span><br><span class="line">							((InitializingBean) bean).afterPropertiesSet();</span><br><span class="line">							return null;</span><br><span class="line">						&#125;</span><br><span class="line">					&#125;, getAccessControlContext());</span><br><span class="line">				&#125;</span><br><span class="line">				catch (PrivilegedActionException pae) &#123;</span><br><span class="line">					throw pae.getException();</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			else &#123;</span><br><span class="line">				((InitializingBean) bean).afterPropertiesSet();	//启动afterPropertiesSet,afterPropertiesSet是InitializingBean接口的方法</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		if (mbd != null) &#123;</span><br><span class="line">			String initMethodName = mbd.getInitMethodName();	//获取用户自定义的初始化方法</span><br><span class="line">			if (initMethodName != null &amp;&amp; !(isInitializingBean &amp;&amp; &quot;afterPropertiesSet&quot;.equals(initMethodName)) &amp;&amp;</span><br><span class="line">					!mbd.isExternallyManagedInitMethod(initMethodName)) &#123;</span><br><span class="line">				invokeCustomInitMethod(beanName, bean, mbd);	//调用自定义的初始化方法</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure></p>
<p>可以看到，上述代码实际上是在调用Bean实现的initializingBean接口的afterPropertiesSet方法来初始化Bean，接下来还调用了用户自定义的init-method方法，可以看到上面我的applicationContext.xml配置文件中配置的有一个initMethod方法，这就是自定义的初始化方法，这个方法也是在这里被调用的</p>
<p>好，代码分析到这，也可以看到了，既然这里初始化的时候调用了BeanPostProcessor的那两个方法，但是我的测试代码为什么没有执行这两个方法呢？<br>其实可以看到真正执行BeanPostProcessor接口的代码是如下代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public Object applyBeanPostProcessorsBeforeInitialization(Object existingBean, String beanName)</span><br><span class="line">			throws BeansException &#123;</span><br><span class="line"></span><br><span class="line">		Object result = existingBean;</span><br><span class="line">		for (BeanPostProcessor beanProcessor : getBeanPostProcessors()) &#123;</span><br><span class="line">			result = beanProcessor.postProcessBeforeInitialization(result, beanName);</span><br><span class="line">			if (result == null) &#123;</span><br><span class="line">				return result;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		return result;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure></p>
<p>其中的getBeanPostProcessors()方法获取的实际就是AbstractBeanFactory的this.beanPostProcessors属性值，看来是这个属性值为空，所以执行的时候没有调用<br>那接下来要分析的原因就是为什么this.beanPostProcessors属性值为空呢？或者说bean的载入时为什么没有载入进来呢？那就要看它是在哪里载入的了，最终定位到载入是在<br>AbstractApplicationContext中执行的<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">	public void refresh() throws BeansException, IllegalStateException &#123;</span><br><span class="line">		synchronized (this.startupShutdownMonitor) &#123;</span><br><span class="line">			// Prepare this context for refreshing.</span><br><span class="line">			prepareRefresh();</span><br><span class="line"></span><br><span class="line">			//这是在子类中启动refreshBeanFactory的地方</span><br><span class="line">			// Tell the subclass to refresh the internal bean factory.</span><br><span class="line">			ConfigurableListableBeanFactory beanFactory = obtainFreshBeanFactory();</span><br><span class="line"></span><br><span class="line">			// Prepare the bean factory for use in this context.</span><br><span class="line">			prepareBeanFactory(beanFactory);</span><br><span class="line"></span><br><span class="line">			try &#123;</span><br><span class="line">				// Allows post-processing of the bean factory in context subclasses.</span><br><span class="line">				// 设置BeanFactory的后置处理</span><br><span class="line">				postProcessBeanFactory(beanFactory);</span><br><span class="line"></span><br><span class="line">				// Invoke factory processors registered as beans in the context.</span><br><span class="line">				// 调用BeanFactory的后处理器,这些后处理器是在Bean定义中向容器注册的</span><br><span class="line">				invokeBeanFactoryPostProcessors(beanFactory);</span><br><span class="line"></span><br><span class="line">				// Register bean processors that intercept bean creation.</span><br><span class="line">				// 注册Bean的后处理器,在Bean创建过程中调用</span><br><span class="line">				registerBeanPostProcessors(beanFactory);</span><br><span class="line"></span><br><span class="line">				// Initialize message source for this context.</span><br><span class="line">				// 对上下文中的消息源进行初始化</span><br><span class="line">				initMessageSource();</span><br><span class="line"></span><br><span class="line">				// Initialize event multicaster for this context.</span><br><span class="line">				// 初始化上下文中的事件机制</span><br><span class="line">				initApplicationEventMulticaster();</span><br><span class="line"></span><br><span class="line">				// Initialize other special beans in specific context subclasses.</span><br><span class="line">				// 初始化其他的特殊Bean</span><br><span class="line">				onRefresh();</span><br><span class="line"></span><br><span class="line">				// Check for listener beans and register them.</span><br><span class="line">				// 检查监听Bean,并且将这些Bean向容器注册</span><br><span class="line">				registerListeners();</span><br><span class="line"></span><br><span class="line">				// Instantiate all remaining (non-lazy-init) singletons.这里是对lazy-init属性进行处理的地方</span><br><span class="line">				finishBeanFactoryInitialization(beanFactory);</span><br><span class="line"></span><br><span class="line">				// Last step: publish corresponding event.</span><br><span class="line">				// 发布容器事件,结束Refresh过程</span><br><span class="line">				finishRefresh();</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			catch (BeansException ex) &#123;</span><br><span class="line">				if (logger.isWarnEnabled()) &#123;</span><br><span class="line">					logger.warn(&quot;Exception encountered during context initialization - &quot; +</span><br><span class="line">							&quot;cancelling refresh attempt: &quot; + ex);</span><br><span class="line">				&#125;</span><br><span class="line"></span><br><span class="line">				// Destroy already created singletons to avoid dangling resources.</span><br><span class="line">				// 为防止Bean资环占用,在异常处理中,销毁已经在前面过程中生成的单件Bean</span><br><span class="line">				destroyBeans();</span><br><span class="line"></span><br><span class="line">				// Reset &apos;active&apos; flag.</span><br><span class="line">				cancelRefresh(ex);</span><br><span class="line"></span><br><span class="line">				// Propagate exception to caller.</span><br><span class="line">				throw ex;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			finally &#123;</span><br><span class="line">				// Reset common introspection caches in Spring&apos;s core, since we</span><br><span class="line">				// might not ever need metadata for singleton beans anymore...</span><br><span class="line">				resetCommonCaches();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure></p>
<p>registerBeanPostProcessors(beanFactory)是载入Bean实现的BeanPostProcessor接口，具体载入代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line">public static void registerBeanPostProcessors(</span><br><span class="line">			ConfigurableListableBeanFactory beanFactory, AbstractApplicationContext applicationContext) &#123;</span><br><span class="line"></span><br><span class="line">		String[] postProcessorNames = beanFactory.getBeanNamesForType(BeanPostProcessor.class, true, false);</span><br><span class="line"></span><br><span class="line">		// Register BeanPostProcessorChecker that logs an info message when</span><br><span class="line">		// a bean is created during BeanPostProcessor instantiation, i.e. when</span><br><span class="line">		// a bean is not eligible for getting processed by all BeanPostProcessors.</span><br><span class="line">		int beanProcessorTargetCount = beanFactory.getBeanPostProcessorCount() + 1 + postProcessorNames.length;</span><br><span class="line">		beanFactory.addBeanPostProcessor(new BeanPostProcessorChecker(beanFactory, beanProcessorTargetCount));</span><br><span class="line"></span><br><span class="line">		// Separate between BeanPostProcessors that implement PriorityOrdered,</span><br><span class="line">		// Ordered, and the rest.</span><br><span class="line">		List&lt;BeanPostProcessor&gt; priorityOrderedPostProcessors = new ArrayList&lt;&gt;();</span><br><span class="line">		List&lt;BeanPostProcessor&gt; internalPostProcessors = new ArrayList&lt;&gt;();</span><br><span class="line">		List&lt;String&gt; orderedPostProcessorNames = new ArrayList&lt;&gt;();</span><br><span class="line">		List&lt;String&gt; nonOrderedPostProcessorNames = new ArrayList&lt;&gt;();</span><br><span class="line">		for (String ppName : postProcessorNames) &#123;</span><br><span class="line">			if (beanFactory.isTypeMatch(ppName, PriorityOrdered.class)) &#123;</span><br><span class="line">				BeanPostProcessor pp = beanFactory.getBean(ppName, BeanPostProcessor.class);</span><br><span class="line">				priorityOrderedPostProcessors.add(pp);</span><br><span class="line">				if (pp instanceof MergedBeanDefinitionPostProcessor) &#123;</span><br><span class="line">					internalPostProcessors.add(pp);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			else if (beanFactory.isTypeMatch(ppName, Ordered.class)) &#123;</span><br><span class="line">				orderedPostProcessorNames.add(ppName);</span><br><span class="line">			&#125;</span><br><span class="line">			else &#123;</span><br><span class="line">				nonOrderedPostProcessorNames.add(ppName);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		// First, register the BeanPostProcessors that implement PriorityOrdered.</span><br><span class="line">		sortPostProcessors(beanFactory, priorityOrderedPostProcessors);</span><br><span class="line">		registerBeanPostProcessors(beanFactory, priorityOrderedPostProcessors);</span><br><span class="line"></span><br><span class="line">		// Next, register the BeanPostProcessors that implement Ordered.</span><br><span class="line">		List&lt;BeanPostProcessor&gt; orderedPostProcessors = new ArrayList&lt;&gt;();</span><br><span class="line">		for (String ppName : orderedPostProcessorNames) &#123;</span><br><span class="line">			BeanPostProcessor pp = beanFactory.getBean(ppName, BeanPostProcessor.class);</span><br><span class="line">			orderedPostProcessors.add(pp);</span><br><span class="line">			if (pp instanceof MergedBeanDefinitionPostProcessor) &#123;</span><br><span class="line">				internalPostProcessors.add(pp);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		sortPostProcessors(beanFactory, orderedPostProcessors);</span><br><span class="line">		registerBeanPostProcessors(beanFactory, orderedPostProcessors);</span><br><span class="line"></span><br><span class="line">		// Now, register all regular BeanPostProcessors.</span><br><span class="line">		List&lt;BeanPostProcessor&gt; nonOrderedPostProcessors = new ArrayList&lt;&gt;();</span><br><span class="line">		for (String ppName : nonOrderedPostProcessorNames) &#123;</span><br><span class="line">			BeanPostProcessor pp = beanFactory.getBean(ppName, BeanPostProcessor.class);</span><br><span class="line">			nonOrderedPostProcessors.add(pp);</span><br><span class="line">			if (pp instanceof MergedBeanDefinitionPostProcessor) &#123;</span><br><span class="line">				internalPostProcessors.add(pp);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		registerBeanPostProcessors(beanFactory, nonOrderedPostProcessors);</span><br><span class="line"></span><br><span class="line">		// Finally, re-register all internal BeanPostProcessors.</span><br><span class="line">		sortPostProcessors(beanFactory, internalPostProcessors);</span><br><span class="line">		registerBeanPostProcessors(beanFactory, internalPostProcessors);</span><br><span class="line"></span><br><span class="line">		beanFactory.addBeanPostProcessor(new ApplicationListenerDetector(applicationContext));</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure></p>
<p>invokeBeanFactoryPostProcessors(beanFactory)是载入Bean实现的BeanFactoryPostProcessor接口，具体载入如下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br></pre></td><td class="code"><pre><span class="line">public static void invokeBeanFactoryPostProcessors(</span><br><span class="line">			ConfigurableListableBeanFactory beanFactory, List&lt;BeanFactoryPostProcessor&gt; beanFactoryPostProcessors) &#123;</span><br><span class="line"></span><br><span class="line">		// Invoke BeanDefinitionRegistryPostProcessors first, if any.</span><br><span class="line">		Set&lt;String&gt; processedBeans = new HashSet&lt;&gt;();</span><br><span class="line"></span><br><span class="line">		if (beanFactory instanceof BeanDefinitionRegistry) &#123;</span><br><span class="line">			BeanDefinitionRegistry registry = (BeanDefinitionRegistry) beanFactory;</span><br><span class="line">			List&lt;BeanFactoryPostProcessor&gt; regularPostProcessors = new LinkedList&lt;&gt;();</span><br><span class="line">			List&lt;BeanDefinitionRegistryPostProcessor&gt; registryPostProcessors =</span><br><span class="line">					new LinkedList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">			for (BeanFactoryPostProcessor postProcessor : beanFactoryPostProcessors) &#123;</span><br><span class="line">				if (postProcessor instanceof BeanDefinitionRegistryPostProcessor) &#123;</span><br><span class="line">					BeanDefinitionRegistryPostProcessor registryPostProcessor =</span><br><span class="line">							(BeanDefinitionRegistryPostProcessor) postProcessor;</span><br><span class="line">					registryPostProcessor.postProcessBeanDefinitionRegistry(registry);</span><br><span class="line">					registryPostProcessors.add(registryPostProcessor);</span><br><span class="line">				&#125;</span><br><span class="line">				else &#123;</span><br><span class="line">					regularPostProcessors.add(postProcessor);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			// Do not initialize FactoryBeans here: We need to leave all regular beans</span><br><span class="line">			// uninitialized to let the bean factory post-processors apply to them!</span><br><span class="line">			// Separate between BeanDefinitionRegistryPostProcessors that implement</span><br><span class="line">			// PriorityOrdered, Ordered, and the rest.</span><br><span class="line">			String[] postProcessorNames =</span><br><span class="line">					beanFactory.getBeanNamesForType(BeanDefinitionRegistryPostProcessor.class, true, false);</span><br><span class="line"></span><br><span class="line">			// First, invoke the BeanDefinitionRegistryPostProcessors that implement PriorityOrdered.</span><br><span class="line">			List&lt;BeanDefinitionRegistryPostProcessor&gt; priorityOrderedPostProcessors = new ArrayList&lt;&gt;();</span><br><span class="line">			for (String ppName : postProcessorNames) &#123;</span><br><span class="line">				if (beanFactory.isTypeMatch(ppName, PriorityOrdered.class)) &#123;</span><br><span class="line">					priorityOrderedPostProcessors.add(beanFactory.getBean(ppName, BeanDefinitionRegistryPostProcessor.class));</span><br><span class="line">					processedBeans.add(ppName);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			sortPostProcessors(beanFactory, priorityOrderedPostProcessors);</span><br><span class="line">			registryPostProcessors.addAll(priorityOrderedPostProcessors);</span><br><span class="line">			invokeBeanDefinitionRegistryPostProcessors(priorityOrderedPostProcessors, registry);</span><br><span class="line"></span><br><span class="line">			// Next, invoke the BeanDefinitionRegistryPostProcessors that implement Ordered.</span><br><span class="line">			postProcessorNames = beanFactory.getBeanNamesForType(BeanDefinitionRegistryPostProcessor.class, true, false);</span><br><span class="line">			List&lt;BeanDefinitionRegistryPostProcessor&gt; orderedPostProcessors = new ArrayList&lt;&gt;();</span><br><span class="line">			for (String ppName : postProcessorNames) &#123;</span><br><span class="line">				if (!processedBeans.contains(ppName) &amp;&amp; beanFactory.isTypeMatch(ppName, Ordered.class)) &#123;</span><br><span class="line">					orderedPostProcessors.add(beanFactory.getBean(ppName, BeanDefinitionRegistryPostProcessor.class));</span><br><span class="line">					processedBeans.add(ppName);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			sortPostProcessors(beanFactory, orderedPostProcessors);</span><br><span class="line">			registryPostProcessors.addAll(orderedPostProcessors);</span><br><span class="line">			invokeBeanDefinitionRegistryPostProcessors(orderedPostProcessors, registry);</span><br><span class="line"></span><br><span class="line">			// Finally, invoke all other BeanDefinitionRegistryPostProcessors until no further ones appear.</span><br><span class="line">			boolean reiterate = true;</span><br><span class="line">			while (reiterate) &#123;</span><br><span class="line">				reiterate = false;</span><br><span class="line">				postProcessorNames = beanFactory.getBeanNamesForType(BeanDefinitionRegistryPostProcessor.class, true, false);</span><br><span class="line">				for (String ppName : postProcessorNames) &#123;</span><br><span class="line">					if (!processedBeans.contains(ppName)) &#123;</span><br><span class="line">						BeanDefinitionRegistryPostProcessor pp = beanFactory.getBean(ppName, BeanDefinitionRegistryPostProcessor.class);</span><br><span class="line">						registryPostProcessors.add(pp);</span><br><span class="line">						processedBeans.add(ppName);</span><br><span class="line">						pp.postProcessBeanDefinitionRegistry(registry);</span><br><span class="line">						reiterate = true;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			// Now, invoke the postProcessBeanFactory callback of all processors handled so far.</span><br><span class="line">			invokeBeanFactoryPostProcessors(registryPostProcessors, beanFactory);</span><br><span class="line">			invokeBeanFactoryPostProcessors(regularPostProcessors, beanFactory);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		else &#123;</span><br><span class="line">			// Invoke factory processors registered with the context instance.</span><br><span class="line">			invokeBeanFactoryPostProcessors(beanFactoryPostProcessors, beanFactory);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		// Do not initialize FactoryBeans here: We need to leave all regular beans</span><br><span class="line">		// uninitialized to let the bean factory post-processors apply to them!</span><br><span class="line">		String[] postProcessorNames =</span><br><span class="line">				beanFactory.getBeanNamesForType(BeanFactoryPostProcessor.class, true, false);</span><br><span class="line"></span><br><span class="line">		// Separate between BeanFactoryPostProcessors that implement PriorityOrdered,</span><br><span class="line">		// Ordered, and the rest.</span><br><span class="line">		List&lt;BeanFactoryPostProcessor&gt; priorityOrderedPostProcessors = new ArrayList&lt;&gt;();</span><br><span class="line">		List&lt;String&gt; orderedPostProcessorNames = new ArrayList&lt;&gt;();</span><br><span class="line">		List&lt;String&gt; nonOrderedPostProcessorNames = new ArrayList&lt;&gt;();</span><br><span class="line">		for (String ppName : postProcessorNames) &#123;</span><br><span class="line">			if (processedBeans.contains(ppName)) &#123;</span><br><span class="line">				// skip - already processed in first phase above</span><br><span class="line">			&#125;</span><br><span class="line">			else if (beanFactory.isTypeMatch(ppName, PriorityOrdered.class)) &#123;</span><br><span class="line">				priorityOrderedPostProcessors.add(beanFactory.getBean(ppName, BeanFactoryPostProcessor.class));</span><br><span class="line">			&#125;</span><br><span class="line">			else if (beanFactory.isTypeMatch(ppName, Ordered.class)) &#123;</span><br><span class="line">				orderedPostProcessorNames.add(ppName);</span><br><span class="line">			&#125;</span><br><span class="line">			else &#123;</span><br><span class="line">				nonOrderedPostProcessorNames.add(ppName);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		// First, invoke the BeanFactoryPostProcessors that implement PriorityOrdered.</span><br><span class="line">		sortPostProcessors(beanFactory, priorityOrderedPostProcessors);</span><br><span class="line">		invokeBeanFactoryPostProcessors(priorityOrderedPostProcessors, beanFactory);</span><br><span class="line"></span><br><span class="line">		// Next, invoke the BeanFactoryPostProcessors that implement Ordered.</span><br><span class="line">		List&lt;BeanFactoryPostProcessor&gt; orderedPostProcessors = new ArrayList&lt;&gt;();</span><br><span class="line">		for (String postProcessorName : orderedPostProcessorNames) &#123;</span><br><span class="line">			orderedPostProcessors.add(beanFactory.getBean(postProcessorName, BeanFactoryPostProcessor.class));</span><br><span class="line">		&#125;</span><br><span class="line">		sortPostProcessors(beanFactory, orderedPostProcessors);</span><br><span class="line">		invokeBeanFactoryPostProcessors(orderedPostProcessors, beanFactory);</span><br><span class="line"></span><br><span class="line">		// Finally, invoke all other BeanFactoryPostProcessors.</span><br><span class="line">		List&lt;BeanFactoryPostProcessor&gt; nonOrderedPostProcessors = new ArrayList&lt;&gt;();</span><br><span class="line">		for (String postProcessorName : nonOrderedPostProcessorNames) &#123;</span><br><span class="line">			nonOrderedPostProcessors.add(beanFactory.getBean(postProcessorName, BeanFactoryPostProcessor.class));</span><br><span class="line">		&#125;</span><br><span class="line">		invokeBeanFactoryPostProcessors(nonOrderedPostProcessors, beanFactory);</span><br><span class="line"></span><br><span class="line">		// Clear cached merged bean definitions since the post-processors might have</span><br><span class="line">		// modified the original metadata, e.g. replacing placeholders in values...</span><br><span class="line">		beanFactory.clearMetadataCache();</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure></p>
<p>所以我们可以看到BeanPostProcessor接口和BeanFactoryPostProcessor接口的载入只在abstractApplicationContext中执行了，而在DefaultListableBeanFactory<br>中没有执行，而我们测试用的工厂就是DefaultListableBeanFactory，所以实际是根本没有载入上面两个接口。<br>接下来我把测试代码换成如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@Test</span><br><span class="line">    public void test3() &#123;</span><br><span class="line">        ApplicationContext applicationContext = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;);</span><br><span class="line">        StudentService studentService = (StudentService)applicationContext.getBean(&quot;studentService&quot;);</span><br><span class="line">        studentService.read();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>然后执行，可以很清楚的看到那两个接口的方法都执行了。<br>原因是：ClassPathXmlApplicationContext是abstractApplicationContext的实现，所以使用这个工厂来管理bean，会载入如上两个接口。<br>总结：<br>其实我们两个测试代码分别使用了DefaultListableBeanFactory和ClassPathXmlApplicationContext作为Bean工厂，ClassPathXmlApplicationContext底层其实<br>也是使用的DefaultListableBeanFactory作为Bean工厂，但是ClassPathXmlApplicationContext在DefaultListableBeanFactory的基础上额外载入了<br>BeanPostProcessor接口和BeanFactoryPostProcessor接口，这个载入是在其父接口AbstractApplicationContext中执行的，这就是为什么test2测试代码不执行这两个接口的方法的原因。<br>此外，对于两个工厂而言，真正的在初始化的过程中调用这些接口的地方都是在底层工厂DefaultListableBeanFactory中,而DefaultListableBeanFactory<br>实际是调用的父接口AbstractAutowireCapableBeanFactory的initializeBean方法来进行初始化，从而调用那些初始化接口的方法</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://denglinjie.com/2017/09/08/2017-09-08-Spring IOC学习心得之BeanPostProcessor，BeanNameAware，BeanClassLoaderAware，BeanFactoryAware接口是如何起作用的/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="jasonjie">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="jasonjie">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/09/08/2017-09-08-Spring IOC学习心得之BeanPostProcessor，BeanNameAware，BeanClassLoaderAware，BeanFactoryAware接口是如何起作用的/" itemprop="url">Spring IOC学习心得之BeanPostProcessor，BeanNameAware，BeanClassLoaderAware，BeanFactoryAware接口是如何起作用的</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-09-08T00:00:00+08:00">
                2017-09-08
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/Java开发/" itemprop="url" rel="index">
                    <span itemprop="name">Java开发</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>tags:</p>
<pre><code>- Spring
- Java
- Linux
</code></pre><hr>
<ol>
<li>首先说下BeanPostProcessor接口中的两个方法，如下：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">package org.springframework.beans.factory.config;  </span><br><span class="line">  </span><br><span class="line">import org.springframework.beans.BeansException;  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">public interface BeanPostProcessor &#123;  </span><br><span class="line">  </span><br><span class="line">        //Bean初始化的前置处理器  </span><br><span class="line">    Object postProcessBeforeInitialization(Object bean, String beanName) throws BeansException;  </span><br><span class="line">  </span><br><span class="line">    //Bean初始化的后置处理器  </span><br><span class="line">    Object postProcessAfterInitialization(Object bean, String beanName) throws BeansException;  </span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>应用中自定义的Bean，可以实现这个接口，并覆盖这两个方法来控制Bean的初始化过程，即在Bean的初始化之前做一件事，即调用postProcessBeforeInitialization方法，也可以在Bean的初始化之后做一件事，即调用postProcessAfterInitialization方法。那么这两个方法究竟是如何被Spring调用的呢？</p>
<ol start="2">
<li><p>在Bean的初始化过程中，会调用initializeBean方法，该方法的源码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">protected Object initializeBean(final String beanName, final Object bean, RootBeanDefinition mbd) &#123;  </span><br><span class="line">        if (System.getSecurityManager() != null) &#123;  </span><br><span class="line">            AccessController.doPrivileged(new PrivilegedAction&lt;Object&gt;() &#123;  </span><br><span class="line">                @Override  </span><br><span class="line">                public Object run() &#123;  </span><br><span class="line">                    invokeAwareMethods(beanName, bean);  </span><br><span class="line">                    return null;  </span><br><span class="line">                &#125;  </span><br><span class="line">            &#125;, getAccessControlContext());  </span><br><span class="line">        &#125;  </span><br><span class="line">        else &#123;  </span><br><span class="line">            invokeAwareMethods(beanName, bean);  </span><br><span class="line">        &#125;  </span><br><span class="line">  </span><br><span class="line">        Object wrappedBean = bean;  </span><br><span class="line">        if (mbd == null || !mbd.isSynthetic()) &#123;  </span><br><span class="line">            //执行BeanPostProcessor扩展点的PostProcessBeforeInitialization进行修改实例化Bean  </span><br><span class="line">            wrappedBean = applyBeanPostProcessorsBeforeInitialization(wrappedBean, beanName);  </span><br><span class="line">        &#125;  </span><br><span class="line">  </span><br><span class="line">        try &#123;  </span><br><span class="line">            //调用Bean的初始化方法,这个初始化方法是在BeanDefinition中通过定义init-method属性指定的  </span><br><span class="line">            //同时,如果Bean实现了InitializingBean接口,那么这个Bean的afterPropertiesSet实现也不会被调用  </span><br><span class="line">            invokeInitMethods(beanName, wrappedBean, mbd);  </span><br><span class="line">        &#125;  </span><br><span class="line">        catch (Throwable ex) &#123;  </span><br><span class="line">            throw new BeanCreationException(  </span><br><span class="line">                    (mbd != null ? mbd.getResourceDescription() : null),  </span><br><span class="line">                    beanName, &quot;Invocation of init method failed&quot;, ex);  </span><br><span class="line">        &#125;  </span><br><span class="line">  </span><br><span class="line">        if (mbd == null || !mbd.isSynthetic()) &#123;  </span><br><span class="line">            //执行BeanPostProcessor扩展点的PostProcessAfterInitialization进行修改实例化Bean  </span><br><span class="line">            wrappedBean = applyBeanPostProcessorsAfterInitialization(wrappedBean, beanName);  </span><br><span class="line">        &#125;  </span><br><span class="line">        return wrappedBean;  </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>BeanPostProcessor起作用的方式<br>先说下invokeInitMethods方法，这个是真正的Bean的初始化方法，我们可以看到在该方法之前有一个方法applyBeanPostProcessorsBeforeInitialization，该方法实现Bean初始化的前置处理，可以看下该方法的源码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">@Override  </span><br><span class="line">    public Object applyBeanPostProcessorsBeforeInitialization(Object existingBean, String beanName)  </span><br><span class="line">            throws BeansException &#123;  </span><br><span class="line">  </span><br><span class="line">        Object result = existingBean;  </span><br><span class="line">        for (BeanPostProcessor beanProcessor : getBeanPostProcessors()) &#123;  </span><br><span class="line">            result = beanProcessor.postProcessBeforeInitialization(result, beanName);  </span><br><span class="line">            if (result == null) &#123;  </span><br><span class="line">                return result;  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">        return result;  </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>这个方法中会通过getBeanPostProcessors方法去获取Bean所实现的所有的BeanPostProcessor接口，并调用其postProcessBeforeInitialization方法来实现在Bean的初始化之前做一些预处理<br>在invokeInitMethods方法之后，有一个applyBeanPostProcessorsAfterInitialization方法，该方法实现Bean的初始化的后置处理，可以看下该方法的源码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">@Override  </span><br><span class="line">    public Object applyBeanPostProcessorsAfterInitialization(Object existingBean, String beanName)  </span><br><span class="line">            throws BeansException &#123;  </span><br><span class="line">  </span><br><span class="line">        Object result = existingBean;  </span><br><span class="line">        for (BeanPostProcessor beanProcessor : getBeanPostProcessors()) &#123;  </span><br><span class="line">            result = beanProcessor.postProcessAfterInitialization(result, beanName);  </span><br><span class="line">            if (result == null) &#123;  </span><br><span class="line">                return result;  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">        return result;  </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>与前置处理类似，也是获取Bean实现的所有BeanPostProcessor接口，然后调用所有接口的postProcessAfterInitialization后置处理方法</p>
<ol start="4">
<li>BeanNameAware，BeanClassLoaderAware，BeanFactoryAware接口起作用的方式<br>大家注意到initializebean方法中有一个invokeAwareMethods方法，先看下这个方法的源码：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">private void invokeAwareMethods(final String beanName, final Object bean) &#123;  </span><br><span class="line">        if (bean instanceof Aware) &#123;  </span><br><span class="line">            if (bean instanceof BeanNameAware) &#123;  </span><br><span class="line">                ((BeanNameAware) bean).setBeanName(beanName);  </span><br><span class="line">            &#125;  </span><br><span class="line">            if (bean instanceof BeanClassLoaderAware) &#123;  </span><br><span class="line">                ((BeanClassLoaderAware) bean).setBeanClassLoader(getBeanClassLoader());  </span><br><span class="line">            &#125;  </span><br><span class="line">            if (bean instanceof BeanFactoryAware) &#123;  </span><br><span class="line">                ((BeanFactoryAware) bean).setBeanFactory(AbstractAutowireCapableBeanFactory.this);  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>举例来说，当应用自定义的Bean实现了BeanNameAware接口，如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public class MyBean implements BeanNameAware &#123;  </span><br><span class="line">    private String beanName;  </span><br><span class="line">  </span><br><span class="line">    void setBeanName(String name) &#123;  </span><br><span class="line">        this.beanName = name;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这样就可以获取到该Bean在Spring容器中的名字，原理就是上述invokeAwareMethods方法中，判断了如果bean实现了BeanNameAware接口，就会调用该Bean覆盖的BeanNameAware接口的setBeanName方法，这样MyBean中就获取到了该Bean在Spring容器中的名字。<br>BeanClassLoaderAware接口和BeanFactoryAware接口同理，可以分别获取Bean的类装载器和bean工厂</p>
<ol start="5">
<li>InitializeBean接口起作用的方式<br>最后来说下真正的初始化方法invokeInitMethods，该方法的源码如下：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">protected void invokeInitMethods(String beanName, final Object bean, RootBeanDefinition mbd)  </span><br><span class="line">            throws Throwable &#123;  </span><br><span class="line">  </span><br><span class="line">        boolean isInitializingBean = (bean instanceof InitializingBean);  </span><br><span class="line">        if (isInitializingBean &amp;&amp; (mbd == null || !mbd.isExternallyManagedInitMethod(&quot;afterPropertiesSet&quot;))) &#123;  </span><br><span class="line">            if (logger.isDebugEnabled()) &#123;  </span><br><span class="line">                logger.debug(&quot;Invoking afterPropertiesSet() on bean with name &apos;&quot; + beanName + &quot;&apos;&quot;);  </span><br><span class="line">            &#125;  </span><br><span class="line">            if (System.getSecurityManager() != null) &#123;  </span><br><span class="line">                try &#123;  </span><br><span class="line">                    AccessController.doPrivileged(new PrivilegedExceptionAction&lt;Object&gt;() &#123;  </span><br><span class="line">                        @Override  </span><br><span class="line">                        public Object run() throws Exception &#123;  </span><br><span class="line">                            ((InitializingBean) bean).afterPropertiesSet();  </span><br><span class="line">                            return null;  </span><br><span class="line">                        &#125;  </span><br><span class="line">                    &#125;, getAccessControlContext());  </span><br><span class="line">                &#125;  </span><br><span class="line">                catch (PrivilegedActionException pae) &#123;  </span><br><span class="line">                    throw pae.getException();  </span><br><span class="line">                &#125;  </span><br><span class="line">            &#125;  </span><br><span class="line">            else &#123;  </span><br><span class="line">                ((InitializingBean) bean).afterPropertiesSet(); //启动afterPropertiesSet,afterPropertiesSet是InitializingBean接口的方法  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">  </span><br><span class="line">        if (mbd != null) &#123;  </span><br><span class="line">            String initMethodName = mbd.getInitMethodName();    //获取用户自定义的初始化方法  </span><br><span class="line">            if (initMethodName != null &amp;&amp; !(isInitializingBean &amp;&amp; &quot;afterPropertiesSet&quot;.equals(initMethodName)) &amp;&amp;  </span><br><span class="line">                    !mbd.isExternallyManagedInitMethod(initMethodName)) &#123;  </span><br><span class="line">                invokeCustomInitMethod(beanName, bean, mbd);    //调用自定义的初始化方法  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>可以看到方法中判断了如果该Bean实现了InitializeBean接口，即bean instanceof InitializingBean == true，就会调用该Bean实现的Initializebean接口的afterPropertiesSet方法</p>
<ol start="6">
<li>自定义的初始化方法起作用的方式<br>上述代码中有一个方法getInitMethodName，可以获取用户自定义的初始化方法，然后通过调用invokeCustomInitMethod方法来执行用户自定义的初始化方法</li>
</ol>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope="" itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">jasonjie</p>
              <p class="site-description motion-element" itemprop="description">生活不只眼前的苟且，还有诗和远方的田野</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">14</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">2</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">jasonjie</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Muse</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
